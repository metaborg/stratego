module rules-to-multimatch

strategies
  rules-to-multimatch =
    debug(!"[i] rules-to-multimatch ")
  ; r2mm(id, order-preserving-make-set) <+ r2mm_fallback
  ; debug(!"[o] rules-to-multimatch ")

  r2mm(cond) = r2mm(cond, id)
  r2mm(cond, mod) = where(cond); mod; r2mm

rules
  // Empty def list
  r2mm: [] -> []

  // Single (rule/strategy) definition: skip
  r2mm: rs@[_] -> rs

  /*
   * Multiple definitions
   * Cases:
   * - Only rule definitions: group all into MM strategy
   * - Mixed rule and strategy definitions:
   *   + Group adjacent rules into MM strategy.
   *   + Return strategies as-is.
   *   + Repeat.
   */
  r2mm: ds@[RDefT(f, [], [], _) | _] -> [SDefT(f, [], [], MultiMatch(Linear, cases)) | strats]
  where
    <debug(!"[i] tw "); take-while(is-rdef-noargs); debug(!"[o] tw ")> ds => rdefs // rule def(s)
  ; <debug(!"[i] dw "); drop-while(is-rdef-noargs); debug(!"[o] dw ")> ds => defs  // empty list or (non-rule def and possibly other defs)
  ; <debug(!"[i] R2C "); map(rule-to-case); debug(!"[o] R2C ")> rdefs => cases
  ; <debug(!"rest (defs) "); r2mm> defs => strats

  r2mm: ds@[SDefT(_, _, _, _) | _] -> <conc> (defs, strats)
  where
    <debug(!"[i] tu "); take-until(is-rdef-noargs); debug(!"[o] tu ")> ds => defs  // strategy def(s)
  ; <debug(!"[i] du "); drop-until(is-rdef-noargs); debug(!"[o] du ")> ds => rdefs // empty list or (rule def and possibly other defs)
  ; <debug(!"rest (rdefs) "); r2mm> rdefs => strats

  rule-to-case: RDefT(_, _, _, s) -> MatchCase(pat, Build(body))
  where
    Rule(pat, body, conds) := s // TODO Handle conditions

strategies
  is-rdef-noargs = ?RDefT(_, [], [], _)

  internal r2mm_fallback = debug(!"[r2mm] "); id
  internal order-preserving-make-set = debug(!"[i/ms] "); reverse; make-set; reverse; debug(!"[o/ms] ")

//  r2mm: rs@[RDefT(f, sargs, targs, _) | _] -> SDefT(f, sargs', targs', mm)
//  where
//  <debug(!"rs ")> rs;
//    <map(VarDec(NewID, id))> sargs => sargs'
//  ; <map(VarDec(NewID, id))> targs => targs'
//  ; <map(\ VarDec(y, _) -> SVar(y) \ )> sargs' => svars
//  ; <map(\ VarDec(y, _) -> Var(y) \ )> targs' => vars
//  ; <debug(!"[i] RD "); map(RenameDefinition(|svars, vars)); debug(!"[o] RD ")> rs => rs'
//  ; <debug(!"[i] R2C "); map(rule-to-case); debug(!"[o] R2C ")> rs' => cases
//  ; mm := MultiMatch(Linear, cases)

//  RenameDefinition(|ys1, ys2) :
//    SDefT(_, xs1, xs2, s1) -> s3
//    where <map(\ VarDec(x2,_) -> x2 \ )> xs2 => zs2
//  ; <tsubs> (zs2, ys2, s1) => s2
//  ; {| RenameSVar :
//             <zip({?(VarDec(x1,_), y1)
//                   ; rules( RenameSVar : SVar(x1) -> y1 ) }
//              )> (xs1, ys1)
//       ; <alltd(RenameSVar)> s2 => s3
//          |}

//  JoinDefs2:
//    defs@[SDefT(f, sargs, targs, s) | _] -> SDefT(f, sargs', targs', mm)
//    where
//      <map(VarDec(NewID, id))> sargs => sargs'
//    ; <map(VarDec(NewID, id))> targs => targs'
//    ; <map(\ VarDec(y, t) -> SVar(y) \ )> sargs' => svars
//    ; <map(\ VarDec(y, t) -> Var(y) \ )> targs' => vars
//    ; <map(RenameDefinition(|svars, vars))> defs => ss
//    ; <map(debug)> ss
//    ; mm := MultiMatch(Linear, [])
