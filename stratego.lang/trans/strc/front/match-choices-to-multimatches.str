module match-choices-to-multimatches

imports
  signatures/core/strategies-sig
  signatures/core/terms-sig

  strc/stratego/strc/opt/bound-unbound-vars
  strc/stratego/strc/opt/stratego-laws
  strc/stratego/strc/strc/strc // log-timed

overlays
  MultiMatch(cases) = MultiMatch(Sequential(), cases)

  // TODO Fix semantics. Failure of a strategy in a choice tries the next strategy, while the resulting multimatch fails as a whole.
  
  // Suggestion: patterns of shape Match(p); ... ; Build(t) -> case | p where ...: t
  // Edge case: building unbound vars.

  MatchPattern(p) = Match(p)

  MatchSuccessPattern(p) = MatchPattern(p)
  MatchSuccessPattern(p, s) = Seq(MatchPattern(p), s)
  MatchSuccessPattern(vars, p, s) = Scope(vars, MatchSuccessPattern(p, s))

  ChoicePattern(s1, s2) = GuardedLChoice(s1, Id(), s2)
  ChoicePattern(match, rhs, next) = GuardedLChoice(match, rhs, next)

strategies
  sdeft-match-choices-to-multimatches =
  log-timed(
    simplify
  // TODO Is the analysis even necessary? Can just use the parent Scope.
  ; mark-bound-unbound-vars
  ; SDefT(id, id, id, match-choices-to-multimatches)
  ; strip-annos
  | "MatchBuild - translate", 1)

  // Used for testing
  match-choices-to-multimatches-test-NoDesugar =
    simplify-NoDesugar
  ; match-choices-to-multimatches
  
  match-choices-to-multimatches =
    topdown(try(translate-match-choices))
  ; simplify-clean // Remove vars from scopes if they are now scoped from a match case

  translate-match-choices =
    !MultiMatch(<MatchCasesChoice>)

  MatchCases =
    MatchCasesChoice
 <+ MatchCasesDefault

  MatchCasesChoice:
    ChoicePattern(s1, s2) -> [<MatchCase> s1 | <MatchCases> s2]

  // No fail needed in the last case; is implicit in MultiMatch.
  MatchCasesDefault: Fail() -> []
//  MatchCasesDefault = ![<MatchCase>]
  MatchCasesDefault =
    ![ScopedMatchCase(<collect-unbound-vars>, Anno(Wld(), Wld()), <id>)]

  // Merge MultiMatch cases
  MatchCase = ?MultiMatch(<id>)

  MatchCase:
    MatchSuccessPattern(p) -> ScopedMatchCase(x*, p, Id())
  where
    <collect-unbound-vars> p => x*

  MatchCase:
    MatchSuccessPattern(p, s) -> ScopedMatchCase(x*, p, s)
  where
    <collect-unbound-vars> p => x*

  MatchCase:
    MatchSuccessPattern(x1*, p, s) -> ScopedMatchCase(x1*, p, s)
  where
    <collect-unbound-vars> p => x2*
  with
    <restore(subseteq, debug(!"(x2*, x1*): "))> (x2*, x1*)

  collect-unbound-vars = collect(?Var(<id>){"unbound"})
