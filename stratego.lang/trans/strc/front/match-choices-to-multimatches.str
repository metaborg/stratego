module match-choices-to-multimatches

imports
  signatures/core/strategies-sig
  signatures/core/terms-sig

  strc/stratego/strc/lib/stratlib
  strc/stratego/strc/opt/stratego-laws

overlays
  MultiMatch(cases) = MultiMatch(Sequential(), cases)

  MatchPattern(p) = Match(p)

  MatchSuccessPattern(p) = MatchPattern(p)
  MatchSuccessPattern(p, s) = Seq(MatchPattern(p), s)
  MatchSuccessPattern(vars, p, s) = Scope(vars, MatchSuccessPattern(p, s))

  ChoicePattern(s1, s2) = GuardedLChoice(s1, Id(), s2)

strategies
  sdeft-match-choices-to-multimatches =
    SDefT(id, id, id, match-choices-to-multimatches)

  match-choices-to-multimatches =
    simplify // To lower number of possible patterns
  ; match-choices-to-multimatches1

  // Used for testing
  match-choices-to-multimatches-test-NoDesugar =
    simplify-NoDesugar
  ; match-choices-to-multimatches1
  
  match-choices-to-multimatches1 =
    topdown(try(translate-match-choices))
  ; simplify-clean // Remove vars from scopes if they are now scoped from a match case

  translate-match-choices =
    !MultiMatch(<MatchCasesChoice>)

  MatchCases =
    MatchCasesChoice
 <+ MatchCasesDefault

  MatchCasesChoice:
    ChoicePattern(s1, s2) -> [<MatchCase> s1 | <MatchCases> s2]

  // No fail needed in the last case; is implicit in MultiMatch.
  MatchCasesDefault: Fail() -> []
  MatchCasesDefault = ![<MatchCase>]
  MatchCasesDefault =
    ![ScopedMatchCase(<tvars>, Anno(Wld(), Wld()), <id>)]

  // Merge MultiMatch cases
  MatchCase = ?MultiMatch(<id>)

  MatchCase:
    MatchSuccessPattern(p) -> ScopedMatchCase(x*, p, Id())
  where
    <tvars> p => x*

  MatchCase:
    MatchSuccessPattern(p, s) -> ScopedMatchCase(x*, p, s)
  where
    <tvars> p => x2*
  ; <union> (x1*, x2*) => x*
