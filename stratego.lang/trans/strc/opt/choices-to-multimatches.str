module choices-to-multimatches

imports
  strc/front/desugar
  strc/lib/stratlib
  strc/strc/strc // log-timed

  strc/opt/bound-unbound-vars
  strc/opt/multimatch/decompose
  strc/opt/multimatch/guard
  strc/opt/multimatch/utils

  signatures/core/strategies-sig
  signatures/core/terms-sig

overlays
  MM(c) = MultiMatch(Sequential(), c)
  NoAnnoMatch(t) = Anno(t, Wld())

strategies
  choices-to-multimatches = log-timed(id
//  ; log-timed(desugar|"  0. Desugaring", 1) // everything should be desugared by now
  ; log-timed(mark-bound-unbound-vars|"  1. Marking (un)bound vars", 1)
  ; log-timed(
    topdown(try(repeat(choice-to-multimatch
               <+ extract-matches
               <+ extract-righthandsides)))
    | "  2. Translating choices", 1)
  ; log-timed(bottomup(try(lift-defaults))|"  3. Lifting defaults", 1)
  ; log-timed(strip-annos|"  4. Stripping annos", 1)
  ; log-timed(desugar|"  5. Desugaring", 1)
  | "Optimisation: choices to multimatches", 1)

strategies

  /* VERIFIED
    foo = match sequential
            case x | p where s1: s2
            case ..
          end
       < id + match sequential
            case y | q where s3: s4
            case ... 
          end

    foo' = match sequential
           case x | p where s1: s2
           case .. 
           case y | q where s3: s4
           case ... 
         end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c1*), Id(), MM(c2*)) ->
    MM([c1*, c2*])

  /* VERIFIED
    bar = match sequential
            case ...
            case x | p where s1: s2 
          end < s3 + s4

    bar' = match sequential
            case ...
            case x | p where s1: s2; s3
            case   | _ where s4: id
          end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c*), s3, s4) ->
    MM(c'*)
  where
    <split-init-last> c* => (init*, last)
  ; ScopedGuardedMatchCase(x*, p, s1, s2) := last
  with
    c1 := ScopedGuardedMatchCase(x*, p, s1, Seq(s2, s3))
  ; c2 := ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s4, Id())
  ; <at-last(![c1, c2])> init* => c'*

  /* VERIFIED
    foo0 = s1 < s2 + s3
  
    foo0' = match sequential
              case | _ where s1: s2
              case | _ where s3: id
            end
  */
  choice-to-multimatch:
    GuardedLChoice(s1, s2, s3) ->
    MM([
      ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s1, s2)
    , ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s3, Id())
    ])

  /* VERIFIED
    qux = match sequential
            case ...
            case   | _ where s1 < s2 + s3: id
          end
  
    qux' = match sequential
            case ...
            case   | _ where s1: s2
            case   | _ where s3: id
          end
  */
  choice-to-multimatch:
    MM(c*) ->
    MM(c'*)
  where
    <split-init-last> c* => (init*, last)
  ; !last => ScopedGuardedMatchCase([], p@<is-wld>, GuardedLChoice(s1, s2, s3), Id())
  with
    c1 := ScopedGuardedMatchCase([], p, s1, s2)
  ; c2 := ScopedGuardedMatchCase([], p, s3, Id())
  ; c'* := <at-last(![c1, c2])> init*

strategies

  /* VERIFIED
    baz = match sequential
            case ...
            case   | _ where {y*: ?q; s1}: s2
            case ...
          end

    baz' =  match sequential
              case ...
              case y* | q where s1: s2
              case ...
            end
  */
  extract-matches = MM(list-some(extract-match))


  extract-match:
    ScopedGuardedMatchCase(x*, p, Scope(y*, Seq(Match(q), s1)), s2) ->
    ScopedGuardedMatchCase(z*, q, s1, s2)
  where
    <is-wld + is-wld-core> p
  ; <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  extract-match:
    ScopedGuardedMatchCase(x*, p, Scope(y*, Match(q)), s2) ->
    ScopedGuardedMatchCase(z*, q, Id(), s2)
  where
    <is-wld + is-wld-core> p
  ; <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  extract-match:
    ScopedGuardedMatchCase(x*, p, Seq(Match(q), s1), s2) ->
    ScopedGuardedMatchCase(x*, q, s1, s2)
  where
    <is-wld + is-wld-core> p

  extract-match:
    ScopedGuardedMatchCase(x*, p, Match(q), s2) ->
    ScopedGuardedMatchCase(x*, q, Id(), s2)
  where
    <is-wld + is-wld-core> p

strategies
  extract-righthandsides = MM(list-some(extract-rhs))

  extract-rhs:
    ScopedGuardedMatchCase(x*, p, s1, s2) ->
    ScopedGuardedMatchCase(x*, p, Id(), s3)
  where
    <not(?Id()); always-succeeds> s1
  with
    s3 := <sequence-strategies> (s1, s2)

//  // FIX Causes undeclared vars
//  /*
//   * case x* | p where s1'; s1'': s2
//   * where s1' is not guaranteed to succeed
//   * and s1'' is guaranteed to succeed
//   * ->
//   * case x* | p where s1': s1''; s2
//   */
//  extract-rhs:
//    ScopedGuardedMatchCase(x*, p, s1, s2) ->
//    ScopedGuardedMatchCase(x*, p, s1', s3)
//  where
//    <oncetd(Seq(id, where(always-succeeds); ?s1''); ?Seq(<id>, _))> s1 => s1'
//  with
//    <sequence-strategies> (s1'', s2) => s3

strategies
  lift-defaults:
    MM(c*) -> MM([init*, last'*])
  where
    <split-init-last> c* => (init*, last)
  ; <lift-default> last => last'*

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case | p where match sequential
                    case xs | q where s1: s2
                    case ys | r where s3: s4
                  end: s
  ->
   case xs | q where s1: s2; s
   case ys | r where s3: s4; s
  */
  lift-default:
    ScopedGuardedMatchCase([], p, MM(c*), s) ->
    <map(ScopedGuardedMatchCase(id, id, id, <sequence-strategies> (<id>, s)))> c*
  where
    <is-wld + is-wld-core> p

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case | p where s: match sequential
                       case xs | q where s1: s2
                       case ys | r where s3: s4
                     end
  ->
   case xs | q where s; s1: s2
   case ys | r where s; s3: s4
  */
  lift-default:
    ScopedGuardedMatchCase([], p, s, MM(c*)) ->
    <map(ScopedGuardedMatchCase(id, id, <sequence-strategies> (s, <id>), id))> c*
  where
    <is-wld + is-wld-core> p

strategies

  /**
   * Determines whether a strategy always succeeds (without side effects).
   */
  always-succeeds =
    ?Id()
  + Build(
      ?Path(CurP())
    + not(oncetd(id
        // No (potentially) unbound vars in build
        + ?Var(_){"unbound"}
        + ?Var(_){"(un)bound"}
        // No list builds where the tail is not a list
        + ?Op("Cons", <not(?Op("Nil", _) + ?Op("Cons", _))>)
        // No exploded builds where the constructor is a Var
        + ?Explode(_, _))
      )
    )
  + ?Match(Var(_){"unbound"})
  + Seq(always-succeeds, always-succeeds)
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(always-succeeds, always-succeeds, id)
                                , GuardedLChoice(always-fails, id, always-succeeds)
                                , GuardedLChoice(id, always-succeeds, always-succeeds))
  + Scope(id, always-succeeds)

  /**
   * Determines whether a strategy always fails (without side effects).
   */
  always-fails =
    ?Fail()
  + Build(oncetd(
      ?Var(_){"unbound"}
    ))
  + ?Seq(_, _) < or(Seq(always-fails, id), Seq(id, always-fails))
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(id, always-fails, always-fails)
                                , GuardedLChoice(always-succeeds, always-fails, id)
                                , GuardedLChoice(always-fails, id, always-succeeds))
  + Scope(id, always-fails)

// helpers
strategies
  internal is-wld-core = ?NoAnno(<is-wld>)
