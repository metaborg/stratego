module choices-to-multimatches

imports
  strc/front/desugar
  strc/lib/stratlib

  strc/opt/bound-unbound-vars
  strc/opt/multimatch/decompose
  strc/opt/multimatch/guard
  strc/opt/multimatch/utils

  signatures/core/strategies-sig
  signatures/core/terms-sig

overlays
  MM(c) = MultiMatch(Sequential(), c)

strategies
  choices-to-multimatches = id
  ; desugar
  ; mark-bound-unbound-vars
  ; repeat(oncetd(choice-to-multimatch
               <+ extract-matches
               <+ extract-righthandsides))
  ; bottomup(try(lift-defaults))
  ; strip-annos
  ; desugar

strategies

  /* VERIFIED
    foo = match sequential
            case x | p where s1: s2
            case ..
          end
       <+ match sequential
            case y | q where s3: s4
            case ... 
          end

    foo' = match sequential
           case x | p where s1: s2
           case .. 
           case y | q where s3: s4
           case ... 
         end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c1*), Id(), MM(c2*)) ->
    MM([c1*, c2*])

  /* VERIFIED
    bar = match sequential
            case ...
            case x | p where s1: s2 
          end < s3 + s4

    bar' = match sequential
            case ...
            case x | p where s1: s2; s3
            case   | _ where s4: id
          end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c*), s3, s4) ->
    MM(c'*)
  where
    <split-init-last> c* => (init*, last)
  ; ScopedGuardedMatchCase(x*, p, s1, s2) := last
  with
    c := ScopedGuardedMatchCase(x*, p, s1, Seq(s2, s3))
  ; <at-last(![c])> init* => c'*

  /* VERIFIED
    foo0 = s1 < s2 + s3
  
    foo0' = match sequential
              case | _ where s1: s2
              case | _ where s3: id
            end
  */
  choice-to-multimatch:
    GuardedLChoice(s1, s2, s3) ->
    MM([
      ScopedGuardedMatchCase([], Anno(Wld(), Wld()), s1, s2)
    , ScopedGuardedMatchCase([], Anno(Wld(), Wld()), s3, Id()) 
    ])
//  where
//    <tvars; debug(!"tvars s1 ")> s1
//  ; <tvars; debug(!"tvars s2 ")> s2
//  ; <tvars; debug(!"tvars s3 ")> s3

  /* VERIFIED
    qux = match sequential
            case ...
            case   | _ where s1 < s2 + s3: id
          end
  
    qux' = match sequential
            case ...
            case   | _ where s1: s2
            case   | _ where s3: id
          end
  */
  choice-to-multimatch:
    MM(c*) ->
    MM(c'*)
  where
    <split-init-last> c* => (init*, last)
  ; !last => ScopedGuardedMatchCase([], p@<is-wld>, GuardedLChoice(s1, s2, s3), Id())
  with
    c1 := ScopedGuardedMatchCase([], p, s1, s2)
  ; c2 := ScopedGuardedMatchCase([], p, s3, Id())
  ; c'* := <at-last(![c1, c2])> init*

strategies

  /* VERIFIED
    baz = match sequential
            case ...
            case   | _ where {y: ?q; s1}: s2
          end

    baz' =  match sequential
              case ...
              case y | q where s1: s2
            end
  */
  extract-matches = MM(list-some(extract-match))

  extract-match:
    ScopedGuardedMatchCase(x*, p, Scope(y*, Seq(Match(q), s1)), s2) ->
    ScopedGuardedMatchCase(z*, q, s1, s2)
  where
    <is-wld + is-wld-core> p
  ; <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  extract-match:
    ScopedGuardedMatchCase(x*, p, Scope(y*, Match(q)), s2) ->
    ScopedGuardedMatchCase(z*, q, Id(), s2)
  where
    <is-wld + is-wld-core> p
  ; <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  extract-match:
    ScopedGuardedMatchCase(x*, p, Seq(Match(q), s1), s2) ->
    ScopedGuardedMatchCase(x*, q, s1, s2)
  where
    <is-wld + is-wld-core> p

  extract-match:
    ScopedGuardedMatchCase(x*, p, Match(q), s2) ->
    ScopedGuardedMatchCase(x*, q, Id(), s2)
  where
    <is-wld + is-wld-core> p

strategies
  extract-righthandsides = MM(list-some(extract-rhs))

  extract-rhs:
    ScopedGuardedMatchCase(x*, p, s1, s2) ->
    ScopedGuardedMatchCase(x*, p, Id(), s3)
  where
    <not(?Id()); always-succeeds> s1
  with
    s3 := <sequence-strategies> (s1, s2)

  /*
   * case x* | p where s1'; s1'': s2
   * where s1' is not guaranteed to succeed
   * and s1'' is guaranteed to succeed
   * ->
   * case x* | p where s1': s1''; s2
   */
  extract-rhs:
    ScopedGuardedMatchCase(x*, p, s1, s2) ->
    ScopedGuardedMatchCase(x*, p, s1', s3)
  where
    <oncetd(Seq(id, where(always-succeeds); ?s1''); ?Seq(<id>, _))> s1 => s1'
  with
    <sequence-strategies> (s1'', s2) => s3

strategies
  lift-defaults:
    MM(c*) -> MM([init*, last'*])
  where
    <split-init-last> c* => (init*, last)
  ; <lift-default> last => last'*

  // This is only valid for the very last case.
  // TODO Verify validity.
  lift-default:
    ScopedGuardedMatchCase([], p, MM(c*), s) ->
    <map(ScopedGuardedMatchCase(id, id, id, <sequence-strategies> (<id>, s)))> c*
  where
    <is-wld + is-wld-core> p

  // This is only valid for the very last case.
  // TODO Verify validity.
  lift-default:
    ScopedGuardedMatchCase([], p, s, MM(c*)) ->
    <map(ScopedGuardedMatchCase(id, id, <sequence-strategies> (s, <id>), id))> c*
  where
    <is-wld + is-wld-core> p

strategies

  /**
   * Determines whether a strategy always succeeds (without side effects).
   */
  always-succeeds =
    ?Id()
  // TODO Build and Match can contain more than vars, which should succeed too.
  // Probably needs a build-always-succeeds strategy.
  + Build(where(collect-om(?Var(_){"unbound"} + ?Var(_){"(un)bound"}); ?[]))
  + Match(where(collect-om(?Var(_){"bound"} + ?Var(_){"(un)bound"}); ?[]))
  + Seq(always-succeeds, always-succeeds)
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(always-succeeds, always-succeeds, id)
                                , GuardedLChoice(always-fails, id, always-succeeds)
                                , GuardedLChoice(id, always-succeeds, always-succeeds))
  + Scope(id, always-succeeds)

  /**
   * Determines whether a strategy always fails (without side effects).
   */
  always-fails =
    ?Fail()
  + Build(where(collect-om(?Var(_){"unbound"}; ?[_ | _])))
  + ?Seq(_, _) < or(Seq(always-fails, id), Seq(id, always-fails))
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(id, always-fails, always-fails)
                                , GuardedLChoice(always-succeeds, always-fails, id)
                                , GuardedLChoice(always-fails, id, always-succeeds))
  + Scope(id, always-fails)
