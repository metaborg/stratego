module choices-to-multimatches

imports
  strc/front/desugar
  strc/lib/stratlib
  strc/strc/strc // log-timed

  strc/opt/bound-unbound-vars
  strc/opt/stratego-laws
  strc/opt/multimatch/decompose
  strc/opt/multimatch/guard
  strc/opt/multimatch/utils

  signatures/core/strategies-sig
  signatures/core/terms-sig

  libstratego-lib

overlays
  MM(c) = MultiMatch(Sequential(), c)
  NoAnnoMatch(t) = Anno(t, Wld())

strategies
  choices-to-multimatches = log-timed(id
//  ; log-timed(desugar|"  0. Desugaring", 1) // everything should be desugared by now
  ; log-timed(mark-bound-unbound-vars|"  1. Marking (un)bound vars", 1)
  ; log-timed(
    downup(
      try(repeat(choice-to-multimatch, extract-matches))
    ; try(extract-righthandsides)
    , try(lift-defaults))
    | "  2. Translating choices & lifting defaults", 1)
//  ; log-timed(bottomup(try(lift-defaults))|"  3. Lifting defaults", 1)
  ; log-timed(strip-annos|"  4. Stripping annos", 1)
  ; log-timed(simplify|"  5. Simplifying", 1)
  | "Optimisation: choices to multimatches", 1)

strategies

  /* VERIFIED
    foo = match sequential
            case x* | p when s1: s2
            case ..
          end
       < id + match sequential
            case y* | q when s3: s4
            case ... 
          end

    foo' = match sequential
           case x* | p when s1: s2
           case .. 
           case y* | q when s3: s4
           case ... 
         end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c1*), Id(), MM(c2*)) ->
    MM([c1*, c2*])

  /* VERIFIED
    bar = match sequential
            case x* | p when sg: sr
            case y* | q when sg': sr'
          end < s2 + s3

    bar' = match sequential
            case x* | p when sg: sr; s2
            case y* | q when sg': sr'; s2
            case    | _ when s3: id
          end
  */
  // TODO NOTE: Duplicates s2. Not valid if s2 is not a pure operation.
  choice-to-multimatch:
    GuardedLChoice(MM(c1*), s2, s3) ->
    MM([c1'*, c2'*])
  with
    c1'* := <map(ScopedGuardedMatchCase(id, id, id, <sequence-strategies> (<id>, s2)))> c1*
  ; if <?MM(c2*)> s3
    then c2'* := c2*
    else c2'* := [ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s3, Id())]
    end

  /* VERIFIED
    foo0 = s1 < s2 + s3
  
    foo0' = match sequential
              case | _ when s1: s2
              case | _ when s3: id
            end
  */
  choice-to-multimatch:
    GuardedLChoice(s1, s2, s3) ->
    MM([
      ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s1, s2)
    , ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s3, Id())
    ])

strategies

  /* VERIFIED
    baz = match sequential
            case ...
            case without pattern, with match in guard
            case ...
          end

    baz' =  match sequential
              case ...
              case with pattern, without match in guard
              case ...
            end
  */
  extract-matches = MM(list-some(extract-match))

  /*
    case   | _ when {y*: ?q; s1}: s2
    ->
    case y* | q when s1: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Scope(y*, Seq(Match(q), s1)), s2) ->
    ScopedGuardedMatchCase(z*, q, s1, s2)
  where
    <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  /*
    case   | _ when {y*: ?q}: s2
    ->
    case y* | q when id: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Scope(y*, Match(q)), s2) ->
    ScopedGuardedMatchCase(z*, q, Id(), s2)
  where
    <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  /*
    case   | _ when ?q; s1: s2
    ->
    case y* | q when s1: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Seq(Match(q), s1), s2) ->
    ScopedGuardedMatchCase(x*, q, s1, s2)

  /*
    case   | _ when ?q: s2
    ->
    case y* | q when id: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Match(q), s2) ->
    ScopedGuardedMatchCase(x*, q, Id(), s2)

strategies
  extract-righthandsides = MM(list-some(extract-rhs))

  /*
    case x* | p when s1: s2
    ->
    case x* | p when id: s1; s2
    
    Note: only if s1 always succeeds.
  */
  extract-rhs:
    ScopedGuardedMatchCase(x*, p, s1, s2) ->
    ScopedGuardedMatchCase(x*, p, Id(), s3)
  where
    <not(?Id()); always-succeeds> s1
  with
    s3 := <sequence-strategies> (s1, s2)

strategies
  lift-defaults = MM(at-last([lift-default]; flatten-list))

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case xs | _ when match sequential
                    case ys | q when s1: s2
                    case zs | r when s3: s4
                  end: s
  ->
   case xs | q when s1; s2: s
   case ys | r when s3; s4: s
  */
  lift-default:
    ScopedGuardedMatchCase(xs, NoAnnoMatch(Wld()), MM(c*), s) ->
    <map(ScopedGuardedMatchCase(<conc> (xs, <id>), id, <sequence-strategies> (<id>, s), id))> c*

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case | _ when s: match sequential
                       case xs | q when s1: s2
                       case ys | r when s3: s4
                     end
  ->
   case xs | q when s; s1: s2
   case ys | r when s; s3: s4
  */
  lift-default:
    ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s, MM(c*)) ->
    <map(ScopedGuardedMatchCase(id, id, <sequence-strategies> (s, <id>), id))> c*

strategies

  /**
   * Determines whether a strategy always succeeds (without side effects).
   */
  always-succeeds =
    ?Id()
  + ?Build(_) < Build(
      ?Path(CurP())
    + not(oncetd(fail
        // No (potentially) unbound vars in build
        + ?Var(_){"unbound"}
        + ?Var(_){"(un)bound"}
        // No list builds
        + ?Op("Cons", _)
        // No list builds where the tail is not a list (TODO Fix)
//        + ?Op("Cons", <not(?Op("Nil", _) + ?Op("Cons", _))>)
        // No exploded builds where the constructor is a Var
        + ?Explode(_, _)
      ))
    )
  + ?Match(Var(_){"unbound"})
  + Seq(always-succeeds, always-succeeds)
  + ?GuardedLChoice(_, _, _) < (GuardedLChoice(always-succeeds, always-succeeds, id)
                              + GuardedLChoice(always-fails, id, always-succeeds)
                              + GuardedLChoice(id, always-succeeds, always-succeeds))
  + Scope(id, always-succeeds)

  /**
   * Determines whether a strategy always fails (without side effects).
   */
  always-fails =
    ?Fail()
  + ?Build(_)
    < where(oncetd(
      ?Var(_){"unbound"}
      // TODO Add list build with non-list tail
    ))
  + ?Seq(_, _) < or(Seq(always-fails, id), Seq(id, always-fails))
  + ?GuardedLChoice(_, _, _) < (GuardedLChoice(id, always-fails, always-fails)
                              + GuardedLChoice(always-succeeds, always-fails, id)
                              + GuardedLChoice(always-fails, id, always-fails))
  + Scope(id, always-fails)
