module choices-to-multimatches

imports
  strc/front/desugar
  strc/lib/stratlib
  strc/strc/strc // log-timed

  strc/opt/bound-unbound-vars
  strc/opt/stratego-laws
  strc/opt/multimatch/decompose
  strc/opt/multimatch/guard
  strc/opt/multimatch/utils

  signatures/core/strategies-sig
  signatures/core/terms-sig

overlays
  MM(c) = MultiMatch(Sequential(), c)
  NoAnnoMatch(t) = Anno(t, Wld())

strategies
  choices-to-multimatches = log-timed(id
//  ; log-timed(desugar|"  0. Desugaring", 1) // everything should be desugared by now
  ; log-timed(mark-bound-unbound-vars|"  1. Marking (un)bound vars", 1)
  ; log-timed(
    topdown(repeat(choice-to-multimatch
                <+ extract-matches
                <+ extract-righthandsides))
    | "  2. Translating choices", 1)
  ; log-timed(bottomup(try(lift-defaults))|"  3. Lifting defaults", 1)
  ; log-timed(strip-annos|"  4. Stripping annos", 1)
  ; log-timed(simplify|"  5. Simplifying", 1)
  | "Optimisation: choices to multimatches", 1)

strategies

  /* VERIFIED
    foo = match sequential
            case x* | p when s1: s2
            case ..
          end
       < id + match sequential
            case y* | q when s3: s4
            case ... 
          end

    foo' = match sequential
           case x* | p when s1: s2
           case .. 
           case y* | q when s3: s4
           case ... 
         end
  */
  choice-to-multimatch:
    GuardedLChoice(MM(c1*), Id(), MM(c2*)) ->
    MM([c1*, c2*])

  /* TODO Check. Not correct?
    bar = match sequential
            case ...
            case x | p where s1: s2 
          end < s3 + s4

    bar' = match sequential
            case ...
            case x | p where s1: s2; s3
            case   | _ where s4: id
          end
  */
//  choice-to-multimatch:
//    GuardedLChoice(MM(c*), s3, s4) ->
//    MM(c'*)
//  where
//    <split-init-last> c* => (init*, last)
//  ; ScopedGuardedMatchCase(x*, p, s1, s2) := last
//  with
//    c1 := ScopedGuardedMatchCase(x*, p, s1, Seq(s2, s3))
//  ; c2 := ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s4, Id())
//  ; <at-last(![c1, c2])> init* => c'*

  /* VERIFIED
    foo0 = s1 < s2 + s3
  
    foo0' = match sequential
              case | _ when s1: s2
              case | _ when s3: id
            end
  */
  // TODO: This transformation is only useful if we can extract matches afterwards.
  choice-to-multimatch:
    GuardedLChoice(s1, s2, s3) ->
    MM([
      ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s1, s2)
    , ScopedGuardedMatchCase([], NoAnnoMatch(Wld()), s3, Id())
    ])

  /* TODO Check. Not correct?
    qux = match sequential
            case ...
            case | p when s1 < s2 + s3: s
          end

    qux' = match sequential
            case ...
            case | p when s1: s2; s
            case | p when s3: s
          end
  */
//  choice-to-multimatch:
//    MM(c*) ->
//    MM(c'*)
//  where
//    <split-init-last> c* => (init*, last)
//  ; !last => ScopedGuardedMatchCase([], p@<is-wld>, GuardedLChoice(s1, s2, s3), s)
//  with
//    c1 := ScopedGuardedMatchCase([], p, s1, <sequence-strategies> (s2, s))
//  ; c2 := ScopedGuardedMatchCase([], p, s3, s)
//  ; c'* := <at-last(![c1, c2])> init*

strategies

  /* VERIFIED
    baz = match sequential
            case ...
            case without pattern, with match in guard
            case ...
          end

    baz' =  match sequential
              case ...
              case with pattern, without match in guard
              case ...
            end
  */
  extract-matches = MM(list-some(extract-match))

  /*
    case   | _ when {y*: ?q; s1}: s2
    ->
    case y* | q when s1: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Scope(y*, Seq(Match(q), s1)), s2) ->
    ScopedGuardedMatchCase(z*, q, s1, s2)
  where
    <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  /*
    case   | _ when {y*: ?q}: s2
    ->
    case y* | q when id: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Scope(y*, Match(q)), s2) ->
    ScopedGuardedMatchCase(z*, q, Id(), s2)
  where
    <isect> (x*, y*) => []
  with
    z* := <union> (x*, y*)

  /*
    case   | _ when ?q; s1: s2
    ->
    case y* | q when s1: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Seq(Match(q), s1), s2) ->
    ScopedGuardedMatchCase(x*, q, s1, s2)

  /*
    case   | _ when ?q: s2
    ->
    case y* | q when id: s2
  */
  extract-match:
    ScopedGuardedMatchCase(x*, NoAnnoMatch(Wld()), Match(q), s2) ->
    ScopedGuardedMatchCase(x*, q, Id(), s2)

strategies
  extract-righthandsides = MM(list-some(extract-rhs))

  /*
    case x* | p when s1: s2
    ->
    case x* | p when id: s1; s2
    
    Note: only if s1 always succeeds.
  */
  extract-rhs:
    ScopedGuardedMatchCase(x*, p, s1, s2) ->
    ScopedGuardedMatchCase(x*, p, Id(), s3)
  where
    <not(?Id()); always-succeeds> s1
  with
    s3 := <sequence-strategies> (s1, s2)

  /*
   * case x* | p when s1'; s1'': s2
   * where s1' is not guaranteed to succeed
   * and s1'' is guaranteed to succeed
   * ->
   * case x* | p when s1': s1''; s2
   */
//  extract-rhs:
//    ScopedGuardedMatchCase(x*, p, s1, s2) ->
//    ScopedGuardedMatchCase(x*, p, s1', s3)
//  where
//    <oncetd(where(?Seq(_, <always-succeeds; ?s_succ>)); ?Seq(<id>, _))> s1 => s1'
//  ; <not(collect-one(?Scope(_, _)))> s1
//  // TODO Code below breaks some annotations on variables.
////  ; if <collect-one(?Scope(_, _)); debug(|"collected scope ")> s1 => s_scope then
////      <not(is-subterm); debug(|"no subterm ")> (s1', s_scope)
////    ; where(<pp-partial-StrategoLang-string; debug(|"strat:\n")> s1')
////    ; where(<pp-partial-StrategoLang-string; debug(|"scope:\n")> s_scope)
////    end
//  ; <sequence-strategies> (s_succ, s2) => s3

strategies
  lift-defaults = MM(at-last([lift-default]; flatten-list))

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case xs | _ when match sequential
                    case ys | q when s1: s2
                    case zs | r when s3: s4
                  end: s
  ->
   case xs | q where s1: s2; s
   case ys | r where s3: s4; s
  */
  lift-default:
    ScopedGuardedMatchCase(xs, p, MM(c*), s) ->
    <map(ScopedGuardedMatchCase(<conc> (xs, <id>), id, id, <sequence-strategies> (<id>, s)))> c*
  where
    <is-wld + is-wld-core> p

  // This is only valid for the very last case.
  // TODO Verify validity.
  /*
   case | _ when s: match sequential
                       case xs | q when s1: s2
                       case ys | r when s3: s4
                     end
  ->
   case xs | q when s; s1: s2
   case ys | r when s; s3: s4
  */
  lift-default:
    ScopedGuardedMatchCase([], p, s, MM(c*)) ->
    <map(ScopedGuardedMatchCase(id, id, <sequence-strategies> (s, <id>), id))> c*
  where
    <is-wld + is-wld-core> p

strategies

  /**
   * Determines whether a strategy always succeeds (without side effects).
   */
  always-succeeds =
    ?Id()
  + Build(
      ?Path(CurP())
    + not(oncetd(fail
        // No (potentially) unbound vars in build
        + ?Var(_){"unbound"}
        + ?Var(_){"(un)bound"}
        // No list builds
        + ?Op("Cons", _)
        // No list builds where the tail is not a list (TODO Fix)
//        + ?Op("Cons", <not(?Op("Nil", _) + ?Op("Cons", _))>)
        // No exploded builds where the constructor is a Var
        + ?Explode(_, _)
      ))
    )
  + ?Match(Var(_){"unbound"})
  + Seq(always-succeeds, always-succeeds)
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(always-succeeds, always-succeeds, id)
                                , GuardedLChoice(always-fails, id, always-succeeds)
                                , GuardedLChoice(id, always-succeeds, always-succeeds))
  + Scope(id, always-succeeds)

  /**
   * Determines whether a strategy always fails (without side effects).
   */
  always-fails =
    ?Fail()
  + Build(oncetd(
      ?Var(_){"unbound"}
    ))
  + ?Seq(_, _) < or(Seq(always-fails, id), Seq(id, always-fails))
  + ?GuardedLChoice(_, _, _) < or(GuardedLChoice(id, always-fails, always-fails)
                                , GuardedLChoice(always-succeeds, always-fails, id)
                                , GuardedLChoice(always-fails, id, always-succeeds))
  + Scope(id, always-fails)

// helpers
strategies
  internal is-wld-core = ?NoAnnoMatch(<is-wld>)
