module multimatch2java

signature
  sorts DTree
  constructors
//    Leaf    : int                                     -> DTree
    Leaf    : Strategy                                -> DTree
    Fail    :                                            DTree
//    Switch  : /*Occurrence **/ List((Constructor, DTree)) -> DTree
    Switch  : List((Term, DTree))                     -> DTree

    Swap    : int * DTree                             -> DTree

    Todo    :                                            DTree

  sorts Constructor
  constructors
    Constr  : string                                  -> Constructor

//  sorts Occurrence
//  constructors
//    Occ     : int                                     -> Occurrence

strategies
  /*======== Construct clause and action matrices ========*/
  // TODO implement specificity order
  multimatch2matrix: MultiMatch(Linear(), cases) -> (P', A')
  where
    <cases2matrix> cases => (P, A)
  ; P' := <reverse; debug(!"P (reversed): ")> P
  ; A' := <reverse; debug(!"A (reversed): ")> A

  /*
   *
   */
  cases2matrix = debug(!"cases: "); cases2matrix(|([], [])); debug(!"matrix: ")

  cases2matrix(|(P, A)): [] -> (P, A)

  cases2matrix(|(P, A)): [c | cs] -> (P'', A'')
  where
    <debug(!"[i] c2r: "); case2row; debug(!"[o] c2r: ")> c => (p1, a1)
  ; P' := [p1 | P]
  ; A' := [a1 | A]
  ; <debug(!"[i] c2m: "); cases2matrix(|(P', A')); debug(!"[o] c2m: ")> cs => (P'', A'')

  case2row: MatchCase(Anno(Op(op, params), Wld()), s) -> ([op | params], s)
  where
    <debug(!"(op, params): ")> (op, params)

  case2row = debug(!"case2row fallthrough "); ?t; log(|Critical(), "case2row failed ", t)


  /*======== Construct DFA from matrices =================*/
  matrix2dfa = CC

  /*
   * Compilation scheme from Maranget (2008).
   *
   * Changes w.r.t. paper:
   * (none)
   */
  CC = id
  <+ NoRows
  <+ WildcardsFirstRow
  <+ SelectColumn

  /*
   * 1. If matrix P has no row (i.e. m = 0) then matching always fails,
   * since there is no row to match.
   */
  NoRows: ms@([], _) -> Fail()
  where
    <debug(!"NoRows ")> ms

  /*
   * 2. If the first row of P exists and is constituted by wildcards,
   * then matching always succeeds and yields the first action.
   *
   * In particular, this case applies when there is at least
   * one row (m > 0) and no column (n = 0).
   */
  WildcardsFirstRow: ms@([r | _], A) -> Leaf(a1)
  where
    <map(is-wildcard)> r
  ; <debug(!"WildcardsFirstRow ")> ms
  ; a1 := <Hd> A

  /*
   * 3. In any other case, matrix P has at least one row and at least
   * one column (m > 0, n > 0). Furthermore, there exists at least one
   * column of which at least one pattern is not a wildcard. Select
   * one such column i.
   */
  SelectColumn: ms@(P, A) -> T
  where
    <debug(!"SelectColumn ")> ms
  ; i := <find-first-index(row-not-all-wildcards)> P
  ; l := <length> P
  ; <debug(!"  with i=")> i
  ; if <gti> (i, 1)
    /*
     * If i > 1 then swap columns 1 and i in both o and P,
     * as above, yielding decision tree A , and define:
     */
    then P' := <swapcols(|1, i)> P
        // TODO swap entries in o
       ; A' := <CC> (P', A)
       ; !Swap(i, A')
    else // TODO perform a bunch of recursive calls on possible head
         //      constructors and include them in a big Switch
         hcs          := <head-constructors> P
       ; specMatrices := <map(specialize(|(P, A)))> hcs
       ; !Switch(<zip> (hcs, specMatrices))
    end => T


  /*======== Generate Jave code from DFA =================*/
  dfa2java = fail


// Matrix-specific helper strategies
strategies
  is-wildcard = ?Wld()

  /*
   * Succeeds on a list if at least one element is not a wildcard.
   */
  row-not-all-wildcards = filter(not(is-wildcard)); ?[_ | _]

  /*
   * Get head constructors (constructors from first column) from matrix.
   */
  head-constructors = id
  ; is-list
  ; map(Hd)

  /*
   * Specialize the matrix `P -> A` to a certain constructor.
   */
  specialize(|(P, A)) = fail


// General-purpose helper strategies
strategies
  /*
   * Find index of first element in list for which `s` succeeds.
   * Index starts at 1.
   */
  find-first-index(s) = id
  ; where(is-list)
  ; split-fetch(s)
  ; Fst
  ; length
  ; inc

  /*
   * Swap elements `m` and `n` in a list.
   * Index starts at 1.
   */
  swap(|m, n): xs -> ys
  where
    <debug(!"Swapping ")> (m, n, xs)
  ; <is-list> xs
  ; elM := <index(|m)> xs
  ; elN := <index(|n)> xs
  ; xs' := <set-index> (<dec> m, elN, xs)
  ; xs'' := <set-index> (<dec> n, elM, xs')
  ; ys := xs''

  swapcols(|m, n): xs -> ys
  where
    <debug(!"Swapping cols ")> (m, n, xs)
  ; <is-list> xs
  ; ys := <map(swap(|m, n))> xs
