module multimatch/decompose

imports
  strc/c/escaping-variables // is-ListOp

  strc/opt/multimatch/matrix
  strc/opt/multimatch/utils

  strc/front/desugar

  strj/s2j                                // is-TupleOp

  signatures/core/strategies-sig
  signatures/core/terms-sig

overlays
  ExplodeNoAnno(t, anno_cons) = Explode(NoAnno(t), anno_cons)
  NoAnno(t) = Anno(t, Wld())

strategies
  /*
   * Determine default case for matrix.
   *
   * Maranget (2008), fig. 1.
   */
  default = Matrix(?[_ | <id>], remove-all(non-default-row); map(restore(default-row, fatal-err(|"ERROR - no default: "))))
  default-row: Row([<is-wld> | ps], s_a, s_g, s_rhs) -> Row(ps, s_a, s_g, s_rhs)

  non-default-row = ?Row([<non-default-head> | _], _, _, _) // by definition
  non-default-head =
    ?Op(_, _)
  + ?Explode(_, _)
  + ?Var(_) // Could be a default row, but needs an assignment first.
  + ?Int(_)
  + ?Str(_)
  + ?Real(_)

strategies
  /*
   * Get head constructors from list of (constructor) patterns.
   *
   * Maranget (2008), sec 4, step 3a.
   */
  constructors-om =
    ?Col(<id>, _, _, _)
  ; remove-all(where(is-wld + ?As(_, <is-wld>)))
  ; foldr(![], union, ![<constructor-om>])

  tswitch-arms =
    ?Col(<id>, _, _, _)
  ; remove-all(where(is-wld + ?As(_, <is-wld>)))
  ; map(split(cons-type, constructor-om))
  ; ?p*
  ; foldr(![], union, ![<Fst>]) // Set of types
  ; map(\ t -> <split(id, <retain-all(where(Fst; ?t); Snd); make-set> p*)> t \) // [(c, [t*])*]

  /*
   * Specialize the matrix to a certain constructor.
   *
   * Maranget (2008), fig. 1.
   */
  specialize(|c) =
    specialize-set(id|c)

  specialize-set(smod|c) =
    Matrix(specialize-occs(|c), filter(specialize-row(|c); smod))

  specialize-row(|c) =
    Row(specialize-pats(|c), id, id, id)

  specialize-occs(|c): occs@[o | os*] -> [o*, os*]
    with o* := <specialize-occ(|c)> o

  specialize-occ-by-arity(|a):
    p -> <range; map(\ i -> SubP(p, <int-to-string> i) \)> (0, a)

  // Annotations
  constructor-om:               Anno(c, ann)        -> AnnoC()
  specialize-pats(|AnnoC()):    [Anno(c, ann) | ps*] -> [c, ann | ps*]
  specialize-pats(|AnnoC()):    [<is-wld> | ps*]     -> <prepend(|Wld(), 2)> ps*
  specialize-occ(|AnnoC()): p -> [p, AnnoP(p)]

  // Tuples + lists + constructor applications
  arity = ?Op(_, <length>)
  arity: ExplodeNoAnno(Op("Nil", []), NoAnno(Op("Nil", _))) -> 0
  arity: ExplodeNoAnno(Op("Nil", []), NoAnno(Op("Cons", _))) -> 2

  arity =
    ?ExplodeNoAnno(f, <implode-anno-list; length>)
  ; where(not(!f => Op(_, _)))

  p-arity = ?FunC(_, <string-to-int>)
  p-arity = ?TupleC(<string-to-int>)

  // Tuples
  constructor-om:               c@Op("", _)          -> TupleC(<arity; int-to-string> c)
  cons-type:                    Op("", _)             -> TupleT()
  specialize-pats(|TupleC(x)):  [c@Op("", qs*) | ps*]  -> [qs*, ps*]
    where
      a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|TupleC(x)):  [<is-wld> | ps*]       -> <prepend(|Wld(), a)> ps*
    where a := <string-to-int> x
  specialize-occ(|TupleC(x)) =
    specialize-occ-by-arity(|<string-to-int> x)

  // Lists
  constructor-om:               c@Op(f, ts)         -> FunC(f, <arity; int-to-string> c)
    where <is-ListOp> c
  cons-type:                    Op("Nil", [])       -> LisT()
  cons-type:                    Op("Cons", [_, _])  -> LisT()
  specialize-occ(|FunC("Nil", "0")) = ![]
  specialize-occ(|FunC("Cons", "2")): p -> [ HeadP(p), TailP(p) ]

  // Constructor applications
  constructor-om:               c@Op(f, ts)         -> FunC(f, <arity; int-to-string> c)
    where <not(is-ListOp + is-TupleOp)> c
  cons-type:                    c@Op(_, _)          -> ApplT()
    where <not(is-ListOp + is-TupleOp)> c
  specialize-pats(|FunC(f, x)): [c@Op(f, qs*) | ps*] -> [qs*, ps*]
    where
      <not(is-TupleOp)> c
    ; a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|FunC(_, x)): [<is-wld> | ps*]        -> <prepend(|Wld(), a)> ps*
    with a := <string-to-int> x
  specialize-occ(|FunC(_, x)) =
    specialize-occ-by-arity(|<string-to-int> x)

  /* Exploded terms */
  // Tuple
  constructor-om: c@ExplodeNoAnno(Str(""), _) -> TupleC(<arity; int-to-string> c)
  cons-type:      ExplodeNoAnno(Str(""), _) -> TupleT()
  specialize-pats(|TupleC(x)):
    [c@ExplodeNoAnno(Str(""), qs*) | ps*]  -> [qs'*, ps*]
  with
    a := <string-to-int> x
  ; qs'* := <implode-anno-list> qs*
  where
    <eq> (a, <length> qs'*)

  // List
  // Exploded pattern with `[]` constructor and 0 or more arguments
  constructor-om: ExplodeNoAnno(Op("Nil", []), NoAnno(Op("Nil", _))) -> FunC("Nil", "0")
  constructor-om: ExplodeNoAnno(Op("Nil", []), NoAnno(Op("Cons", _))) -> FunC("Cons", "2")
  cons-type:    c@ExplodeNoAnno(Op("Nil", []), _) -> LisT()
  specialize-pats(|FunC(f, a)):
    [c@ExplodeNoAnno(Op("Nil", []), NoAnno(Op(f, qs*))) | ps*] -> [qs*, ps*]
  where
    <arity; int-to-string> c => a

  // String
  constructor-om:
    c@ExplodeNoAnno(s@Str(_), _) -> s' // String
  where
    <arity> c => 0
  ; s' := <DesugarOnce> s
  ; <not(equal)> (s, s')

  cons-type:
    c@ExplodeNoAnno(s@Str(_), _) -> StringT() // String
  where
    <arity> c => 0
  ; s' := <DesugarOnce> s
  ; <not(equal)> (s, s')

  specialize-pats(|c): [<?ExplodeNoAnno(l, _)> | ps*] -> ps*
    where
      c := <constructor-om; is-literal-cons> l

  // Int
  constructor-om: c@ExplodeNoAnno(Int(x), _) -> Int(x)
  where <arity> c => 0
  cons-type:      c@ExplodeNoAnno(Int(x), _) -> IntT()
  where <arity> c => 0

  // Real
  constructor-om: c@ExplodeNoAnno(Real(x), _) -> Real(x)
  where <arity> c => 0
  cons-type:      c@ExplodeNoAnno(Real(x), _) -> RealT()
  where <arity> c => 0

  // Application
  constructor-om: c@ExplodeNoAnno(Str(f), _) -> FunC(f, <arity; int-to-string> c)
  cons-type:      ExplodeNoAnno(Str(_), _) -> ApplT()
  specialize-pats(|FunC(f, x)): [c@ExplodeNoAnno(Str(f), anno_cons) | ps*] -> [qs*, ps*]
    with
      a := <string-to-int> x
    ; qs* := <implode-anno-list> anno_cons
    where
      <eq> (a, <length> qs*)

  // TODO Constructor var (multiple types)
  cons-type:      ExplodeNoAnno(Var(x), _) -> [ApplT(), TupleT(), StringT(), IntT(), RealT()]

  /* Exploded terms (end) */

  // Literals
  is-literal-cons = ?StrC(_) + ?IntC(_) + ?RealC(_)
  constructor-om:               Str(s)              -> StrC(s)
  constructor-om:               Int(i)              -> IntC(i)
  constructor-om:               Real(r)             -> RealC(r)
  cons-type:                    Str(_)              -> StringT()
  cons-type:                    Int(_)              -> IntT()
  cons-type:                    Real(_)              -> RealT()
  specialize-pats(|c):         [<?l + is-wld> | ps*] -> ps*
    where c := <constructor-om; is-literal-cons> l
  specialize-occ(|<is-literal-cons>) = ![]

  // Variables
  is-wld = ?Wld()

  constructor-om = is-wld; fail // by definition
  specialize-pats(|<is-wld>) = fail // by definition

  // Helpers
  internal prepend(|t, n) = repeat(![t | <id>] | n)
  internal exploded-list-length = implode-anno-list; length
  internal ensure-list = is-list <+ MkSingleton

  internal implode-anno-list: NoAnno(Op("Cons", [e, tail])) -> [e | <implode-anno-list> tail]
  internal implode-anno-list: NoAnno(Op("Nil", [])) -> []
