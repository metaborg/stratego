module decompose

imports
  strc/stratego/strc/c/escaping-variables // is-ListOp
  strj/s2j                                // is-TupleOp

  strj/multimatch/matrix

  signatures/core/strategies-sig
  signatures/core/terms-sig
  signatures/sugar/strategies-sig // Assign

strategies
  /*
   * Determine default case for matrix.
   *
   * Maranget (2008), fig. 1.
   */
  default = Matrix(?[_ | <id>], remove-all(non-default-row); map(restore(default-row, debug(!"no default for "))))

  default-row: Row([<is-wld> | ps], [Id() | s*], a) -> Row(ps, s*, a)

  non-default-row = ?Row([<non-default-head> | _], _, _) // by definition
  non-default-head =
    ?Op(_, _)
  + ?Var(_) // Could be a default row, but needs an assignment first.
  + is-literal

strategies
  /*
   * Get head constructors from list of (constructor) patterns.
   *
   * Maranget (2008), sec 4, step 3a.
   */
  head-constructors =
    debug(!"[i] hcs: ")
  ; ?Col(t*, s*)
  ; c* := <zip; remove-wlds; map(split3(Fst; head-type <+ !(), Fst; head-constructor, Snd))> (t*, s*) // (t, c, s)
  ; collect-types; debug(!"types ")
  ; collect-cons(|c*)
  ; debug(!"[o] hcs: ")
  // TODO (?) Put guard-less arms in 'otherwise' (guarded by id) arm

  remove-wlds = remove-all(?(<is-wld>, _))
  // [(t, c, s)*] -> [t*]
  collect-types = foldr(![], union, ![<Fst>])
  // [(t, c, s)*], [t*] -> [(t, [(c, [s*])*])*]
  collect-cons(|c*) = map(\ t -> (t, <retain-all(where(Fst; ?t); Snd); make-set; collect-guards(|c*)> c*) \)
  // [(t, c, s)*], [c*] -> [(c*, [s*])*] 
  collect-guards(|c*) = map(\ c -> (c, <retain-all(where(Snd; ?c); Third); make-set-lr> c*) \)

  // TODO Rewrite with left fold
  make-set-lr = reverse; make-set; reverse

  /*
   * Specialize the matrix to a certain constructor.
   *
   * Maranget (2008), fig. 1.
   */
  specialize(|c) = Matrix(specialize-occs(|c), filter(specialize-row(|c)))

  specialize-row(|c) = Row(specialize-pats(|c), specialize-guards(|c), id)

  specialize-occs(|c): occs@[o | os*] -> [o*, os*]
    with o* := <specialize-occ(|c)> o

  specialize-occ-by-arity(|a):      p -> ps
    with
      i* := <range> (1, <inc> a)
    ; ps := <map(\ i -> Sub(p, <int-to-string> i) \)> i*

  // Annotations
  head-constructor:             Anno(c, ann)        -> Anno()
  specialize-pats(|Anno()):    [Anno(c, ann) | ps*] -> [c, ann | ps*]
  specialize-pats(|Anno()):    [<is-wld> | ps*]     -> <prepend(|Wld(), 2)> ps*
  specialize-guards(|Anno()):  [s | s*]             -> <prepend(|s, 2)> s*
  specialize-occ(|Anno()): p -> [p, Anno(p)]

  // Tuples + lists + constructor applications
  arity = ?Op(_, <length>)

  p-arity = ?Fun(_, <string-to-int>)
  p-arity = ?Tuple(<string-to-int>)

  specialize-guards(|c): [s | s*] -> <prepend(|s, a)> s*
    where a := <p-arity> c

  // Tuples
  head-constructor:             c@Op("", ts)          -> Tuple(<arity; int-to-string> c)
  head-type:                    Op("", _)             -> TupleT()
  specialize-pats(|Tuple(x)):  [c@Op("", qs*) | ps*]  -> [qs*, ps*]
    where
      a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|Tuple(x)):  [<is-wld> | ps*]       -> <prepend(|Wld(), a)> ps*
    where a := <string-to-int> x
  specialize-occ(|Tuple(x)) = specialize-occ-by-arity(|<string-to-int> x)

  // Lists
  head-constructor:             c@Op(f, ts)         -> Fun(f, <arity; int-to-string> c)
    where <is-ListOp> c
  head-type:                    Op("Nil", [])       -> LisT()
  head-type:                    Op("Cons", [_, _])  -> LisT()
  specialize-occ(|Fun("Nil", "0")) = ![]
  specialize-occ(|Fun("Cons", "2")): p -> [ Head(p), Tail(p) ]

  // Constructor applications
  head-constructor:             c@Op(f, ts)         -> Fun(f, <arity; int-to-string> c)
    where <not(is-ListOp + is-TupleOp)> c
  head-type:                    c@Op(_, _)          -> ApplT()
    where <not(is-ListOp + is-TupleOp)> c
  specialize-pats(|Fun(f, x)): [c@Op(f, qs*) | ps*] -> [qs*, ps*]
    where
      <not(is-TupleOp)> c
    ; a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|Fun(_, x)): [<is-wld> | ps*]        -> <prepend(|Wld(), a)> ps*
    with a := <string-to-int> x
  specialize-occ(|Fun(_, x)) = specialize-occ-by-arity(|<string-to-int> x)

  // Literals
  is-literal = ?Str(_) + ?Int(_) + ?Real(_)
  head-constructor = is-literal
  head-type:                    Str(_)              -> StringT()
  head-type:                    Int(_)              -> IntT()
  head-type:                    Real(_)              -> RealT()
  specialize-pats(|l):         [<?l + is-wld> | ps*] -> ps*
    where <is-literal> l
  specialize-guards(|<is-literal>) = ![]
  specialize-occ(|<is-literal>) = ![]

  // As-patterns
  head-constructor = ?As(_, <head-constructor>)
  head-type = ?As(_, <head-type>)

  aliases-to-guards =
    ?Matrix(p*@[p | _], row*)
  ; <map(try(alias-to-guard(|p)))> row* => row'*
  ; !Matrix(p*, row'*)

  alias-to-guard(|p):
    Row([As(t1, t2) | t*], [s1 | s*], s) ->
    Row([t2 | t*],         [s1' | s*], s)
  with
    guard := Assign(t1, Path(p)) // TODO See if this is desugared later.
  ; <combine-guards> (s1, guard) => s1'

  combine-guards: (Id(), s2) -> s2
  combine-guards: (s1, s2) -> Seq(s1, s2)

  // Variables
  is-var = ?Var(_)
  is-wld = ?Wld()
  head-constructor = is-wld; fail // by definition
  specialize-pats(|<is-wld>) = fail // by definition
  specialize-guards(|<is-wld>) = fail

  // Helpers
  prepend(|t, n) = repeat(![t | <id>] | n)
