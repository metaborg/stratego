module decompose

imports
  strc/stratego/strc/c/escaping-variables // is-ListOp
  strj/s2j                                // is-TupleOp

  strj/multimatch/matrix

  signatures/core/strategies-sig
  signatures/core/terms-sig

strategies
  /*
   * Determine default case for matrix.
   *
   * Maranget (2008), fig. 1.
   */
  default: Matrix(rows) -> Matrix(<filter(default-row)> rows)

  default-row: Row([Wld() | ps], a) -> Row(ps, a)
  default-row = ?Row([Fun(_, _) | _], _); fail // by definition

strategies
  /*
   * Get head constructors from list of (constructor) patterns.
   *
   * Maranget (2008), sec 4, step 3a.
   */
  head-constructors = debug(!"[i] hcs ")
  ; remove-all(is-variable)
  ; map(split(head-constructor, head-type <+ !()))

  /*
   * Specialize the matrix to a certain constructor.
   *
   * Maranget (2008), fig. 1.
   */
  specialize(|Matrix(rows)): cons -> Matrix(<filter(specialize-row(|cons))> rows)
  specialize-row(|c) = Row(specialize-pats(|c), id)

  specialize-occs(|c): occs@[o | os*] -> [o*, os*]
    with o* := <specialize-occ(|c)> o

  specialize-occ(|Anno()): p@Path(_) -> [p, <append-occ> (p, Ann())]
  specialize-occ(|Fun("Nil", "0")): Path(_) -> []
  specialize-occ(|Fun("Cons", "2")): p@Path(_) -> [ <append-occ> (p, Hd())
                                                  , <append-occ> (p, Tl()) ]
  specialize-occ(|Fun(_, x)) = specialize-occ'(|<string-to-int> x)
  specialize-occ(|Tuple(x)) = specialize-occ'(|<string-to-int> x)
  specialize-occ(|c) = where(<is-literal> c); ![]

  specialize-occ'(|a):      p@Path(_) -> ps
    where
      i* := <range> (1, <inc> a)
    ; ps := <map(\ i -> <append-occ> (p, Sub(<int-to-string> i)) \)> i*


  append-occ: (Path(os*), o) -> Path([os*, o*])
    with o* := [o]

  // Annotations
  head-constructor:             Anno(c, ann)        -> Anno()
  specialize-pats(|Anno()):    [Anno(c, ann) | ps*] -> [c, ann | ps*]
  specialize-pats(|Anno()):    [Wld() | ps*]        -> <prepend-wld(|2)> ps*

  // Tuples + constructor applications
  arity:                        Op(f, ts)           -> <length> ts

  // Tuples
  head-constructor:             c@Op("", ts)        -> Tuple(<arity; int-to-string> c)
  head-type:                    Op("", _)           -> TupleT()
  specialize-pats(|Tuple(x)):  [c@Op("", qs*) | ps*] -> [qs*, ps*]
    where
      a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|Tuple(x)):  [Wld() | ps*]        -> <prepend-wld(|a)> ps*
    where a := <string-to-int> x

  // Lists
  head-type:                    Op("Nil", [])       -> LisT()
  head-type:                    Op("Cons", [_, _])  -> LisT()

  // Constructor applications
  head-constructor:             c@Op(f, ts)         -> Fun(f, <arity; int-to-string> c)
    where <not(is-TupleOp)> c
  head-type:                    c@Op(_, _)          -> ApplT()
    where <not(is-ListOp + is-TupleOp)> c
  specialize-pats(|Fun(f, x)): [c@Op(f, qs*) | ps*] -> [qs*, ps*]
    where
      <not(is-TupleOp)> c
    ; a := <string-to-int> x
    ; <eq> (a, <arity> c)
  specialize-pats(|Fun(_, x)): [Wld() | ps*]        -> <prepend-wld(|a)> ps*
    with a := <string-to-int> x

  // Literals
  is-literal = ?Str(_) + ?Int(_) + ?Real(_)
  head-constructor = is-literal
  head-type:                    Str(_)              -> StringT()
  head-type:                    Int(_)              -> IntT()
  head-type:                    Real(_)              -> RealT()
  specialize-pats(|Str(s)):    [<?Str(s) + ?Wld()> | ps*] -> ps*
  specialize-pats(|Int(s)):    [<?Int(s) + ?Wld()> | ps*] -> ps*
  specialize-pats(|Real(s)):   [<?Real(s) + ?Wld()> | ps*] -> ps*

  // Variables
  is-variable = ?Var(_) + ?Wld()
  head-constructor = is-variable; fail // by definition
  specialize-pats(|Wld()) = fail // by definition

  prepend-wld(|n) = repeat(![Wld() | <id>] | n)
