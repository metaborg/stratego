module matrix2dfa

imports
  strj/multimatch/dfa
  strj/multimatch/matrix
  strj/multimatch/specialize

  signatures/core/terms-sig

strategies
  /*======== Construct DFA from matrices =================*/
  matrix2dfa = CC

  /*
   * Compilation scheme from Maranget (2008).
   *
   * Changes w.r.t. paper:
   * (none)
   */
  CC = NoRows
    <+ WildcardsFirstRow
    <+ SelectColumn

  /*
   * 1. If matrix P has no row (i.e. m = 0) then matching always fails,
   * since there is no row to match.
   */
  NoRows: m@Matrix([]) -> Fail()
  where
    <debug(!"NoRows ")> m

  /*
   * 2. If the first row of P exists and is constituted by wildcards,
   * then matching always succeeds and yields the first action.
   *
   * In particular, this case applies when there is at least
   * one row (m > 0) and no column (n = 0).
   */
  WildcardsFirstRow: m@Matrix([Row(ps, a) | _]) -> Leaf(a)
  where
    <map(is-wildcard)> ps
  ; <debug(!"WildcardsFirstRow ")> m

  /*
   * 3. In any other case, matrix P has at least one row and at least
   * one column (m > 0, n > 0). Furthermore, there exists at least one
   * column of which at least one pattern is not a wildcard. Select
   * one such column i.
   */
  SelectColumn: m@Matrix(rs) -> T
  where
    <debug(!"SelectColumn ")> m
  ; i := <find-first-col-index(not-all-wildcards)> m
  ; <debug(!"  with i=")> i
  ; if <gti> (i, 1)
    /*
     * If i > 1 then swap columns 1 and i in both o and P,
     * as above, yielding decision tree A , and define:
     */
    then // i > 1
         m' := <swap-cols(|1, i)> m
        // TODO swap entries in o
       ; A' := <CC> m'
       ; !Swap(i, A')
    else // i == 1
         /* TODO perform a bunch of recursive calls on possible head
                 constructors and include them in a big Switch */
         c            := <col(|i)> m
       ; hcs          := <head-constructors; make-set> c
       ; specMatrices := <map(specialize(|m))> hcs
       ; default      := <default; CC> m
       ; !Switch(<zip(\ (cons, mat) -> Alt(cons, <CC> mat) \)> (hcs, specMatrices), default)
    end => T

strategies
  /*
   * Get head constructors from list of (constructor) patterns.
   */
  head-constructors = id
  ; is-list
  ; map(head-constructor)

//  head-constructor: As(x, Anno(c, ann))             -> Fun("anno", 2) // TODO bind
  head-constructor: Anno(c, ann) -> Anno()
  head-constructor: Op(f, ts)   -> Fun(f, <length> ts)
  head-constructor: Str(s)      -> Str(s)
  head-constructor: Int(s)      -> Int(s)
  head-constructor: Real(s)     -> Real(s)
  head-constructor: Var(_)      -> Wld()
  head-constructor: Wld()       -> Wld()

  /*
   * Determine default case for matrix.
   */
  default: Matrix(rows) -> Matrix(<filter(default-row)> rows)
  default-row: Row([Wld() | ps], a) -> Row(ps, a)
