module multimatch/matrix2dfa

imports
  strj/multimatch/decompose
  strj/multimatch/guard
  strj/multimatch/matrix
  strj/multimatch/postprocess

  strc/stratego/strc/strc/strc

  signatures/core/strategies-sig
  signatures/core/terms-sig

strategies
  /*======== Construct DFA from matrices =================*/ 
  matrix2dfa =
    log-timed(CC | "DFA - Compilation", 1)
  ; log-timed(SimplifyDFA | "DFA - Simplification", 1)

  /*
   * Compilation scheme from Maranget (2008).
   *
   * Changes w.r.t. paper:
   * (none)
   */
  CC = NoRows
    <+ WildcardsFirstRow
    <+ SelectColumn

  /*
   * 1. If matrix P has no row (i.e. m = 0) then matching always fails,
   * since there is no row to match.
   */
  NoRows: m@Matrix(_, []) -> Fail()
  where
    <debug(!"NoRows ")> m

  /*
   * 2. If the first row of P exists and is constituted by wildcards,
   * then matching always succeeds and yields the first action.
   *
   * In particular, this case applies when there is at least
   * one row (m > 0) and no column (n = 0).
   * ================================================================
   * Produce an intermediate guarded leaf.
   * In a subsequent traversal, this guard can be pushed up to the switch arm.
   */
  WildcardsFirstRow: m@Matrix(_, [Row(ps, s_a, s_g, s_rhs) | _]) -> GuardedLeaf(s_rhs, s)
  where
    <map(is-wld)> ps
  ; <debug(!"WildcardsFirstRow ")> m
  with
    s := <combine-guards> (s_a, s_g)

  /*
   * 3. In any other case, matrix P has at least one row and at least
   * one column (m > 0, n > 0). Furthermore, there exists at least one
   * column of which at least one pattern is not a wildcard. Select
   * one such column i.
   */
  SelectColumn: m@Matrix([p | _], [_ | _]) -> T
  where
    <debug(!"SelectColumn ")> m
  with
    i := <find-first-col-index(not-all-wildcards)> m
  ; <debug(!"  with i=")> i
  ; if <gti> (i, 1) then
    /*
     * If i > 1 then swap columns 1 and i in both o and P,
     * and run the algorithm on the resulting matrix.
     */
      <swap-cols(|1, i); CC> m
    else
      <aliases-to-guards> m => m'
    ; <unwrap-annos <+ tswitch> (m', <col(|i)> m')
    end => T

  unwrap-annos: (m, col) -> <specialize(|hc); CC> m
  where
    <constructors-om> col => [hc@Anno()]
  ; debug(!"unwrapping annos... ")

  tswitch:
    (m@Matrix([p | _], [_ | _]), col) -> SwitchT(Type(p), talt*, s_def)
  with
    arm*    := <tswitch-arms> col
  ; s_def   := <default; CC> m
  ; talt*   := <map(talt(|m, p, s_def))> arm*

  talt(|m, p, s_def): (t, valt*) -> AltT(t, SwitchV(p', <map(valt(|m))> valt*, s_def))
  with
    p' := <extend-path-by-type(|t)> p

  valt(|m): (c, s*) -> GuardedAltV(c, guards)
  where <is-switchable> c
    ; <debug(!"valt ")> (c, s*)
  with guards := <map(!Guard(<id>, <specialize(|c); CC> m))> s*

  is-switchable = ?Fun(_, _)
                + is-literal
                + ?Tuple(_)
                + is-wld

  extend-path-by-type(|ApplT()) = !Con(<id>)
  extend-path-by-type(|LisT()) = id
  extend-path-by-type(|IntT()) = !Int(<id>)
  extend-path-by-type(|RealT()) = !Real(<id>)
  extend-path-by-type(|StringT()) = !Str(<id>)
  extend-path-by-type(|CtorT()) = <fatal-error> ["CtorT not implemented"]
  extend-path-by-type(|TupleT()) = !Size(<id>)
  extend-path-by-type(|RefT()) = <fatal-error> ["RefT not implemented"]
  extend-path-by-type(|BlobT()) = <fatal-error> ["BlobT not implemented"]
  extend-path-by-type(|PlaceT()) = <fatal-error> ["PlaceT not implemented"]
