module matrix2dfa

imports
  strj/multimatch/decompose
  strj/multimatch/matrix

  signatures/core/strategies-sig
  signatures/core/terms-sig

strategies
  /*======== Construct DFA from matrices =================*/ 
  matrix2dfa = CC

  /*
   * Compilation scheme from Maranget (2008).
   *
   * Changes w.r.t. paper:
   * (none)
   */
  CC = NoRows
    <+ WildcardsFirstRow
    <+ SelectColumn

  /*
   * 1. If matrix P has no row (i.e. m = 0) then matching always fails,
   * since there is no row to match.
   */
  NoRows: m@Matrix(_, []) -> Fail()
  where
    <debug(!"NoRows ")> m

  /*
   * 2. If the first row of P exists and is constituted by wildcards,
   * then matching always succeeds and yields the first action.
   *
   * In particular, this case applies when there is at least
   * one row (m > 0) and no column (n = 0).
   */
  WildcardsFirstRow: m@Matrix(_, [Row(ps, s*, a) | _]) -> a
  where
    <map(is-wld)> ps
  ; <debug(!"WildcardsFirstRow ")> m
  ; if <not(make-set; (?[] + ?[Id()]))> s* then
      <debug(!"DISMISSING GUARDS IN LEAF: ")> s*
    end

  /*
   * 3. In any other case, matrix P has at least one row and at least
   * one column (m > 0, n > 0). Furthermore, there exists at least one
   * column of which at least one pattern is not a wildcard. Select
   * one such column i.
   */
  SelectColumn: m@Matrix([p | _], [_ | _]) -> T
  where
    <debug(!"SelectColumn ")> m
  with
    i := <find-first-col-index(not-all-wildcards)> m
  ; <debug(!"  with i=")> i
  ; if <gti> (i, 1) then
    /*
     * If i > 1 then swap columns 1 and i in both o and P,
     * and run the algorithm on the resulting matrix.
     */
      <swap-cols(|1, i); CC> m
    else
      <aliases-to-guards> m => m'
    ; <col(|i); head-constructors> m' => hc*
    ; <debug(!"tswitch "); unwrap-annos <+ tswitch> (m', hc*)
    end => T

  unwrap-annos =
    ?(m, [(hc@Anno(), _, _)])
  ; debug(!"unwrapping annos... ")
  ; <specialize(|hc); CC> m

  tswitch:
    (m@Matrix([p | _], [_ | _]), hc*) -> SwitchT(Type(p), talt*, default)
  where
    <remove-all(where(Fst; is-switchable)); restore(?[], debug(!"Annotations or vars present in head constructors: "))> hc*
  with
    hts      := <map(Snd); make-set; debug(!"hts ")> hc*
  ; valt*    := <map(\ (c, t, s) -> (c, t, s, <specialize(|c)> m) \); debug(!"valt* ")> hc*
  ; tbranch* := <map(\ t -> (t, <retain-all(where(Snd; ?t))> valt*) \); debug(!"tbranch* ")> hts
  ; default  := <default; CC> m
  ; talt*    := <map(talt(|p, default))> tbranch*

  is-switchable = ?Fun(_, _)
                + is-literal
                + ?Tuple(_)
                + is-wld

  talt(|p, d): (t, valt*) -> AltT(t, <vswitch(|t, p, d)> valt*)

  valt: (c, _, [],     m) -> AltV(c, <CC> m)
  valt: (c, _, [Id()], m) -> AltV(c, <CC> m)

  valt: (c, _, s@[_ | _], m) -> GuardedAltV(c, <map(!AltVGuard(<id>, <CC> m))> s)
  where
    debug(!"valt (guarded) ")

  vswitch(|ApplT(), p, d) =
    !SwitchV(Con(p), <map(valt)>, d)

  vswitch(|LisT(), p, d) =
    !SwitchV(p, <map(valt)>, d)

  vswitch(|IntT(), p, d) =
    !SwitchV(Int(p), <map(valt)>, d)

  vswitch(|RealT(), p, d) =
    !SwitchV(Real(p), <map(valt)>, d)

  vswitch(|StringT(), p, d) =
    !SwitchV(Str(p), <map(valt)>, d)

  // Consider if this pattern can occur outside of an APPL.
  vswitch(|CtorT(), p, d) = <error> ["CtorT not implemented"]; fail

  vswitch(|TupleT(), p, d) =
    !SwitchV(Size(p), <map(valt)>, d)

  // TODO Find out if this is not yet deprecated.
  vswitch(|RefT(), p, d) = <error> ["RefT not implemented"]; fail

  // TODO Find out if this is not yet deprecated.
  vswitch(|BlobT(), p, d) = <error> ["BlobT not implemented"]; fail

  // TODO Find out if this is not yet deprecated.
  vswitch(|PlaceT(), p, d) = <error> ["PlaceT not implemented"]; fail
