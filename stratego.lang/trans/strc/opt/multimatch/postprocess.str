module multimatch/postprocess

imports
  strc/opt/multimatch/decompose
  strc/opt/multimatch/guard
  strc/opt/multimatch/utils

  signatures/core/strategies-sig

strategies
  desugar-dfa =
    repeat(
      oncebu(
        eliminate-guard
      <+ simplify-switch
      <+ lift-guard
      )
    )
  ; topdown(try(wrap-guarded-leaves); try(ensure-id-guard))

  optimise-dfa = bottomup(
    try(drop-unreachable-guards; try(eliminate-guard))
  )

strategies
  /*
   * SwitchT with just a default arm.
   *
   * Too aggressive? Only true if the path `p` is valid.
   */
  simplify-switch = ?SwitchT(p, [], Default(<id>))

  simplify-switch: SwitchT(p, [], GuardedDefault(guard*)) ->
                   GuardedLeafs(guard*)

  eliminate-guard =
    EliminateId
  + EliminateFail

  EliminateId: GuardedAltV(t, [Guard(<is-id-guard>, a)]) -> AltV(t, a)
  EliminateId: GuardedDefault([Guard(<is-id-guard>, a)]) -> Default(a)

  /*
   * TODO: Investigate whether removing definitely failing guards violates
   * soundness. Removing them too aggressively can lift the failure to a
   * higher level in the tree, resulting in falling back to a different default,
   * therefore changing the semantics of the tree.
   */
  EliminateFail =
    EliminateFail1

  EliminateFail1: GuardedDefault(guard*) -> Default(Fail())
  where
    <foldr(![], union, ![<?Guard(<id>, _)>])> guard* => [<is-fail-guard>]

  /*
   * Lift guards from guarded leafs to enclosing switch arm.
   *
   * Note: before doing this, all guarded arms have the same rhs.
   * This rewrite (possibly) violates that property (?).
   *
   * Desugar IR.
   */
  lift-guard: AltV(t, GuardedLeafs(g*)) ->
              GuardedAltV(t, g*)
  lift-guard: Default(GuardedLeafs(g*)) ->
              GuardedDefault(g*)

  /*
   * Merge guard from guarded leaf with surrounding guard.
   *
   * Desugar IR.
   */
  lift-guard: Guard(s1, GuardedLeafs([Guard(s2, s)])) ->
              Guard(s3, s)
  with
    <sequence-strategies> (s1, s2) => s3

  /*
   * Ensure that any guarded default has an `id`-guarded arm, which can
   * *always* be taken if any other match/guard does not succeed.
   *
   * Ensure soundness.
   */
  ensure-id-guard = GuardedDefault(at-end(![Guard(Id(), Fail())]))

  wrap-guarded-leaves:
    GuardedLeafs(guard*) ->
    SwitchT(Type(Cur()), [], GuardedDefault(guard*))

  /*
   * Remove any guarded arms *after* an `id`-guarded arm.
   *
   * Reduce code size.
   */
  drop-unreachable-guards =
    GuardedDefault(drop-after(?Guard(<is-id-guard>, _)))
  drop-unreachable-guards =
    GuardedAltV(id, drop-after(?Guard(<is-id-guard>, _)))
