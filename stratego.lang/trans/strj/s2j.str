
/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 * @author Lennart Kats
 * @author Eelco Visser
 */
module strj/s2j

imports
  strj/shared-constructors

//  libstrc
  libstratego-xtc
  libstratego-lib
  libjava-front
  libstratego-aterm

  strj/java-postprocess
  strj/java-optimize
  strj/java-simplify
  strj/variable-lifting
  strj/variable-access
  strj/backend-simplify
  strj/s2j-options
  strj/lib/dr-scoping
  signatures/gradual-types/signatures-sig
  signatures/gradual-types/internal-sig
  signatures/gradual-types/strategies-sig
  signatures/core/strategies-sig

  strc/opt/multimatch/multimatch2dfa
  strc/opt/multimatch/utils

signature
  constructors
    Next  : Term
    Match : Term * Exp -> Exp
    Offset: Int -> Term
    Frames: List(Term) -> Term
    Escape: Stm -> Strategy

    // stategoxt-annos extension:
    Override       : Strategy
    ProceedNoArgs  : Strategy
    Proceed        : List(Strategy) -> Strategy
    ProceedT       : List(Strategy) * List(Term) -> Strategy

overlays

  // Number of term/strategy arguments allowed by the default overloads of Strategy.invoke()
  // The number 5 was chosen mostly to support Aster-generated strategies.
  MAX_STATIC_TARGS = 5
  MAX_STATIC_SARGS = 5

strategies

  main-s2j =
    io-wrap(
      s2j-options
    ,
      s2j
    )

rules

  s2j =
      with(
        s2j-init-options
      ; record-main-classname
//      ; if <get-config> "--single-strategy"
//          then <get-config;base-filename;remove-extension> "-i"; rules(SingleStrategy := <id>)
//        end
      )
    ; log-timed(
        if <get-config> "--single-strategy"
          then backend-simplify-quiet
          else backend-simplify
        end
      | "Backend preprocessing succeeded", 1
      )
    ; log-timed(
        dr-scope-all-verbose(
          if <get-config> "--single-strategy"
            then java-compile-spec-single
            else if <get-config> "--boilerplate"
              then java-compile-spec-boilerplate
              else java-compile-spec
            end
          end
        )
      ; java-simplify
      | "Backend transformation succeeded", 1
      )
    ; log-timed(
        olevel1(java-optimize)
      | <conc-strings> ("Backend optimization succeeded -O ", <get-config; int-to-string> "-O"), 1
      )
    ; log-timed(
        java-relabel
      ; if <get-config> "-p" then
          // Use multiple .java files for programs with a package name
          java-split-class
        ; if not(IsIncrementalCompilation); not(<get-config> "--single-strategy") then
            java-add-alias-classes
          end
        ; if <get-config> "--single-strategy" then
            Tl // drop main class. Hard to remove in java-compile-spec-single, so removed here
          end
        else
          ![<id>]
        end
      | "Backend postprocessing succeeded", 1
      )

  record-main-classname =
    (<get-config> "-o" <+ strc-getoutfile(!""))
  ; base-filename
  ; jify
  ; remove-extension
  ; rules(
      MainClassName := <id>
    )
  ; app-name := <!"-p"; get-config; string-tokenize('.'); last <+ MainClassName>
  ; rules(
      ConstantContainerClass := app-name
      ApplicationName        := app-name
    )

  jify =
    escape(Jify)

  Jify(x) =
    \['_'  | cs] -> ['_' | <x> cs]\
  <+
    Cify(x)

  java-compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) ->
    |[
     ~package-dec?: pkgname

     ~import-dec*:imports

     import org.strategoxt.lang.*;
     import org.strategoxt.lang.gradual.*;
     import org.spoofax.interpreter.terms.*;
     import static org.strategoxt.lang.Term.*;
     import org.spoofax.interpreter.library.AbstractPrimitive;
     import java.util.ArrayList;
     import java.util.Arrays;
     import java.lang.ref.WeakReference;

     @SuppressWarnings("all")
     public class x_name {

       protected static final boolean TRACES_ENABLED = e_traces;
       protected static ITermFactory constantFactory;
       private static WeakReference<Context> initedContext;
       private static boolean isIniting;

       ~*cnst-decls
       ~*cnstr-decls

       public static Context init(Context context) {
         synchronized (x_name.class) {
           if (isIniting) return null;
           try {
             isIniting = true;
             ITermFactory termFactory = context.getFactory();
             if (constantFactory == null) { // don't reinit constants by default
               initConstructors(termFactory);
               initConstants(termFactory);
             }
             if (initedContext == null || initedContext.get() != context) {
               ~*import-inits
               ~*def-inits
               context.registerComponent("~x_name'");
             }
             initedContext = new WeakReference<Context>(context);
             constantFactory = termFactory;
           } finally {
             isIniting = false;
           }
           return context;
         }
       }

       public static Context init() {
         return init(new Context());
       }

       ~*main

       ~*<java-split-method> |[
         public static void initConstructors(ITermFactory termFactory) {
           ~*cnstr-inits
         }
       ]|

       ~*<java-split-method> |[
         public static void initConstants(ITermFactory termFactory) {
           ~*cnst-inits
         }
       ]|

       ~*constant-defs
       ~*function-defs
       ~*lifted-defs

       ~*register
     }
  ]|
  with
      <list-loop(try(JavaTranslate))> ops
    ; <list-loop(try(JavaTranslate))> defs
    ; imports       := <java-imports>
    ; import-inits  := <java-init-imports>
    ; x_name        := <MainClassName>
    ; x_name'       := <ApplicationName>
    ; pkgname       := <!package-dec? |[ package ~x:<get-config> "-p"; ]| <+ !None()>
    ; main          := <java-main-methods>
    ; register      := <java-interop-registerers> (defs, ops)
    ; switch <get-config> "--stacktrace"
        case 0: e_traces := |[ false ]|
        case 1: e_traces := |[ true ]|
        case 2: e_traces := |[ x_name.class.desiredAssertionStatus() ]|
      end
  with
    rules(
      CurrentLiftedFrame := None()
    )
  ; function-defs := <map(translate-outer-definition-top)> defs
  ; add-default-constructors
  ; constant-defs := <map(translate-constant-definition)> <get-config <+ ![]> "-D"
  ; lifted-defs   := <bagof-LiftedDef>
  ; cnstr-decls   := <bagof-ConstructorDecl>
  ; cnstr-inits   := <bagof-ConstructorInit>
  ; def-inits     := <bagof-DefInit>
  ; cnst-decls    := <bagof-ConstDecl>
  ; cnst-inits    := <bagof-ConstInit; concat; reverse>

  java-compile-spec-single :
    Specification([Signature([Constructors([])]), Strategies(defs)]) ->
    |[
     ~package-dec?: pkgname

     ~import-dec*:imports

     import org.strategoxt.lang.*;
     import org.strategoxt.lang.gradual.*;
     import org.spoofax.interpreter.terms.*;
     import static org.strategoxt.lang.Term.*;
     import org.spoofax.interpreter.library.AbstractPrimitive;
     import java.util.ArrayList;
     import java.util.Arrays;
     import java.lang.ref.WeakReference;

     @SuppressWarnings("all")
     public class x_name {
       ~*function-defs
       ~*lifted-defs
     }
  ]|
  with
      <list-loop(try(JavaTranslate))> defs
    ; imports       := <java-imports>
    ; pkgname       := <!package-dec? |[ package ~x:<get-config> "-p"; ]| <+ !None()>
    ; x_name        := <MainClassName>
    ; switch <get-config> "--stacktrace"
        case 0: e_traces := |[ false ]|
        case 1: e_traces := |[ true ]|
        case 2: e_traces := |[ true ]|
      end
  with
    rules(
      CurrentLiftedFrame := None()
    )
  ; function-defs := <map(translate-outer-definition-top)> defs
  ; add-default-constructors
  ; lifted-defs   := <bagof-LiftedDef>

  java-compile-spec-boilerplate :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) ->
    |[
     ~package-dec?: pkgname

     ~import-dec*:imports

     import org.strategoxt.lang.*;
     import org.strategoxt.lang.gradual.*;
     import org.spoofax.interpreter.terms.*;
     import static org.strategoxt.lang.Term.*;
     import org.spoofax.interpreter.library.AbstractPrimitive;
     import java.util.ArrayList;
     import java.util.Arrays;
     import java.lang.ref.WeakReference;

     @SuppressWarnings("all")
     public class x_name {

       protected static final boolean TRACES_ENABLED = e_traces;
       protected static ITermFactory constantFactory;
       private static WeakReference<Context> initedContext;
       private static boolean isIniting;

       public static Context init(Context context) {
         synchronized (x_name.class) {
           initTypeInfo(context);
           if (isIniting) return null;
           try {
             isIniting = true;
             ITermFactory termFactory = context.getFactory();
             if (constantFactory == null) { // don't reinit constants by default
               initConstructors(termFactory);
               initConstants(termFactory);
             }
             if (initedContext == null || initedContext.get() != context) {
               ~*import-inits
               ~*def-inits
               context.registerComponent("~x_name'");
             }
             initedContext = new WeakReference<Context>(context);
             constantFactory = termFactory;
           } finally {
             isIniting = false;
           }
           return context;
         }
       }

       public static Context init() {
         return init(new Context());
       }

       ~*main

       ~*<java-split-method> |[
         public static void initConstructors(ITermFactory termFactory) {
           // ~*cnstr-inits
         }
       ]|

       ~*<java-split-method> |[
         public static void initConstants(ITermFactory termFactory) {
           // ~*cnst-inits
         }
       ]|

       ~*<java-split-method> |[
         public static void initTypeInfo(Context compiledContext) {
           bstm3*
           compiledContext.typeInfo.finishRegistration();
         }
       ]|

       ~*constant-defs

       ~*register
     }
  ]|
  with id
    ; <list-loop(try(JavaTranslate))> ops
    ; <list-loop(try(JavaTranslate))> defs
    ; imports       := <java-imports>
    ; import-inits  := <java-init-imports>
    ; x_name        := <MainClassName>
    ; x_name'       := <ApplicationName>
    ; pkgname       := <!package-dec? |[ package ~x:<get-config> "-p"; ]| <+ !None()>
    ; main          := <java-main-methods>
    ; bstm3*        := <filter(java-register-signature)> ops
    ; register      := <java-interop-registerers> (defs, ops)
    ; switch <get-config> "--stacktrace"
        case 0: e_traces := |[ false ]|
        case 1: e_traces := |[ true ]|
        case 2: e_traces := |[ x_name.class.desiredAssertionStatus() ]|
      end
  with
    rules(
      CurrentLiftedFrame := None()
    )
    ; constant-defs := <map(translate-constant-definition)> <get-config <+ ![]> "-D"
    ; def-inits := <filter(outer-definition-DefInit)> defs

  java-imports =
    <get-config> "-la"
  ; map(java-import)
  <+
    ![]

  java-init-imports =
    <get-config> "-la"
  ; map(java-init-import)
  <+
    ![]

  java-import :
    x -> TypeImportOnDemandDec(TypeName(Id(x')))
    with
      x' := <jify> x

  java-init-import :
    x -> |[ x'.Main.init(context); ]|
    with
      x' := <jify> x

  java-main-methods :
    _ ->
    class-body-dec* |[
      public static Strategy getMainStrategy() { // used by SSL_EXT_java_call
        return null;
      }
    ]|
    where
      <get-config> "--library"
    ; not(<get-config> "-m")

  java-main-methods :
    _ ->
    |[
     public static void main(String args[]) {
       Context context = init();
       context.setStandAlone(true);
       try {
         IStrategoTerm result;
         try {
           result = context.invokeStrategyCLI(x_main.instance, "~x_name", args);
         } finally {
           context.getIOAgent().closeAllFiles();
         }
         if (result == null) {
           System.err.println("~x_name" + (TRACES_ENABLED ? ": rewriting failed, trace:" : ": rewriting failed"));
           context.printStackTrace();
           context.setStandAlone(false);
           System.exit(1);
         } else {
           System.out.println(result);
           context.setStandAlone(false);
           System.exit(0);
         }
       } catch (StrategoErrorExit exit) {
         context.setStandAlone(false);
         System.err.println(exit.getLocalizedMessage());
         System.exit(exit.getValue());
       } catch (StrategoExit exit) {
         context.setStandAlone(false);
         System.exit(exit.getValue());
       }
     }

     public static IStrategoTerm mainNoExit(String... args) throws StrategoExit {
       return mainNoExit(new Context(), args);
     }

     public static IStrategoTerm mainNoExit(Context context, String... args) throws StrategoExit {
       try {
         init(context);
         return context.invokeStrategyCLI(x_main.instance, "~x_name", args);
       } finally {
         context.getIOAgent().closeAllFiles();
       }
     }

     public static Strategy getMainStrategy() { // used by SSL_EXT_java_call
       return x_main.instance;
     }
    ]|
    where
      <get-config> "-m" <+ not(<get-config> "--library")
    with
      x_name := <MainClassName>
    ; main   := <get-config <+ !"main"> "-m"
    ; x_main := <conc-strings> (<cify; jify; dollars-for-capitals> main, "_0_0")

  // TODO: do interop strategy additions in a fully on-demand fashion?
  //       (need to adapt VarScope class to do so)
  java-interop-registerers :
    (defs, sigs) ->
    class-body-dec* |[
      public static void registerInterop(org.spoofax.interpreter.core.IContext context, Context compiledContext) {
        new InteropRegisterer().registerLazy(context, compiledContext, InteropRegisterer.class.getClassLoader());
      }

      // InteropRegisterer is used for dynamic loading and gets lifted to a separate class
      @SuppressWarnings("unused")
      public static class InteropRegisterer extends org.strategoxt.lang.InteropRegisterer {
        @Override
        public void register(org.spoofax.interpreter.core.IContext context, Context compiledContext) {
          register(context, compiledContext, context.getVarScope());
        }

        @Override
        public void registerLazy(org.spoofax.interpreter.core.IContext context, Context compiledContext, ClassLoader classLoader) {
          registerLazy(context, compiledContext, classLoader, context.getVarScope());
        }

        ~*<java-split-method>  |[
          private void register(org.spoofax.interpreter.core.IContext context, Context compiledContext, org.spoofax.interpreter.core.VarScope varScope) {
            compiledContext.registerComponent("~x_name");
            x_name.init(compiledContext);
            bstm1*
          }
        ]|

        ~*<java-split-method>  |[
          private void registerLazy(org.spoofax.interpreter.core.IContext context, Context compiledContext, ClassLoader classLoader, org.spoofax.interpreter.core.VarScope varScope) {
            compiledContext.registerComponent("~x_name");
            x_name.init(compiledContext);
            bstm2*
          }
        ]|
      }
    ]|
    with
      // HACK: non-lazy defs are used only to trick javac to compile everything atm
      bstm1* := <filter(java-register-strategy)> defs
    ; bstm2* := <filter(java-register-strategy-lazy)> defs
    ; x_name := <ApplicationName>

  java-register-strategy :
    SDefT(x,_,_,_) ->
    |[ varScope.addSVar("~x'", new InteropSDefT(x.instance, context)); ]|
    with
      x' := <undo-dollars-for-capitals> x

  java-register-strategy-lazy :
    SDefT(x,_,_,_) ->
    |[ varScope.addSVar("~x'", new InteropSDefT(classLoader, "~y", context)); ]|
    with
      x' := <undo-dollars-for-capitals> x
    with
      y := <conc-strings> (<get-config> "-p", ".", x)
    <+
      y := <conc-strings> (<ApplicationName>, "$", x)

  java-register-signature:
    OpDecl(str, optype) ->
    bstm |[ compiledContext.typeInfo.registerConstructor(e_sort, e_str, Arrays.asList(e_ty*)); ]|
  with
    (e_sort, e_ty*) := <java-reg-optype> optype
  ; e_str := Lit(String([Chars(str)]))

  java-register-signature:
    OpDeclInj(FunType([from], to)) ->
    bstm |[ compiledContext.typeInfo.registerInjection(e_from, e_to); ]|
  with
    e_from := <translate-ConstType> from
  ; e_to := <translate-ConstType> to

  // TODO: write java-register-signature for other OpDeclInj which are injections from TupleType to a Sort?

  java-reg-optype =
    translate-ConstType; !(<id>, [])

  java-reg-optype:
    FunType(ty*, sort) -> (e_sort, e_ty*)
  with
    e_sort := <translate-ConstType> sort
  ; e_ty* := <map(translate-ConstType)> ty*

  translate-ConstType = ?ConstType(<translate-Type>)
  translate-ConstType = ?DynT(_); translate-Type

rules

  translate-constant-definition : // TODO: check if constant strategy definition name not taken
    (name, value) -> def'
    with
      name'  := <dollars-for-capitals> name
    ; def    := SDefT(name', [], [], Build(value))
    ; def'   := <translate-outer-definition> def

  translate-outer-definition-top =
    if IsIncrementalCompilation then
      {| ConstDecl, ConstInit, java-Cache, ConstantContainerClass:
        if ?SDefT(name, _, _, _) then
          rules(
            ConstantContainerClass := name
          )
        end;
        translate-outer-definition;
        if ConstInit then
          with(add-local-constant-decls; ?x); !x
        end
      |}
    else
      translate-outer-definition
    end

  add-local-constant-decls:
    Semicolon() -> Semicolon()

  add-local-constant-decls:
    type-dec |[
      mod* class x extends y {
        ~*members
      }
    ]| ->
    type-dec |[
      mod* class x extends y {
        private volatile boolean isInitialized;
        ~*cnst-decls
        ~*members'
        private void init() {
          synchronized (x.class) {
            if (!isInitialized) {
              ~*cnst-inits'
              isInitialized = true;
            }
          }
        }
      }
    ]|
  with
    x_main      := <MainClassName>
  ; cnst-decls  := <bagof-ConstDecl>
  ; cnst-inits  := <bagof-ConstInit; concat; reverse>
  ; cnst-inits' := <alltd(add-constant-factory-container(|x_main))> cnst-inits
  ; members'    := <oncetd(add-local-constant-inits)> members

  add-local-constant-inits:
    |[ mod* IStrategoTerm x_name(param*) {
         bstm*
       }
    ]| ->
    |[ mod* IStrategoTerm x_name(param*) {
         if (!isInitialized) // Java 5+ safe double-checked locking
           init();
         bstm*
       }
    ]|

  add-constant-factory-container(|x_main):
    AmbName(Id("termFactory")) -> expr |[ x_main.constantFactory ]|

  translate-outer-definition =
     translate-outer-definition-plain
  <+ translate-outer-definition-override
  <+ translate-outer-definition-extend
  <+ translate-outer-definition-internal
  <+ translate-outer-definition-conflict

  translate-outer-definition-plain :
    SDefT(x, s*, t*, s){a*} ->
    type-dec |[
       @SuppressWarnings("all")
       public static class x extends Strategy {
         public static final x instance = new x();

         ~body*
         ~invokedynamic*
       }
    ]|
    with
      body*          := <translate-definition-body>
    ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)

  translate-outer-definition-override :
    AnnoDef([Override()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       @SuppressWarnings("all")
       private static final class x' extends x {
         // Initialize proceed with a new instance, to avoid stacking overrides due to repeated dynamic loads.
         // NOTE: this prevents multiple overrides of a strategy.
         private static final x proceed = new x();
         ~(body*)
         @Override public String getName() { return "~x"; }
       }
    ]|
    with
      x' := <conc-strings> (x, "_override")
    ; bstm_init := <outer-definition-DefInit(|x')> def
    ; rules(DefInit :+= bstm_init)
    with
      {| ProceedInvoke :
        e_s* := <translate-args> s*
      ; e_t* := <translate-args> t*
      ; rules(
          ProceedInvoke := |[ proceed.invoke(context, term, e_s*, e_t*) ]|
        )
      ; body* := <translate-definition-body> def
      |}

  translate-outer-definition-extend :
    AnnoDef([Extend()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       @SuppressWarnings("all")
       private static final class x' extends x {
         private static final x proceed = x.instance;
         ~(body*)
         @Override public String getName() { return "~x"; }
       }
    ]|
    with
      x' := <conc-strings> (x, "_extension")
    ; bstm_init := <outer-definition-DefInit(|x')> def
    ; rules(DefInit :+= bstm_init)
    with
      {| ProceedInvoke :
        e_s* := <translate-args> s*
      ; e_t* := <translate-args> t*
      ; def' := SDefT(x, s*, t*, GuardedLChoice(s, Id(), Override()))
      ; rules(
          ProceedInvoke := |[ proceed.invoke(context, term, e_s*, e_t*) ]|
        )
      ; body* := <translate-definition-body> def'
      |}

  translate-outer-definition-internal :
    AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       @SuppressWarnings("all")
       private static final class x extends Strategy {
         public static final x instance = new x();

         ~body*
         ~invokedynamic*
       }
    ]|
    with
      body*          := <translate-definition-body> def
    ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)

  translate-outer-definition-conflict :
    AnnoDef(a*, SDefT(x, _, _, _)) -> ()
    with
      fatal-err(|["conflicting annotations for strategy ", x])

  outer-definition-DefInit(|x'): SDefT(x, _, _, _) -> bstm |[ x.instance = new x'(); ]|

  outer-definition-DefInit: AnnoDef([Override()], SDefT(x, _, _, _)) -> bstm |[ x.instance = new x'(); ]|
    with
      x' := <conc-strings> (x, "_override")

  outer-definition-DefInit: AnnoDef([Extend()], SDefT(x, _, _, _)) -> bstm |[ x.instance = new x'(); ]|
    with
      x' := <conc-strings> (x, "_extension")

  translate-inner-definition :
    sdeft@SDefT(x, s*, t*, s) ->
    type-dec |[
       @SuppressWarnings("all")
       private static final class x extends Strategy {
         ~instance-field*
         ~lifted-tfield*
         ~lifted-sfield*

         ~body
         ~invokedynamic*
       }
    ]|
    with
      ?def
    ; lifted-tvar*   := <collect-lifted-tvars> def
    ; lifted-svar*   := <collect-lifted-svars> def
    ; lifted-sfield* := <map(\y -> class-body-dec |[ Strategy y;      ]|\)> lifted-svar*
    ; lifted-tfield* := <map(\y -> class-body-dec |[ TermReference y; ]|\)> lifted-tvar*
    ; lifted-args    := <conc> (lifted-svar*, lifted-tvar*)
    with
      if !lifted-tvar* => lifted-svar* => [] then
        instance-field* := class-body-dec* |[ public static final x instance = new x(); ]|
      ; {| CurrentLiftedFrame :
          rules(CurrentLiftedFrame := x{})
        ; body           := <java-eliminate-stacktrace> <translate-definition-body> sdeft
        ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)
        |}
      else
        instance-field* := []
      ; {| CurrentLiftedFrame :
          rules(CurrentLiftedFrame := x{})
        ; body           := <java-eliminate-stacktrace> <translate-inner-definition-body> sdeft
        ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)
        |}
      end

  maybe-make-invoke-dynamic :
    (s*, t*) -> invokedynamic*
    with
      if is-dynamic-signature(|s*, t*) then
        invokedynamic* := [<make-invoke-dynamic> (s*, t*)]
      else
        invokedynamic* := []
      end

  make-invoke-dynamic :
    (s*, t*) ->
    |[ @Override
       public IStrategoTerm invokeDynamic(Context context, IStrategoTerm term,
                                          Strategy[] sargs, IStrategoTerm[] targs) {
         if (sargs == null || targs == null || sargs.length != i_slength || targs.length != i_tlength)
           throw new IllegalArgumentException("Illegal arguments for " + getName());

         return invoke(context, term, e_s*, e_t*);
       }
    ]|
    with
      i_slength := <write-to-string> <length> s*
    ; i_tlength := <write-to-string> <length> t*
    ; e_s*      := <number(\(_,n) -> |[ sargs[~i:<write-to-string> n] ]|\)> s*
    ; e_t*      := <number(\(_,n) -> |[ targs[~i:<write-to-string> n] ]|\)> t*

  translate-definition-body :
    sdeft@SDefT(x, s*, t*, s) ->
    |[ public static IStrategoTerm callStatic(Context context, IStrategoTerm term, param*) {
           // As an ECJ 3.3 reachability detection bug workaround,
           // we assign a non-final boolean TRUE to true
           boolean TRUE = true;
           ITermFactory termFactory = context.getFactory();
           bstm_init*
           if (TRACES_ENABLED) context.push("~x'");
           Fail: {
             bstm
             if (TRACES_ENABLED) context.popOnSuccess("~x'");
             if (TRUE) // (avoid unreachable stm error)
               return term;
           };
           if (TRACES_ENABLED) context.popOnFailure("~x'");
           return null;
       }
       
       mod_override*
       public IStrategoTerm invoke(Context context, IStrategoTerm term, param2*) {
           return callStatic(context, term, e_s*, e_t*);
       }
    ]|
    with
      {| IsStrategyArg, java-CheckBuild, CurrentLiftedFrame, java-CheckBuild,
         IsLiftedTVar, IsLiftedSVar, LiftedTVars, LiftedSVars:
        (s'*, [])          := <translate-params> s*
      ; (t'*,  bstm_init*) := <translate-params> t*
      // Ignore escaping variables for proxy to static call by stripping annos that mark those
      ; (t2*,  [])         := <strip-annos; translate-params> t*
      ; e_s*               := <translate-args> s*
      ; e_t*               := <strip-annos; translate-args> t*
      ; x'                 := <undo-dollars-for-capitals> x
      ; param*             := <conc> (s'*, t'*)
      ; param2*            := <conc> (s'*, t2*)
      ; if is-dynamic-signature(|s*, t*) then
          mod_override* := []
        else
          mod_override* := [ anno |[ @Override ]| ]
        end
      ; bstm := <translate-strategy> s
      |}

  translate-inner-definition-body :
    sdeft@SDefT(x, s*, t*, s) ->
    |[ mod_override*
       public IStrategoTerm invoke(Context context, IStrategoTerm term, param*) {
           // As an ECJ 3.3 reachability detection bug workaround,
           // we assign a non-final boolean TRUE to true
           boolean TRUE = true;
           ITermFactory termFactory = context.getFactory();
           bstm_init*
           if (TRACES_ENABLED) context.push("~x'");
           Fail: {
             bstm
             if (TRACES_ENABLED) context.popOnSuccess("~x'");
             if (TRUE) // (avoid unreachable stm error)
               return term;
           };
           if (TRACES_ENABLED) context.popOnFailure("~x'");
           return null;
       }
    ]|
    with
      {| IsStrategyArg, java-CheckBuild, CurrentLiftedFrame, java-CheckBuild,
         IsLiftedTVar, IsLiftedSVar, LiftedTVars, LiftedSVars:
        (s'*, [])          := <translate-params> s*
      ; (t'*,  bstm_init*) := <translate-params> t*
      ; e_s*               := <translate-args> s*
      ; e_t*               := <translate-args> t*
      ; x'                 := <undo-dollars-for-capitals> x
      ; param*             := <conc> (s'*, t'*)
      ; if is-dynamic-signature(|s*, t*) then
          mod_override* := []
        else
          mod_override* := [ anno |[ @Override ]| ]
        end
      ; bstm := <translate-strategy> s
      |}

  translate-outer-definition :
    ExtSDef(_, _, _) -> Semicolon()

  /**
   * Translates strategy formal parameters to method parameters and initialization.
   */
  translate-params =
    unzip(translate-param)
  ; (id, concat)

  translate-param :
    VarDec(x{}, <?ConstType(_) <+ ?DynT(_)>) -> (param |[ IStrategoTerm x ]|, [])

  translate-param :
    VarDec(x{Offset(_), Escapes()}, <?ConstType(_) <+ ?DynT(_)>) ->
    ( param |[ IStrategoTerm x' ]|
    , bstm* |[ TermReference x = new TermReference(x'); ]|)
    with
      x' := <conc-strings> ("ref_", x)

  translate-param :
    VarDec(x, FunType(_, _)) -> (param |[ Strategy x ]|, [])
    with
      x'    := x{}
    ; frame := <CurrentLiftedFrame>
    ; rules(IsStrategyArg: (frame, x'))

  /**
   * Translates strategy formal parameters to call arguments.
   */
  translate-args =
    map(translate-arg)

  translate-arg :
    VarDec(x{}, <?ConstType(_) <+ ?DynT(_)>) -> expr |[ x ]|

  translate-arg :
    VarDec(x{Offset(_), Escapes()}, <?ConstType(_) <+ ?DynT(_)>) -> expr |[ x.value ]|

  translate-arg :
    VarDec(x, FunType(_, _)) -> expr |[ x ]|

strategies

  translate-Scope :
    Scope(vars, body) -> bstm* |[
      // { // TODO: using an actual scope might reduce the # of local variable slots
        bstm_decl*
        bstm_body
      // }
    ]|
    with
      bstm_decl* := <map(to-java-vardecl)> vars
    ; bstm_body  := <translate-strategy> body

  /** @type Id -> Stm */
  translate-Id :
    Id() -> Empty()

  /** @type Id -> Stm */
  translate-Fail :
    Fail() -> |[ if (TRUE) break Fail; ]| // (avoid unreachable stm error)

  translate-Platform :
    CallT(SVar("if_java_platform_1_0"), [s], []) -> <translate-strategy> s

  translate-Platform :
    CallT(SVar("if_c_platform_1_0"), [s], []) ->  Empty()

  // TODO: Proceed(s*) / ProceedT(s*, t*)
  translate-Proceed :
    <Proceed(id) + ProceedT(id, id)> -> <fatal-err(|"proceed with arguments is not implemented yet")>

  translate-Proceed :
    <ProceedNoArgs() + Override()> -> // TODO: remove "override" strategy keyword
    bstm* |[
      term = e_outer;
      if (term == null) break Fail;
    ]|
    with
      e_outer := <ProceedInvoke>
    <+
      fatal-err(|"proceed illegal in this context")

  translate-Escape :
    Escape(java) -> java

  /** @type Seq -> Stm */
  translate-Seq :
    Seq(s1, s2) ->
    bstm* |[
        ~stm:<translate-strategy> s1
        ~stm:<translate-strategy> s2
    ]|

  /** @type GuardedLChoice -> Block */
  translate-GuardedLChoice-no-left-branch :
    GuardedLChoice(s1, Id(), s2) ->
    bstm* |[
      // (this pattern is matched optimized in java-postprocess)
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           if (TRUE) // (avoid unreachable stm error)
             break Success;
        }
        term = x_termcopy;
        stm_s2
      }
    ]|
   with
     x_termcopy := <newname> "term"
   ; stm_s1     := <translate-strategy> s1
   ; stm_s2     := <translate-strategy> s2

  /** @type GuardedLChoice -> Block */
  translate-GuardedLChoice :
    GuardedLChoice(s1, s2, s3) ->
    bstm* |[
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           OuterFail: { // (redirects failure to outer Fail block)
             stm_s2
             if (TRUE) // (avoid unreachable stm error)
               break Success;
           }
        }
        term = x_termcopy;
        stm_s3
      }
    ]|
   with
     x_termcopy := <newname> "term"
   ; stm_s1     := <translate-strategy> s1
   ; stm_s2     := <translate-strategy> s2
   ; stm_s3     := <translate-strategy> s3

  translate-strategy =
       (
       translate-Platform
    <+ translate-Cast
    <+ translate-TypeTest
    <+ translate-CallT-dynamic
    <+ translate-CallT
    <+ translate-ProxyT
    <+ translate-Build
    <+ translate-Seq
    <+ translate-PrimT-constant
    <+ translate-PrimT
    <+ translate-Id
    <+ translate-Fail
    <+ translate-Proceed
    <+ translate-GuardedLChoice-no-left-branch
    <+ translate-GuardedLChoice
    <+ translate-Scope
    <+ translate-Match
    <+ translate-MultiMatch
    <+ translate-DFA
    <+ translate-Let
    <+ translate-ImportTerm
    <+ translate-Escape
    <+ fatal-err(|"translate-strategy failed on ")
       )

  translate-Let :
    Let(defs, body) -> body'
    with
      {| InnerDefinition :
        !defs
      ; record-inner-definitions
      ; list-loop(rules(LiftedDef :+= <translate-inner-definition>))
      ; body' := <translate-strategy> body
      |}

  record-inner-definitions =
    list-loop({
      if ?def @ SDefT(x, _, _, _) then
        x' := x{}
      ; rules(InnerDefinition: x' -> def)
      /* This forces LiftedTVars and LiftedSVars to be populated before translating the bodies
       * of the definitions. `lifted-call-to-instance-with-args` is sometimes used in the bodies.
       * These can be executed before seeing the definitions if they are in the wrong order or
       * mutually dependent.
       */
      ; <collect-lifted-tvars> def
      ; <collect-lifted-svars> def
      end
    })

  translate-CallT-dynamic:
    CallT(SVar(x), s*, t*) ->
    bstm* |[
      bstm_init*
      bstm_call
      if (term == null)
        break Fail;
    ]|
    where
      is-dynamic-signature(|s*, t*)
    with
      lifted-decls-wrap(
//        if <is-self-call> x then
//          e_instance := |[ this ]|
//        else
          e_instance := <lifted-call-to-instance>
//        end
      ; e_s* := <map(lifted-strategy-to-instance)> s*
      ; e_t* := <map(java-construct-term)> t*
      ; !e_instance
      ; ( make-call-static(|x, e_s*, e_t*)
       <+ !bstm |[ term = e_instance.invokeDynamic(context, term, new Strategy[] { e_s* }, new IStrategoTerm[] { e_t* }); ]|)
      ; ?bstm_call
      ,
        ?bstm_init*
      )

  translate-CallT:
    CallT(SVar(x), s*, t*) ->
    bstm* |[
      bstm_init*
      bstm_call
      if (term == null)
        break Fail;
    ]|
    with
      lifted-decls-wrap(
//        if <is-self-call> x then
//          e_instance := |[ this ]|
//        else
          e_instance := <lifted-call-to-instance>
//        end
      ; e_s* := <map(lifted-strategy-to-instance)> s*
      ; e_t* := <map(java-construct-term)> t*
      ; ( make-call-static(|x, e_s*, e_t*)
       <+ !bstm |[ term = e_instance.invoke(context, term, e_s*, e_t*); ]|)
      ; ?bstm_call
      ,
        ?bstm_init*
      )

  // `this` call in local def that isn't a closure
  make-call-static(|x, e_s*, e_t*):
    expr |[ this ]| ->
    bstm |[ term = callStatic(context, term, e_s*, e_t*); ]|
    where
      sarg* := <LiftedSVars> x{}
    ; targ* := <LiftedTVars> x{}
    ; !sarg* => targ* => []

  // static call to top-level def
  make-call-static(|f, e_s*, e_t*):
    expr |[ x.instance ]| ->
    bstm |[ term = x.callStatic(context, term, e_s*, e_t*); ]|

  translate-ProxyT:
    ProxyT(s*, t*, i, o, SVar(x)) ->
    bstm* |[
      bstm_init*
      Proxy x_proxy = new Proxy(context, e_coercion, e_instance);
      term = x_proxy.invoke(context, term);
      if (term == null)
        break Fail;
    ]|
    with
      x_proxy := <concat-strings;newname> ["proxy_", x]
    ; e_coercion := <translate-FunTCoercion> (s*, t*, i, o)
    ; lifted-decls-wrap(
        e_instance := <lifted-call-to-instance> CallT(SVar(x), [], [])
      ,
        ?bstm_init*
      )

  translate-FunTCoercion:
    (s*, t*, i, o) ->
    |[ new FunTCoercion(Arrays.asList(e_s*), Arrays.asList(e_t*), e_i, e_o) ]|
  with
    e_s* := <map(translate-SCoercion)> s*
  ; e_t* := <map(translate-Coercion)> t*
  ; e_i := <translate-Coercion> i
  ; e_o := <translate-Coercion> o

  translate-Coercion:
    Id() -> |[ IdCoercion.INSTANCE ]|

  translate-Coercion:
    RuntimeCheck(type) -> |[ new TypeCoercion(e_type) ]|
  with
    e_type := <translate-Type> type

  translate-Type:
    StringT() -> |[ StringT.INSTANCE ]|

  translate-Type:
    IntT() -> |[ IntT.INSTANCE ]|

  translate-Type:
    RealT() -> |[ RealT.INSTANCE ]|

  translate-Type:
    BlobT() -> |[ BlobT.INSTANCE ]|

  translate-Type:
    Sort(str{a*}, args) -> |[ new Sort(e_str, Arrays.asList(e_ty*)) ]|
  where
    not(<getfirst(?SortVar(_))> a*)
  with
    e_ty* := <map(translate-Type)> args
  ; e_str := Lit(String([Chars(str)]))

  translate-Type:
    Sort(str{a*}, args) -> <translate-Type> v
  where <getfirst(?v@SortVar(_))> a*

  translate-Type:
    SortVar(str) -> |[ new SortVar(e_str) ]|
  with
    e_str := Lit(String([Chars(str)]))

  translate-Type:
    DynT(_) -> |[ DynT.INSTANCE ]|

  translate-Type:
    EmptyT() -> |[ BottomT.INSTANCE ]|

  translate-Type:
    IllFormedTermT(constr, args) -> |[ new IllFormedTermT(e_str, Arrays.asList(e_ty*)) ]|
  with
    e_ty* := <map(translate-Type)> args
  ; e_str := Lit(String([Chars(constr)]))

  translate-SCoercion:
    SId() -> |[ FunTCoercion.ID ]|

  translate-SCoercion:
    SRuntimeCheck(funttype) ->
    <translate-SType> funttype

  translate-SType:
    FunTType(s*, t*, FunNoArgsType(i, o)) ->
    |[ new FunTCoercion(Arrays.asList(e_s*), Arrays.asList(e_t*), e_i, e_o) ]|
  with
    e_s* := <map(translate-SType)> s*
  ; e_t* := <map(!RuntimeCheck(<id>);translate-Coercion)> t*
  ; e_i := <translate-Coercion> RuntimeCheck(i)
  ; e_o := <translate-Coercion> RuntimeCheck(o)

  translate-Cast:
    Cast(RuntimeCheck(type)) ->
    bstm* |[
      Cast.check(context, term, e_type);
    ]|
    with
      e_type := <translate-Type> type

  translate-TypeTest:
    TypeTest(type) ->
    bstm* |[
      if(!Cast.test(context, term, e_type)) break Fail;
    ]|
    with
      e_type := <translate-Type> type

  translate-PrimT :
    CallDynamic(f, s*, t*) -> <fail>
    with
      // They could be supported through the interopcontext,
      // but they're never used anyway
      fatal-err(|"Think again. Dynamic calls are not supported")

  translate-PrimT-constant :
    PrimT(f, [], []) -> <translate-strategy> Build(term)
    where
      term := <GetConstantDef> f

  translate-PrimT :
    PrimT(f, s*, t*) ->
    <java-check-unbound-args(|t*)>
    bstm* |[
      bstm_init*
      term = context.invokePrimitive("~f", term, new Strategy[] { e_s* }, new IStrategoTerm[] { e_t* });
      if (term == null) break Fail;
    ]|
    with
      lifted-decls-wrap(
        e_s*  := <map(lifted-strategy-to-instance)> s*
      ; e_t*  := <map(java-construct-term)> t*
      ,
        ?bstm_init*
      )

  lifted-decls-wrap(s, get-init-stms) =
    dr-ignore-states( // (hide and then scope these dyn. rules)
      s
    ; with(
        <get-init-stms> <concat> [<bagof-CallTDecls> | <bagof-CallTAssigns>]
      )
    | ["CallTDecl", "CallTDecls", "CallTAssigns"]
    )

  lifted-strategy-to-instance =
    if ?CallT(_, _, _) + ?ProxyT(_, _, _, _, _) then
      // Pass (potentially parameterizable) svar calls as-is
      lifted-call-to-instance
    else
      // Lift definition and produce call
      with(
        !SDefT(<concat-strings;newname => x> [<ConstantContainerClass>, "_lifted"], [], [], <id>)
      ; rules(LiftedDef :+= <translate-inner-definition>)
      )
    ; <lifted-call-to-instance> CallT(SVar(x), [], [])
    end

  lifted-call-to-instance =
    lifted-call-to-instance-proxy
  <+
    lifted-call-to-instance-self-call
  <+
    lifted-call-to-instance-from-frame
  <+
    lifted-call-to-instance-with-args
  <+
    lifted-call-to-instance-direct
  <+
    lifted-call-to-instance-instance

  lifted-call-to-instance-proxy :
    ProxyT(s*, t*, i, o, SVar(x)) ->
    expr |[ x_proxy ]|
    with
      x_proxy := <concat-strings;newname> ["proxy_", x]
    ; rules(
        CallTDecl: x_proxy -> x_proxy
      )
    ; e_coercion := <translate-FunTCoercion> (s*, t*, i, o)
    ; e_instance := <lifted-call-to-instance> CallT(SVar(x), [], [])
    ; init := bstm |[
        Proxy x_proxy;
      ]|
    ; rules(
        CallTDecls :+= init
      )

    ; assigns := bstm* |[
        x_proxy = new Proxy(context, e_coercion, e_instance);
      ]|
    ; rules(
        CallTAssigns :+= assigns
      )

  lifted-call-to-instance-self-call :
    CallT(SVar(x), _, _) -> expr |[ this ]|
    where
      <is-self-call> x
    // Only do self calls for inner definitions with lifted args
    ; sarg* := <LiftedSVars> x{}
    ; targ* := <LiftedTVars> x{}
    ; (!sarg* => [_ | _] + !targ* => [_ | _])

  lifted-call-to-instance-from-frame :
    CallT(SVar(x{a*}), _, _) -> expr |[ x ]|
    where
      <not(is-self-call)> x
    ; frame := <CurrentLiftedFrame>
    ; !a*
    ; one(?Offset(_))
    ; one(Frames(one(?frame)))

  lifted-call-to-instance-with-args :
    CallT(SVar(x), _, _) -> expr |[ x' ]|
    where
      sarg* := <LiftedSVars> x{}
    ; targ* := <LiftedTVars> x{}
    ; (!sarg* => [_ | _] + !targ* => [_ | _]) // needs lifting
    with
      if not(<CallTDecl> x => x') then // add declaration
        x' := <newname> x
      ; rules(
          CallTDecl: x -> x'
        )
      ; init := bstm |[ x x' = new x(); ]|
      ; rules(
          CallTDecls :+= init
        )
      ; e_sarg* := <map(\x -> <lifted-call-to-instance> CallT(SVar(x), [], [])\)> sarg*
      ; e_targ* := <map(\x -> ExprName(Id(x))\)> targ*
      ; assigns := <zip(\(x_field, e_value) -> |[ x'.x_field = e_value; ]|\)> ([sarg*, targ*], [e_sarg*, e_targ*])
      ; rules(
          CallTAssigns :+= assigns
        )
      end

  lifted-call-to-instance-direct :
    CallT(SVar(x{a*}), _, _) -> expr |[ x ]|
    where
      <IsStrategyArg> (<CurrentLiftedFrame>, x{})

  lifted-call-to-instance-instance :
    CallT(SVar(x), _, _) -> expr |[ x.instance ]|

  is-dynamic-signature(|s*, t*) =
    where(
      <gt> (<length> s*, MAX_STATIC_SARGS())
    + <gt> (<length> t*, MAX_STATIC_TARGS())
    )

/* ================================ Build  */

  translate-Build:
    Build(t) ->
    <java-check-unbound-args(|t)>
    bstm* |[
      ~*decs
      ~*stms
      term = e;
    ]|
    where
      {| java-CheckBuild :
         <java-construct-term> t => e
       ; bagof-java-CheckBuild; unzip; (id, reverse; concat) => (decs, stms)
      |}

  // these two strategies should be in libstratego-lib, but is not yet supported
  // by the c compiler due to usage of an older aterm library
  WriteToStreamingFile =
    WriteToFile(write-in-saf-to-stream)

  write-in-saf-to-stream =
    if-java-platform(
      ?(Stream(stream), term); prim("SSL_write_term_to_stream_saf", stream, term); !Stream(<id>)
    );
    if-c-platform(
      fatal-err-msg(|["Trying to write SAF file on c platform, not supported"])
    )

  write-imported-term =
    if-java-platform(WriteToStreamingFile);
    if-c-platform(WriteToBinaryFile)

  /**
   * Translate 'import-term'
   * - uses LazyTerm to lazily load the term
   * - inlining construction would exceed max method limit
   *    even an array may have this effect
   *  - inlining a string could be an easy solution to inline it
   *    (minding the 32767 length limit)
   */
  translate-ImportTerm:
    ImportTerm(file) -> <translate-ImportTerm'> (inputfile, outputfile, pkgpath)
    with
      inputfile  := <find-import-term-file> file // (exits on error)
    ; outputfile := <base-filename> file
    ; pkgname    := <get-config <+ !""> "-p"
    ; pkgpath    := <conc-strings> ("/", <string-replace(|".", "/")> pkgname, "/")
    with
      outputdir := <output-dirname>
    ; copyfile  := <conc-strings> (outputdir, "/", outputfile)
    ; if not(<eq> (<modification-time> inputfile, <file-exists; modification-time> copyfile)) then
        log(|Info(), ["Referenced imported term file ", file, "; copying to ", outputdir])
      ; if olevel1(?is-olevel1); !is-olevel1 then
          <ReadFromFile> inputfile
        ; <write-imported-term> (copyfile, <id>)
        else
          <copy-file> (inputfile, copyfile)
        end
      <+
        fatal-err-msg(|["Could not copy imported term file ", inputfile, " to ", copyfile])
      else
        log(|Info(), ["Referenced imported term file ", file, "; exists in ", outputdir])
      end

  translate-ImportTerm':
    (_, outputfile, pkgpath) -> |[ term = new ImportTerm(termFactory, x_constants.class, "~pkgpath", "~outputfile"); ]|
    where <get-config> "--single-strategy"
    with x_constants   := <ConstantContainerClass>

  translate-ImportTerm' :
    (inputfile, outputfile, pkgpath) -> |[ term = x_constants.x_constant; ]|
    where not(<get-config> "--single-strategy")
    with
      inputname     := <file-name-to-identifier> inputfile
    ; inputname'    := <not(IsImported) <+ newname> inputname
    ; x_constant    := <conc-strings> ("const", inputname')
    ; x_getconstant := <conc-strings> ("get",   inputname')
    ; x_constants   := <ConstantContainerClass>
    ; rules(
        IsImported : inputname
        ConstDecl :+= class-body-dec |[
          protected static ImportTerm x_constant;
        ]|
        ConstDecl :+= class-body-dec |[
          public static IStrategoTerm x_getconstant() {
            return x_constant;
          }
        ]|
        ConstInit :+= bstm* |[
          x_constant = new ImportTerm(termFactory, x_constants.class, "~pkgpath", "~outputfile");
        ]|
      )

  file-name-to-identifier =
    base-filename
  ; string-as-chars(
      listtd(try(['.', to-upper | id]))
    ; filter(is-alphanum)
    ; [to-upper | id]
    )

  find-import-term-file :
    file -> file'
    with
      pack-stratego-options-wrap(
        pack-include-path
      ; getfirst(pack-find-from-dir(|file)) => file'
      <+
        basefile := <base-filename> file
      ; pack-include-path
      ; getfirst(pack-find-from-dir(|basefile)) => file'
      )
    <+
      file' := <file-exists> file
    <+
      fatal-err(|["file ", file, " for imported term not found"])

  pack-stratego-options-wrap(s) =
    finally(
      with(
        include* := <get-config <+ ![]> "-I"
      ; <set-config> ("-I", [])
      ; <parse-options(pack-stratego-options, system-usage, id)> [<whoami>, include*, "-I", "."]
      )
    ; s
    , <set-config> ("-I", include*)
    )

  java-check-unbound-args(|t) =
    try(java-CheckUnboundArgs(|t))

  java-CheckUnboundArgs(|t) :
    stm ->
    bstm* |[
      if (e)
        break Fail;
      stm
    ]|
    where
      <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
    ; not([])
    ; foldr1(!expr|[ ~expr:<Hd; java-ConstructVar> == null ]|
            ,!expr|[ ~expr:<Fst; java-ConstructVar> == null || ~expr:<Snd> ]|) => e

/**
 * Term construction with constant term caching
 */
rules

  /** @type Term -> Exp */
  java-construct-term =
    where(not(<get-config> "--single-strategy" + <get-config> "--boilerplate"));
     ( java-Cache
    <+ java-ConstructAnnoVar
    <+ java-ConstructVar
    <+ !(<id>, <java-ConstructTerm>)
       ; (java-CacheConstant-again <+ java-CacheConstant <+ Snd) )

  java-construct-term =
    where(<get-config> "--single-strategy" + <get-config> "--boilerplate");
     ( java-ConstructAnnoVar
    <+ java-ConstructVar
    <+ java-ConstructTerm )

  java-CacheConstant-again :
    (t, e1 @ |[ x_constants.x_constant ]|) -> e1
    with
      rules(java-Cache: t -> e1)
    ; x_constants := <ConstantContainerClass>

  java-CacheConstant :
    (t, e1) -> |[ x_constants.x ]|
  where
      <(Op(id, map(java-Cache)); java-proper-list
            + Anno(java-Cache, java-Cache)
            + Int(id) + Str(id) + Real(id) )> t
  with
        x_constants := <ConstantContainerClass>
      ; switch !t
          case ?Op("Cons", _):
            x := <newname> "constCons"
          ; rules(IsProperList: |[ x_constants.x ]|)
          case ?Op("Nil", _):
            x := <newname> "constNil"
          ; rules(IsProperList: |[ x_constants.x ]|)
          case ?Op(op, _):
            x := <newname> <conc-strings> ("const", <try(un-double-quote-chars); jify> op)
          otherwise:
            x := <newname> "const"
        end
      ; rules( java-Cache : t -> |[ x_constants.x ]| )
      ; !(x, e1)
      ; rules(ConstDecl :+= <java-DeclareTermId>)
      ; rules(ConstInit :+= <java-InitTermId>)

 java-proper-list =
    Op("Nil", [])
    + Op("Cons", [id, java-proper-list <+ IsProperList])
    // TODO: Fix constants being generated multiple times
    //       e.g., <conc> ([], []) does this; it's got something to do with annos
    + Op(id, id)
      ; not(is-ListOp)

strategies

  is-TupleOp = ?Op("", _)

  java-DeclareTermId :
    (x, e) ->
    class-body-dec|[ protected static IStrategoTerm x; ]|

  java-InitTermId :
    (x, e) -> bstm* |[ x = e; ]|

  java-mk-int-const =
    !Lit(Deci(<try(int-to-string)>))

  java-mk-string-const =
    !Lit(String([Chars(<escape>)]))

  java-mk-float-const =
    !Lit(Float(<try(real-to-string)>))

rules

  java-ConstructTerm :
    Int(i) ->
    expr|[
      termFactory.makeInt(~expr:<java-mk-int-const> i)
    ]|

  java-ConstructTerm :
    Real(x) ->
    expr|[
      termFactory.makeReal(~expr:Lit(Float(<try(real-to-string)> x)))
    ]|

  java-ConstructTerm :
    Str(x) ->
    expr|[
      termFactory.makeString(~expr:Lit(String([Chars(<escape> x)])))
    ]|

  java-ConstructTerm : // HACK: BAFReader work-around
    Str([]) ->
    expr|[
      termFactory.makeString("[]")
    ]|

  java-ConstructVar :
    x@Var(_) -> e
  with
      e := <java-VarToReadRef> x

  java-ConstructAnnoVar :
    Anno(Var(x), pt2) ->
    expr|[
      termFactory.annotateTerm(e, checkListAnnos(termFactory, ~expr:<java-construct-term> pt2))
    ]|
  where
      <java-ConstructVar> Var(x) => e

  java-ConstructTerm :
    Anno(pt1, Op("Nil", [])) -> <java-construct-term> pt1
  where
      <not(?Var(_))> pt1

  java-ConstructTerm :
    Anno(pt1, pt2) ->
    expr|[
      termFactory.annotateTerm(~expr:<java-construct-term> pt1, checkListAnnos(termFactory, ~expr:<java-construct-term> pt2))
    ]|
  where
      <not(?Op("Nil", []))> pt2
    ; <not(?Var(_))> pt1

  java-ConstructTerm :
    Op(c, t*) -> expr|[ termFactory.makeAppl(e_cons, new IStrategoTerm[] { e_arg* }) ]|
  where
      not(is-ListOp + is-TupleOp)
  with
      e_cons := <java-ConstructorName-expr> (c, <length> t*)
    ; e_arg* := <map(java-construct-term)> t*

  java-ConstructTerm :
    Explode(t1, t2) -> expr |[ x ]|
    with
      e_t1 := <java-construct-term> t1
    ; e_t2 := <java-construct-term> t2
    ; x    := <newname> "mkterm"
    ; rules(
        java-CheckBuild :+=
          ( bstm |[ IStrategoTerm x; ]|
          , bstm*|[
               x = context.invokePrimitive("SSL_mkterm", term, new Strategy[] {},
                                           new IStrategoTerm[] { e_t1, e_t2 });
               if (x == null)
                 break Fail;
            ]|)
      )

  java-ConstructTerm :
    Op("", args) -> expr|[ termFactory.makeTuple(~*args') ]|
    with
      args' := <map(java-construct-term)> args

  java-ConstructTerm :
    Op("Nil", []) -> expr|[ (IStrategoTerm) termFactory.makeList(Term.NO_TERMS) ]|

  java-ConstructTerm :
    Op("Cons", [t1, t2]) ->
    expr|[
      (IStrategoTerm) termFactory.makeListCons(~expr:<java-construct-term> t1, e)
    ]|
    with
      <java-construct-term> t2
        ; if <not(Anno(is-ListOp,id))> t2 then
            java-check-aterm-list
          else
              if ?|[ x_constants.x_constant ]| + ?expr |[ x ]| then
                !|[ (IStrategoList) ~expr:<id> ]|
              else
                try(java-UncastATerm)
              end
              ; try(java-CastATermListSetAnnotations)
            end => e

  java-ConstructTerm = ?Path(<translate-Path>)

  java-check-aterm-list :
    e -> expr |[ x ]|
    with
      x := <newname> "list"
    ; rules(
        java-CheckBuild :+=
          ( bstm |[ IStrategoList x; ]|
          , bstm*|[
              x = checkListTail(e);
              if (x == null) break Fail;
            ]|)
      )

  java-CastATerm :
    e -> expr|[ (IStrategoTerm) e ]|

  java-CastATermListSetAnnotations :
    expr|[                 termFactory.annotateTerm(e1, checkListAnnos(e2, e3)) ]| ->
    expr|[ (IStrategoList) termFactory.annotateTerm(e1, checkListAnnos(e2, e3)) ]|

  java-UncastATerm :
    expr|[ (IStrategoTerm) e ]| -> e

/**
 * Signatures
 */
strategies

  JavaTranslate =
      ?OpDecl(c, t)
    ; rules(
        ConstructorDecl :+= <JavaDeclareConstructor>
        ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>
      )

  JavaDeclareConstructor :
    OpDecl(c, t) -> class-body-dec|[ public static IStrategoConstructor x; ]|
  where
    not(OpDecl("", id) + OpDecl("Cons", [id, id]) + OpDecl("Nil", []))
  with
    n := <Arity <+ is-int> t
  ; x := <java-ConstructorName> (c, n)
  ; rules(IsLocalOpDecl: (c, n))

  java-ConstructorName :
    (c, n) -> <conc-strings> ("_cons", c', "_", n')
    with
      c' := <jify> c
    ; n' := <int-to-string> n

  java-ConstructorName-expr =
    where(<get-config> "--single-strategy")
  ; JavaInitConstructorExpr

  java-ConstructorName-expr =
    where(not(<get-config> "--single-strategy"))
  ; with(
      IsLocalOpDecl
    <+
      // HACK: locally redefine external constructors to avoid ambiguous imports
      //       (should this be done for congruences as well?)
      JavaCopyConstructor
    )
  ; !expr |[ ~x:<MainClassName>.~x:<java-ConstructorName> ]|

  JavaCopyConstructor =
    ((c, n) -> OpDecl(c, n))
  ; rules(
      IsLocalOpDecl: (c, n)
      ConstructorDecl :+= <oncetd(\Public() -> Protected()\)> <JavaDeclareConstructor>
      ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>
    )

  JavaInitConstructorQ :
    OpDecl(c, t) ->
    bstm |[
      x = ~expr:<JavaInitConstructorExpr> (<concat-strings> ["\\\"", c', "\\\""], ar);
    ]|
  where
      <string-as-chars(unescape-chars; un-double-quote-chars)> c => c'
    ; ar := <Arity <+ is-int> t
    ; x  := <java-ConstructorName> (c, ar)

  JavaInitConstructor :
    OpDecl(c, t) ->
    bstm |[
      x = ~expr:<JavaInitConstructorExpr> (c, ar);
    ]|
  where
      ar := <Arity <+ is-int> t
    ; x  := <java-ConstructorName> (c, ar)

  JavaInitConstructorExpr:
    (c, ar) ->
    expr |[ termFactory.makeConstructor("~c", ~expr:<java-mk-int-const> ar) ]|

  /**
   * Locally redefines some standard list and Some/None constructors,
   * which appear in nearly every grammar.
   */
  add-default-constructors =
    with(
      add-private-constructor(|"Some", 1)
    ; add-private-constructor(|"None", 0)
    ; add-private-constructor(|"Conc", 2)
    )

  add-private-constructor(|name, arity) =
    if not(<IsLocalOpDecl> (name, arity)) then
      x := <java-ConstructorName> (name, arity)
    ; rules(
        IsLocalOpDecl: (name, arity)
        ConstructorDecl :+= class-body-dec|[ public static IStrategoConstructor x; ]|
        ConstructorInit :+=
          |[ x = termFactory.makeConstructor("~name", ~expr:<java-mk-int-const> arity); ]|
      )
    end

/* ================================ Match */
strategies

  translate-Match :
    Match(t) -> result
    with
      result := <translate-Match> Match(t, ExprName(Id("term")))

  translate-Match :
    Match(Wld(), trm) -> Empty()

  translate-Match :
    Match(As(t1,t2), trm) ->
    bstm* |[
      stm_match1
      stm_match2
    ]|
    with stm_match1 := <translate-Match> Match(t1,trm)
       ; stm_match2 := <translate-Match> Match(t2,trm)

  translate-Match :
    Match(Var(x){"unbound"}, trm) -> stm_assign
    with
      stm_assign := <java-VarToWrite> (x, trm)

  translate-Match :
    Match(Var(x){"bound"}, e) ->
    stm |[
      if (e != e_var && !e_var.match(e))
        break Fail;
     ]|
    with
      e_var := <java-VarToReadRef> Var(x)

  translate-Match :
    Match(Var(x){"(un)bound"}, e) ->
    stm |[
      if (e_var == null)
        stm_assign
      else if (e_var != e && !e_var.match(e))
        break Fail;
    ]|
    with
      e_var      := <java-VarToReadRef> Var(x)
    ; stm_assign := <java-VarToWrite> (x, e)

  translate-Match :
    Match(Var(x){}, trm) -> <translate-Match> Match(Var(x){"(un)bound"}, trm)

  translate-Match :
    Match(Explode(t1, t2), e) ->
    bstm* |[
      IStrategoTerm x_cons = context.invokePrimitive("SSL_get_constructor", term,
                                                      new Strategy[] {},
                                                      new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t1, ExprName(Id(x_cons))))
      IStrategoTerm x_args = context.invokePrimitive("SSL_get_arguments", term,
                                                     new Strategy[] {},
                                                     new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t2, ExprName(Id(x_args))))
     ]|
  with
      !e => ExprName(Id(_))
    ; x_cons := <newname> "cons"
    ; x_args := <newname> "args"

  translate-Match =
       ( translate-MatchNoAnno
      <+ translate-MatchAnno )

  translate-MatchNoAnno :
    Match(Anno(pt1, Wld()), e) -> result
    with result := <translate-Match> Match(pt1, e)

  translate-MatchAnno :
    Match(Anno(pt1, pt2), e) ->
    bstm* |[
      stm0
      IStrategoList x = e.getAnnotations();
      stm1
    ]|
  where
      <not(Wld())> pt2
  with
      x    := <newname> "annos" // FIXME: this seems to not always return a truly unused name
    ; if Var(x) := pt2 then <fatal-err> $[newname returned non-fresh name [x].] end
    ; stm0 := <translate-Match> Match(pt1, e)
    ; stm1 := <translate-Match> Match(pt2, ExprName(Id(x)))

  // String constants are not cached for comparison,
  // since we do comparison modulo annotations
  translate-Match :
    Match(Str(str), e) ->
    stm|[
      if (e.getTermType() != IStrategoTerm.STRING
         || !e_str.equals(((IStrategoString) e).stringValue()))
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_str := Lit(String([Chars(<escape> str)]))

  translate-Match :
    Match(Int(i), e) ->
    stm|[
      if (e.getTermType() != IStrategoTerm.INT
         || e_int != ((IStrategoInt) e).intValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_int := <java-mk-int-const> i

  translate-Match :
    Match(Real(r), e) ->
    stm|[
      if (e.getTermType() != IStrategoTerm.REAL
          || e_real != ((IStrategoReal) e).realValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_real := Lit(Float(<try(real-to-string)> r))

  /**
   * Translate a match of an Op, but not a Cons/2 , Nil/0, or tuple.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    bstm* |[
      // (this pattern is matched and optimized in java-postprocess)
      if (e.getTermType() != IStrategoTerm.APPL || e_nomatch) break Fail;
      ~bstm*:match-args
    ]|
  where
    <not(is-ListOp + is-TupleOp)> op
  with
    e_cons     := <java-ConstructorName-expr> (c, <length> ts)
  ; match-args := <translate-Match-args> (e, ts)
  ; if not(<get-config> "-sc" => "off") then
      e_nomatch := |[ e_cons != ((IStrategoAppl) e).getConstructor() ]|
    else
      e_nomatch := |[ !e_cons.equals(((IStrategoAppl) e).getConstructor()) ]|
    end

  /**
   * Translate a match of a tuple.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.TUPLE || e.getSubtermCount() != i)
        break Fail;
      ~bstm*:match-args
    ]|
  where
    <is-TupleOp> op
  with
    i:= <write-to-string> <length> ts
  ; match-args := <translate-Match-args> (e, ts)

  translate-Match-args :
    (e, terms) -> bstm_matcharg*
    with
      (bstm_matcharg*, _) :=
        <thread-map(\ (t,i) -> (
               <java-MatchArg1 <+ java-MatchArg2>
                  (t, expr|[ e.getSubterm(~expr:<java-mk-int-const> i) ]|)
             , <add>(i, 1)
             )
           \ )> (terms,0)

  java-MatchArg1 :
    (Var(x){t*}, e) -> result
  with
      result := <translate-Match> Match(Var(x){t*}, e)

  java-MatchArg2 :
    (t, e) ->
    bstm* |[
      stm1
      stm2
    ]|
    with
      x    := <newname> "arg"
    ; stm2 := <translate-Match> Match(t, ExprName(Id(x)))
    ; if !stm2 => Empty() then
       stm1 := Empty()
      else
       stm1 := bstm |[ IStrategoTerm x = e; ]|
     end

  translate-Match :
    Match(Op("Nil", []), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.LIST || !((IStrategoList) e).isEmpty())
        break Fail;
    ]|

  translate-Match :
    Match(Op("Cons", [hd, tl]), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.LIST || ((IStrategoList) e).isEmpty())
          break Fail;
      ~bstm*:match-args
    ]|
  with
    <map(java-MatchArg1 <+ java-MatchArg2)>
       [ (hd, expr|[ ((IStrategoList) e).head() ]|)
       , (tl, expr|[ ((IStrategoList) e).tail() ]|) ] => match-args

/* ================================ MultiMatch */
  translate-MultiMatch =
    ?MultiMatch(Sequential(), _) < multimatch2dfa; translate-strategy
  + fail

/*======== Generate Java code from DFA =================*/
  translate-DFA = translate-SwitchT

  translate-SwitchT:
    SwitchT(TypeP(CurP()), [], default) ->
    bstm* |[
      ~<translate-Default> default
    ]|

  translate-SwitchT:
    SwitchT(p, [], default) ->
    bstm* |[
      e_occ; // Necessary to ensure that failure in `p` is not lost.
      ~<translate-Default> default
    ]|
  with
    e_occ := <translate-PathTp> p

  translate-SwitchT:
    SwitchT(p, alt*, default) ->
    bstm* |[
      switch (e_occ) {
        ~switch-group*:cases
        default: {
          ~<translate-Default> default
          break;
        }
      }
    ]|
  with
    e_occ := <translate-PathTp> p
  ; e_trm := <?TypeP(<id>); translate-PathTrm> p
  ; cases := <map(translate-AltT(|e_trm))> alt*

  translate-SwitchT:
    SwitchTNoDefault(p, []) ->
    bstm* |[
      e_occ; // Necessary to ensure that failure in `p` is not lost.
      ~<translate-strategy> Fail()
    ]|
  with
    e_occ := <translate-PathTp> p

  translate-SwitchT:
    SwitchTNoDefault(p, alt*) ->
    bstm* |[
      switch (e_occ) {
        ~switch-group*:cases
        default: {
          ~<translate-Fail> Fail()
          break;
        }
      }
    ]|
  with
    e_occ := <translate-PathTp> p
  ; e_trm := <?TypeP(<id>); translate-PathTrm> p
  ; cases := <map(translate-AltT(|e_trm))> alt*

  translate-Default:
    Default(s) ->
    <translate-strategy> s

  translate-Default:
    GuardedDefault(guards) ->
    <translate-Guards> guards

  translate-AltT(|e_trm):
    AltT(tp, switchv) ->
    switch-group |[
      case x_type: {
        bstm_asgn
        bstm_switch*
        break;
      }
    ]|
  with
    (x_type, bstm_asgn, bstm_switch*) := <translate-AltT-helper(|e_trm)>

  translate-AltT-helper(|e_trm):
    AltT(tp, switchv) ->
    (x_type, bstm_asgn, bstm_switch*)
  with
    <pat-type-to-enum> tp => x_type
  ; <?SwitchV(<id>, _, _) + ?SwitchVNoDefault(<id>, _)> switchv => t_path
  ; <translate-PathVF> t_path => e_path
  ; <cast-path(|tp)> e_trm => e_cast
  ; <typed-assign(|tp)> e_cast => (bstm_asgn, x_asgn)
  ; <alltd((e_cast -> e |[ x_asgn ]|))> e_path => e_path'
  ; <translate-SwitchV(|tp, e_path')> switchv => bstm_switch*

  pat-type-to-enum: ApplT()   -> "APPL"
  pat-type-to-enum: LisT()    -> "LIST"
  pat-type-to-enum: IntT()    -> "INT"
  pat-type-to-enum: RealT()   -> "REAL"
  pat-type-to-enum: StringT() -> "STRING"
  pat-type-to-enum: CtorT()   -> "CTOR"
  pat-type-to-enum: TupleT()  -> "TUPLE"
  pat-type-to-enum: RefT()    -> "REF"
  pat-type-to-enum: BlobT()   -> "BLOB"
  pat-type-to-enum: PlaceT()  -> "PLACEHOLDER"

  translate-SwitchV(|tp, e_path):
    SwitchV(_, alt*, default) ->
    <translate-SwitchV-helper(|tp)> (e_path, alt*, stm_def)
  with
    stm_def := <translate-Default> default

  translate-SwitchV(|tp, e_path):
    SwitchVNoDefault(_, alt*) ->
    <translate-SwitchV-helper(|tp)> (e_path, alt*, stm_def)
  with
    stm_def := <translate-Fail> Fail()

  translate-SwitchV-helper(|tp) =
    if tp := ApplT() then // TODO This criterion could be less strict.
      switch <get-config> "--pmc:switchv" <+ !"hash-switch"
        case ?"elseif": AltVs-as-ifs
        case ?"nested-switch": AltVs-as-nested-switches
        case ?"hash-switch": AltV-as-hash-switch
        otherwise: <fatal-error> ["Not a valid value for '--pmc:switchv'", <id>]
      end
    else
      AltVs-as-ifs
    end

  AltVs-as-ifs:
    (e_path, alt*, stm_def) ->
    <foldr(!stm_def, translate-AltV-if(|e_path))> alt*

  translate-AltV-if(|e_occ):
    (AltV(t, s), stm_else) ->
    bstm* |[
      if (e_match) {
        ~<translate-strategy> s
      } else {
        stm_else
      }
    ]|
  with
    e_match := <java-Pat-to-Condition> (t, e_occ)

  translate-AltV-if(|e_occ):
    (GuardedAltV(t, guards), stm_else) ->
    bstm* |[
      if (e_match) {
        bstm_guards
      } else {
        stm_else
      }
    ]|
  with
    e_match := <java-Pat-to-Condition> (t, e_occ)
  ; bstm_guards := <translate-Guards> guards

  AltV-as-hash-switch:
    (e_path, alt*, stm_def) ->
    bstm* |[
      IStrategoConstructor x_cons = e_path;

      switch (x_cons.hashCode()) {
        ~switch-group*:cases
        default: {
          stm_def
          break;
        }
      }
    ]|
  with
    (x_cons, groups) := <AltV-as-hash-switch-helper>
  ; cases := <map(HashGroup(|e|[x_cons]|, stm_def))> groups

  AltV-as-hash-switch-helper:
    (e_path, alt*, stm_def) ->
    (x_cons, groups)
  with
    x_cons := <local-newname> "cons"
  ; pairs := <map(split(AltHash, id))> alt*
  ; hash_set := <map(Fst); make-set> pairs
  ; groups := <map(split(id, \ h -> <collect-all(where(Fst; equal(|h)); Snd)> pairs \))> hash_set

  AltHash:
    alt@(_#([FunC(x, a), _])) ->
    <constructor-checksum> appl
  where
    <?AltV(_, _) + ?GuardedAltV(_, _)> alt
  with
    appl := x#(<range> (0, <string-to-int> a))

  HashGroup(|e_occ, stm_def):
    (hash, alt*) ->
    switch-group |[
      case e_hash: {
        bstm_alts*
        break;
      }
    ]|
  with
    (e_hash, bstm_alts*) := <HashGroup-helper(|e_occ, stm_def)>

  HashGroup-helper(|e_occ, stm_def):
    (hash, alt*) ->
    (e_hash, bstm_alts*)
  with
    e_hash := <java-mk-int-const> hash
  ; bstm_alts* := <foldr(!stm_def, translate-AltV-if(|e_occ))> alt*

  constructor-checksum = prim("SSL_constructor_hash", <id>)

  AltVs-as-nested-switches =
    switch <get-config> "--pmc:switchv-order" <+ !"arity-name"
      case ?"arity-name": ArityNameSwitch
      case ?"name-arity": NameAritySwitch
      otherwise: <fatal-error> ["Not a valid value for '--pmc:switchv-order'", <id>]
    end

  ArityNameSwitch:
    (e_path, alt*, stm_def) ->
    bstm* |[
      IStrategoConstructor x_cons = e_path;

      switch (x_cons.getArity()) {
        ~switch-group*:groups
        default: {
          stm_def
          break;
        }
      }
    ]|
  with
    x_cons := <local-newname> "cons"
  ; pairs := <map(split(id, Alt2Arity; try(int-to-string)))> alt*
  ; group_labels := <map(Snd); make-set> pairs
  ; grouped_by := <map(\ a -> (a, <filter(where(Snd; ?a); Fst)> pairs) \)> group_labels
  ; groups := <map(ArityGroup(|e|[x_cons]|, stm_def))> grouped_by

  Alt2Arity = ?AltV(<cons-arity>, _)
  Alt2Arity = ?GuardedAltV(<cons-arity>, _)

  ArityGroup(|e_path, stm_def):
    (a, name_alt*) ->
    switch-group |[
      case e_arity: {
        bstm_alt
        break;
      }
    ]|
  with
    e_arity := <java-mk-int-const> a
  ; bstm_alt := <NameSwitch(|e_path, stm_def)> name_alt*

  NameSwitch(|e_path, stm_def):
    alt* ->
    bstm |[
      switch (e_path.getName()) {
        ~switch-group*:groups
        default: {
          stm_def
          break;
        }
      }
    ]|
  with
    pairs := <map(split(id, Alt2Name))> alt*
  ; group_labels := <map(Snd); make-set> pairs
  ; grouped_by := <map(\ a -> (a, <filter(where(Snd; ?a); Fst)> pairs) \)> group_labels
  ; groups := <map(NameGroup(|e_path, stm_def))> grouped_by

  Alt2Name = ?AltV(<cons-name>, _)
  Alt2Name = ?GuardedAltV(<cons-name>, _)

  cons-name = ?FunC(<id>, _)

  NameGroup(|_, _):
    (name, [alt]) ->
    switch-group |[
      case e_name: {
        stm_alt
        break;
      }
    ]|
  with
    e_name := <java-mk-string-const> name
  ; stm_alt := <translate-AltV-case> alt

  translate-AltV-case = ?AltV(_, <translate-strategy>)
  translate-AltV-case = ?GuardedAltV(_, <translate-Guards>)

  NameAritySwitch = debug(|"NameAritySwitch "); fail

  /** @type List(Guard) -> Block */
  translate-Guards =
    translate-Guards(|Fail())

  translate-Guards(|failure) =
    foldr(<translate-strategy> failure, translate-Guard)

  translate-Guard:
    (Guard(s1, Id()), stm_s2) ->
    bstm* |[
      // (this pattern is matched optimized in java-postprocess)
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           if (TRUE) // (avoid unreachable stm error)
             break Success;
        }
        term = x_termcopy;
        stm_s2
      }
    ]|
   with
     x_termcopy := <local-newname> "term"
   ; stm_s1     := <translate-strategy> s1

  /** @type Guard -> Block */  
  translate-Guard:
    (Guard(s1, s2), stm_s3) ->
    bstm* |[
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           OuterFail: { // (redirects failure to outer Fail block)
             stm_s2
             if (TRUE) // (avoid unreachable stm error)
               break Success;
           }
        }
        term = x_termcopy;
        stm_s3
      }
    ]|
  where
    <not(?Id())> s2
  with
    x_termcopy := <local-newname> "term"
  ; stm_s1     := <translate-strategy> s1
  ; stm_s2     := <translate-strategy> s2


  typed-assign(|LisT()):
    e_trm ->
    (bstm |[ IStrategoList x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "list"

  typed-assign(|ApplT()):
    e_trm ->
    (bstm |[ IStrategoAppl x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "appl"

  typed-assign(|TupleT()):
    e_trm ->
    (bstm |[ IStrategoTuple x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "tuple"

  typed-assign(|StringT()):
    e_trm ->
    (bstm |[ IStrategoString x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "str"

  typed-assign(|IntT()):
    e_trm ->
    (bstm |[ IStrategoInt x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "int"

  typed-assign(|RealT()):
    e_trm ->
    (bstm |[ IStrategoReal x_asgn = e_trm; ]|, x_asgn)
  with
    x_asgn := <local-newname> "real"


  java-Pat-to-Condition:
    (FunC("Nil", "0"), e_occ) ->
    e |[ ((IStrategoList) e_occ).isEmpty() ]|

  java-Pat-to-Condition:
    (FunC("Cons", "2"), e_occ) ->
    e |[ !((IStrategoList) e_occ).isEmpty() ]|

  java-Pat-to-Condition:
    (op@FunC(c, x), e_occ) ->
    e_cond
  where
    <not(?FunC("Nil", "0") + ?FunC("Cons", "2"))> op
  with
    e_cons := <java-ConstructorName-expr> (c, <string-to-int> x)
  ; if not(<get-config> "-sc" => "off") then
      !e |[ e_occ == e_cons ]|
    else
      !e |[ e_occ.equals(e_cons) ]|
    end => e_cond

  java-Pat-to-Condition:
    (StrC(s), e_occ) ->
    e |[ e_occ.equals(~<java-mk-string-const> s) ]|

  java-Pat-to-Condition:
    (IntC(x), e_occ) ->
    e |[ e_occ == ~<java-mk-int-const> x ]|

  java-Pat-to-Condition:
    (RealC(x), e_occ) ->
    e |[ e_occ == ~<java-mk-float-const> x ]|

  java-Pat-to-Condition:
    (AnnoC(), e_occ) ->
    e |[ true ]|

  java-Pat-to-Condition:
    (TupleC(x), e_occ) ->
    e |[ e_occ == ~<java-mk-int-const> x ]|


  cast-path(|LisT()):
    e_occ ->
    e |[ (IStrategoList) e_occ ]|

  cast-path(|ApplT()):
    e_occ ->
    e |[ (IStrategoAppl) e_occ ]|

  cast-path(|IntT()):
    e_occ ->
    e |[ (IStrategoInt) e_occ ]|

  cast-path(|RealT()):
    e_occ ->
    e |[ (IStrategoReal) e_occ ]|

  cast-path(|StringT()):
    e_occ ->
    e |[ (IStrategoString) e_occ ]|

  cast-path(|CtorT()):
    e_occ ->
    e |[ (IStrategoConstructor) e_occ ]|

  cast-path(|TupleT()):
    e_occ ->
    e |[ (IStrategoTuple) e_occ ]|

  cast-path(|RefT()):
    e_occ ->
    e |[ (IStrategoRef) e_occ ]|

  cast-path(|PlaceT()):
    e_occ ->
    e |[ (IStrategoPlaceholder) e_occ ]|


  // TODO Only cast when necessary...
  translate-Path =
    translate-PathTrm
  + translate-PathTp
  + translate-PathFld

  translate-PathVF =
    translate-PathTrm
  + translate-PathFld

  translate-PathTrm:
    CurP() ->
    e |[ term ]|

//  translate-PathTrm =
//    ?Var(_); java-ConstructVar

  translate-PathTrm:
    SubP(p, x) ->
    e |[ e.getSubterm(~e:<java-mk-int-const> x) ]|
  with
    e := <translate-PathTrm> p

  translate-PathTrm:
    AnnoP(p) ->
    e |[ e.getAnnotations() ]|
  with
    e := <translate-PathTrm> p

  translate-PathTrm:
    HeadP(p) ->
    e |[ ((IStrategoList) e).head() ]|
  with
    e := <translate-PathTrm> p

  translate-PathTrm:
    TailP(p) ->
    e |[ ((IStrategoList) e).tail() ]|
  with
    e := <translate-PathTrm> p

  translate-PathTp:
    TypeP(p) ->
    e |[ e.getType() ]|
  with
    e := <translate-PathTrm> p

  translate-PathFld:
    SizeP(p) ->
    e |[ e.getSubtermCount() ]|
  with
    e := <translate-PathTrm> p

  translate-PathFld:
    ConP(p) ->
    e |[ ((IStrategoAppl) e).getConstructor() ]|
  with
    e := <translate-PathTrm> p

  translate-PathFld:
    IntP(p) ->
    e |[ ((IStrategoInt) e).intValue() ]|
  with
    e := <translate-PathTrm> p

  translate-PathFld:
    RealP(p) ->
    e |[ ((IStrategoReal) e).realValue() ]|
  with
    e := <translate-PathTrm> p

  translate-PathFld:
    StrP(p) ->
    e |[ ((IStrategoString) e).stringValue() ]|
  with
    e := <translate-PathTrm> p
