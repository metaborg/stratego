module core/strategies

imports
  core/terms
  core/constants
  core/signatures
  core/identifiers

template options
  Id = keyword {reject}
  keyword -/- [a-zA-Z0-9\'\-\_]
  tokenize: ")(|"

sorts Def
context-free syntax
  Def = StrategyDef

  SVar.SVar = Id

  Strategy.Let =
<let
  <{Def "\n"}*>
in
  <Strategy>
end>

  Strategy.CallT =
    <<SVar>(<{Strategy ", "}*>|<{Term ", "}*>)>

  Strategy.CallDynamic =
    <call(<Term>|<{Strategy ", "}*>|<{Term ", "}*>)> {deprecated("Dynamic calls are not supported")}

sorts StrategyDef
context-free syntax
  StrategyDef.SDefT =
<<Id>(<{Typedid ", "}*> | <{Typedid ", "}*>) =
  <Strategy>>

  Def.AnnoDef = <<Anno+> <StrategyDef>>

  StrategyDef.ExtSDefInl =
<external <Id>(<{Typedid ", "}*> | <{Typedid ", "}*>) =
  <Strategy>>

  StrategyDef.ExtSDef =
    <external <MaybeEmptyId>(<{Typedid ", "}*> | <{Typedid ", "}*>)>

sorts MaybeEmptyId
lexical syntax
  MaybeEmptyId =
  MaybeEmptyId = Id

sorts Anno
context-free syntax
  Anno.Extend = <extend>
  Anno.Override = <override>
  Anno.Internal = <internal>

sorts Typedid
context-free syntax
  Typedid.VarDec = <<ID> : <OldType>>


sorts Strategy SVar StrategyMid
context-free syntax
  Strategy.Fail  = <fail>
  Strategy.Id    = <id>
  Strategy.ProceedT = <proceed(<{Strategy ", "}*>|<{Term ", "}*>)>
  Strategy.ProceedNoArgs = <proceed>
  Strategy.Match = <?<Term>>
  Strategy.Build = <!<Term>>
  Strategy.Scope = <{<{ID ", "}*>: <Strategy> }>
  Strategy.Seq   = <<Strategy>; <Strategy>> {right}
  Strategy.GuardedLChoice = [[Strategy] < [Strategy] + [Strategy]] {right}
  Strategy.PrimT = <prim(<String>, <{Strategy ", "}*>|<{Term ", "}*>)>
  Strategy.Some  = <some(<Strategy>)>
  Strategy.One   = <one(<Strategy>)>
  Strategy.All   = <all(<Strategy>)>

// PMC
sorts MatchOrder MatchCase
context-free syntax
  Strategy.MultiMatch =
<match <MatchOrder>
  <{MatchCase "\n"}+>
end>

  MatchOrder.Sequential = <sequential>

  MatchCase.ScopedMatchCase = <case <{ID ", "}*> | <Term>: <Strategy>>
  MatchCase.ScopedGuardedMatchCase = <case <{ID ", "}*> | <Term> where <Strategy>: <Strategy>>

sorts DTree
context-free syntax
  Strategy = DTree // Can be factored out if only one DTree production exists.

  DTree.SwitchT =
<switch <PathT> {
  <{AltT "\n"}*>
  <Default>
}>

  // IR
  DTree.GuardedLeafs = <<{Guard "\n"}+>>

sorts SwitchV
context-free syntax
  SwitchV.SwitchV =
<switch <PathVF> {
  <{AltV "\n"}*>
  <Default>
}>

sorts AltT AltV Default
context-free syntax
  AltT.AltT =
<alt <PatT>:
  <SwitchV>>

  AltV.AltV =
<alt <PatV>:
  <Strategy>>

  AltV.GuardedAltV =
<alt <PatV>
  <{Guard "\n"}+>>

  Default.Default =
<default:
  <Strategy>>

  Default.GuardedDefault =
<default
  <{Guard "\n"}+>>

sorts Guard
context-free syntax
  Guard.Guard =
<where <Strategy>:
  <Strategy>>

sorts Path PathV PathT PathF PathVF
context-free syntax
  Path = PathV
  Path = PathT
  Path = PathF
  
  PathVF = PathV
  PathVF = PathF

  PathV.Cur = <current>
  PathV.Var = Var
  PathV.Sub = <<PathV>.<Int>>
  PathV.Anno = <<PathV>.anno>
  PathV.Head = <<PathV>.head>
  PathV.Tail = <<PathV>.tail>

  PathT.Type = <<PathV>.type>

  PathF.Size = <<PathV>.size>
  PathF.Con  = <<PathV>.con>
  PathF.IntP  = <<PathV>.int>
  PathF.RealP = <<PathV>.real>
  PathF.StrP  = <<PathV>.str>

sorts PatV
context-free syntax
  PatV.Fun = <(<Id>, <Int>)>
  PatV.Str = String
  PatV.Int = Int
  PatV.Real = Real
  PatV.Anno = <{_}>
  PatV.Tuple = <(<Int>)>
  PatV.Var = Var
  PatV.Wld = Wld

sorts PatT
context-free syntax
  PatT.ApplT = <APPL>
  PatT.LisT = <LIST>
  PatT.IntT = <INT>
  PatT.RealT = <REAL>
  PatT.StringT = <STRING>
  PatT.CtorT = <CTOR>
  PatT.TupleT = <TUPLE>
  PatT.RefT = <REF>
  PatT.BlobT = <BLOB>
  PatT.PlaceT = <PLACEHOLDER>

context-free priorities
  { Strategy.Build
    Strategy.Match
  }
> Strategy.Seq
> Strategy.GuardedLChoice

context-free syntax
  Strategy.ImportTerm = <import-term(<ModName>)>
