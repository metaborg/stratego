module core/strategies

imports
  core/terms
  core/constants
  core/signatures
  core/identifiers

template options
  Id = keyword {reject}
  keyword -/- [a-zA-Z0-9\'\-\_]
  tokenize: ")(|"

sorts Def
context-free syntax
  Def = StrategyDef

  SVar.SVar = Id

  Strategy.Let =
<let
  <{Def "\n"}*>
in
  <Strategy>
end>

  Strategy.CallT =
    <<SVar>(<{Strategy ", "}*>|<{Term ", "}*>)>

  Strategy.CallDynamic =
    <call(<Term>|<{Strategy ", "}*>|<{Term ", "}*>)> {deprecated("Dynamic calls are not supported")}

sorts StrategyDef
context-free syntax
  StrategyDef.SDefT =
<<Id>(<{Typedid ", "}*> | <{Typedid ", "}*>) =
  <Strategy>>

  Def.AnnoDef = <<Anno+> <StrategyDef>>

  StrategyDef.ExtSDefInl =
<external <Id>(<{Typedid ", "}*> | <{Typedid ", "}*>) =
  <Strategy>>

  StrategyDef.ExtSDef =
    <external <MaybeEmptyId>(<{Typedid ", "}*> | <{Typedid ", "}*>)>

sorts MaybeEmptyId
lexical syntax
  MaybeEmptyId =
  MaybeEmptyId = Id

sorts Anno
context-free syntax
  Anno.Extend = <extend>
  Anno.Override = <override>
  Anno.Internal = <internal>

sorts Typedid
context-free syntax
  Typedid.VarDec = <<ID> : <OldType>>


sorts Strategy SVar StrategyMid
context-free syntax
  Strategy.Fail  = <fail>
  Strategy.Id    = <id>
  Strategy.ProceedT = <proceed(<{Strategy ", "}*>|<{Term ", "}*>)> {prefer}
  Strategy.ProceedNoArgs = <proceed> {prefer}
  Strategy.Match = <?<Term>>
  Strategy.Build = <!<Term>>
  Strategy.Scope = <{<{ID ", "}*>: <Strategy> }>
  Strategy.Seq   = <<Strategy>; <Strategy>> {right}
  Strategy.GuardedLChoice = [[Strategy] < [Strategy] + [Strategy]] {right}
  Strategy.PrimT = <prim(<String>, <{Strategy ", "}*>|<{Term ", "}*>)>
  Strategy.Some  = <some(<Strategy>)>
  Strategy.One   = <one(<Strategy>)>
  Strategy.All   = <all(<Strategy>)>

// PMC
sorts MatchOrder MatchCase
context-free syntax
  Strategy.MultiMatch =
<match <MatchOrder>
  <{MatchCase "\n"}+>
end>

  MatchOrder.Linear = <linear>

  MatchCase.MatchCase = <case <Term>: <Strategy>>
  MatchCase.ScopedMatchCase = <case <Var*>|<Term>: <Strategy>>

sorts DTree
context-free syntax
  Strategy = DTree

  DTree.Leaf = <leaf <Strategy>> // Only if we don't need DTree.Fail
//  DTree.Fail = <fail> // Only if we can express 
  DTree.SwitchT =
<tswitch [<Path>] {
  <{AltT "\n"}*>
  default: <DTree>
}>

  SwitchV.SwitchV =
<vswitch [<Path>] {
  <{AltV "\n"}*>
  default: <DTree>
}>

sorts AltT AltV
context-free syntax
  AltT.AltT =
<alt <PatT>:
  <SwitchV>>
  AltV.AltV =
<alt <PatV>:
  <Strategy>>

sorts Path PathEl
context-free syntax
  Path.Path = <<{PathEl ", "}+>>

  PathEl.Cur = <cur>
  PathEl.Sub = <sub <Int>>
  PathEl.Ann = <ann>
  PathEl.Con = <con>
  PathEl.Typ = <typ>
  PathEl.Int = <int>
  PathEl.Real = <real>
  PathEl.Str = <str>
  PathEl.Hd = <head>
  PathEl.Tl = <tail>

sorts PatV
context-free syntax
  PatV.Fun = <Fun(<Id>, <Int>)>
  PatV.Str = String
  PatV.Int = Int
  PatV.Real = Real
  PatV.Anno = <anno>
  PatV.Tuple = <Tuple(<Int>)>

sorts PatT
context-free syntax
  PatT.ApplT = <APPL>
  PatT.ListT = <LIST>
  PatT.IntT = <INT>
  PatT.RealT = <REAL>
  PatT.StringT = <STRING>
//  PatT.CtorT = <CTOR>
  PatT.TupleT = <TUPLE>
//  PatT.RefT = <REF>
//  PatT.BlobT = <BLOB>
//  PatT.PlaceT = <PLACEHOLDER>

context-free priorities
  { Strategy.Build
    Strategy.Match
  }
> Strategy.Seq
> Strategy.GuardedLChoice

context-free priorities
DTree.Leaf <0> > { DTree.Leaf
                   // DTree.Fail
                   DTree.SwitchT
                   /*DTree.Swap*/ }

context-free syntax
  Strategy.ImportTerm = <import-term(<ModName>)>
