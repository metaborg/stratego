/**
 * This module contains strategies for operating on immutable binary relations.
 *
 * Note that these relations do not support generic traversal. These are "blob" terms without children
 * and need to be operated on through the strategies in this module.
 *
 * @author Jeff Smits <mail@jeffsmits.net>
 *
 */
module collection/immutable/rel
imports
  strategy/conditional
  collection/list/cons
  collection/tuple/cons
  collection/immutable/set
  collection/immutable/map

signature
  sorts
    ImmutableRelation(*, *)
    ImmutableRelationImplBlob
  constructors
    /**
     * Represents a reference to a Set
     */
    ImmutableRelation : ImmutableRelationImplBlob -> ImmutableRelation(k, v)
    : blob -> ImmutableRelationImplBlob

/**
 * Immutable relation construction and deconstruction
 */
strategies

/**
 * Create an empty immutable relation.
 *
 * @type _ -> ImmutableRelation
 */
imrel-new :: a -> ImmutableRelation(k, v)
imrel-new = prim("SSL_immutable_relation"); !ImmutableRelation(<id>)

/**
 * Create an immutable relation from a list of pairs.
 *
 * @type List -> ImmutableRelation
 */
imrel-from-list :: List(k * v) -> ImmutableRelation(k, v)
imrel-from-list = prim("SSL_immutable_relation_from_list"); !ImmutableRelation(<id>)

/**
 * Turn the immutable relation into a list of pairs.
 *
 * @type ImmutableRelation -> List
 */
imrel-to-list :: ImmutableRelation(k, v) -> List(k * v)
imrel-to-list = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_list")

/**
 * Turn the immutable relation into a map.
 * For pairs with the same key, the values are merged with the second parameter.
 *
 * @type ImmutableRelation -> ImmutableMap
 */
imrel-to-map(v * v -> v) :: ImmutableRelation(k, v) -> ImmutableMap(k, v)
imrel-to-map(merge) = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_map", merge|); !ImmutableMap(<id>)

/**
 * Turn the immutable relation into a list of pairs.
 *
 * @type ImmutableRelation -> List
 */
imrel-pairs :: ImmutableRelation(k, v) -> List(k * v)
imrel-pairs = imrel-to-list

/**
 * Turn the immutable relation into a set of pairs.
 *
 * @type ImmutableRelation -> ImmutableSet
 */
imrel-pairs-imset :: ImmutableRelation(k, v) -> ImmutableSet(k * v)
imrel-pairs-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_set"); !ImmutableSet(<id>)

/**
 * Get all keys of the immutable relation.
 *
 * @type ImmutableRelation -> List
 */
imrel-keys :: ImmutableRelation(k, v) -> List(k)
imrel-keys = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_keys")

/**
 * Get all keys of the immutable relation as an immutable set.
 *
 * @type ImmutableRelation -> List
 */
imrel-keys-imset :: ImmutableRelation(k, v) -> ImmutableSet(k)
imrel-keys-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_keys_set"); !ImmutableSet(<id>)

/**
 * Get all values of the immutable relation.
 *
 * @type ImmutableRelation -> List
 */
imrel-values :: ImmutableRelation(k, v) -> List(v)
imrel-values = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_values")

/**
 * Get all values of the immutable relation.
 *
 * @type ImmutableRelation -> ImmutableSet
 */
imrel-values-imset :: ImmutableRelation(k, v) -> ImmutableSet(v)
imrel-values-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_values_set"); !ImmutableSet(<id>)

/**
 * Take the transitive closure of the relation.
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-transitive-closure :: ImmutableRelation(k, k) -> ImmutableRelation(k, k)
imrel-transitive-closure = ImmutableRelation(prim("SSL_immutable_relation_transitive_closure"))

/**
 * Take the reflexive transitive closure of the relation.
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-reflexive-transitive-closure :: ImmutableRelation(k, k) -> ImmutableRelation(k, k)
imrel-reflexive-transitive-closure =
  ImmutableRelation(prim("SSL_immutable_relation_reflexive_transitive_closure"))

/**
 * Invert the relation (swap all the pairs).
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-invert :: ImmutableRelation(k, v) -> ImmutableRelation(v, k)
imrel-invert: ImmutableRelation(b) ->
  ImmutableRelation(<prim("SSL_immutable_relation_inverse")> b)

/**
 * Elemental operations
 */
strategies

/**
 * Succeeds if the given immutable relation is empty.
 *
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-empty :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-empty = equal(|<imrel-new>)

/**
 * Succeeds if the key is in the immutable relation.
 *
 * @param k - the key
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-contains-key(|k) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-contains-key(|k) = where(imrel-get(|k); not(imset-empty))

/**
 * Succeeds if the key is in the immutable relation.
 *
 * @param k - the key
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-contains(|k, v) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-contains(|k, v) = ImmutableRelation(prim("SSL_immutable_relation_contains", k, v))

/**
 * Returns the associated value of the key in the immutable relation,
 * or fails if the key is not in the immutable relation.
 *
 * @param e - the key used to look up the value
 * @type ImmutableRelation -?> ImmutableSet
 */
imrel-get(|k) :: ImmutableRelation(k, v) -> ImmutableSet(v)
imrel-get(|k) = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_get", k); !ImmutableSet(<id>)

/**
 * Inserts an element in the immutable relation. Returns a new relation with the added element.
 *
 * @param e - the element that is inserted
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-insert(|k, v) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-insert(|k, v) = ImmutableRelation(prim("SSL_immutable_relation_insert", k, v))

/**
 * Removes an element in the immutable relation. Returns a new relation without the removed element.
 *
 * @param e - the element that is removed
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-remove(|k) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-remove(|k) = ImmutableRelation(prim("SSL_immutable_relation_remove", k))

/**
 * Higher-order operations
 */
strategies

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term * Term -?> Term * Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter(k1 * v1 -> k2 * v2) :: ImmutableRelation(k1, v1) -> ImmutableRelation(k2, v2)
imrel-filter(s): ImmutableRelation(b) -> ImmutableRelation(<prim("SSL_immutable_relation_filter", s|)> b)

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails on the key.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter-keys(k1 -> k2) :: ImmutableRelation(k1, v) -> ImmutableRelation(k2, v)
imrel-filter-keys(s) = imrel-filter((s, id))

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails on the value.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter-values(v1 -> v2) :: ImmutableRelation(k, v1) -> ImmutableRelation(k, v2)
imrel-filter-values(s) = imrel-filter((id, s))

/**
 * Map all pairs from the immutable relation.
 * Returns a new immutable relation with the mapped pairs.
 *
 * @param s: Term * Term -?> Term * Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map(k1 * v1 -> k2 * v2) :: ImmutableRelation(k1, v1) -> ImmutableRelation(k2, v2)
imrel-map(s): ImmutableRelation(b) -> ImmutableRelation(<prim("SSL_immutable_relation_map", s|)> b)

/**
 * Map all keys from the immutable relation.
 * Returns a new immutable relation with the mapped keys.
 *
 * @param s: Term -> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map-keys(k1 -> k2) :: ImmutableRelation(k1, v) -> ImmutableRelation(k2, v)
imrel-map-keys(s) = imrel-map((s, id))

/**
 * Map all values from the immutable relation.
 * Returns a new immutable relation with the mapped values.
 *
 * @param s: Term -> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map-values(v1 -> v2) :: ImmutableRelation(k, v1) -> ImmutableRelation(k, v2)
imrel-map-values(s) = imrel-map((id, s))

/**
 * Combining operations
 */
strategies

/**
 * Compose with another immutable relation.
 * Returns a new immutable relation with all pairs (x,z) where there is a y such that (x,y) in this
 * and (y,z) in other.
 *
 * @param other: ImmutableRelation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-compose(|ImmutableRelation(k2, k3)) :: ImmutableRelation(k1, k2) -> ImmutableRelation(k1, k3)
imrel-compose(|r): ImmutableRelation('one) -> ImmutableRelation(<prim("SSL_immutable_relation_compose", other)> 'one)
  where ImmutableRelation(other) := r

/**
 * Intersect with another immutable relation.
 * Returns a new immutable relation with the pairs that are in both relations.
 *
 * @param other: ImmutableRelation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-intersect(|ImmutableRelation(k, v)) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-intersect(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_intersect", other))

/**
 * Intersect two immutable relations.
 * Returns a new immutable relation with the pairs that are in both relations.
 *
 * @type ImmutableRelation * ImmutableRelation -> ImmutableRelation
 */
imrel-intersect :: ImmutableRelation(k, v) * ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-intersect =
  ?(l, r); <imrel-intersect(|r)> l

/**
 * Subtract another immutable relation from the given one.
 * Returns a new immutable relation without the pairs in the other immutable relation.
 *
 * @param other: ImmutableRelation - the relation to remove from the current term immutable relation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-subtract(|ImmutableRelation(k, v)) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-subtract(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_subtract", other))

/**
 * Subtract the right immutable relation from the left.
 * Returns a new immutable relation without the pairs in the other immutable relation.
 *
 * @type ImmutableRelation * ImmutableRelation -> ImmutableRelation
 */
imrel-subtract :: ImmutableRelation(k, v) * ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-subtract =
  ?(l, r); <imrel-subtract(|r)> l

/**
 * Union with another immutable relation.
 * Returns a new relation with the union of the pairs in the two relation.
 *
 * @param other: ImmutableRelation - the relation to remove from the current term immutable relation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-union(|ImmutableRelation(k, v)) :: ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-union(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_union", other))

/**
 * Union two immutable relations.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new relation with the union.
 *
 * @param m: Term * Term -> Term
 * @type ImmutableRelation * ImmutableSet -> ImmutableRelation
 */
imrel-union :: ImmutableRelation(k, v) * ImmutableRelation(k, v) -> ImmutableRelation(k, v)
imrel-union =
  ?(l, r); <imrel-union(|r)> l
