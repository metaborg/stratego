/**
 * Integer arithmetic and comparison.
 */
module term/integer
imports
  collection/list/common
  collection/list/cons
  collection/tuple/common
  collection/tuple/cons
  lang/dynamic-rules
  strategy/iteration
  term/real
  term/string

strategies

  is-int :: ? -> int
  is-int =
    ?i; prim("SSL_is_int", i)

strategies

  /**
   * Adds two numbers (integer or real)
   */
  add :: ? * ? -> ?
  add  = ?(x,y); (prim("SSL_addi",x,y) <+ prim("SSL_addr",x,y))

  /**
   * Adds two integers
   */
  addi :: int * int -> int
  addi = ?(x,y); prim("SSL_addi",x,y)

  /**
   * Adds two integers
   */
  int-add(|int) :: int -> int
  int-add(|y) =
    ?x; prim("SSL_addi", x, y)

  /**
   * Adds two reals
   */
  addr :: real * real -> real
  addr = ?(x,y); prim("SSL_addr",x,y)

strategies

  /**
   * Bitwise OR's two integers
   */
  iori :: int * int -> int
  iori = ?(x, y); prim("SSL_iori",x,y)

  /**
   * Bitwise XOR's two integers
   */
  xori :: int * int -> int
  xori = ?(x, y); prim("SSL_xori",x,y)

  /**
   * Bitwise AND's two integers
   */
  andi :: int * int -> int
  andi = ?(x, y); prim("SSL_andi",x,y)

  /**
   * Bitwise shift x to the left by y places
   */
  shli :: int * int -> int
  shli = ?(x, y); prim("SSL_shli",x,y)

  /**
   * Bitwise shift x to the right by y places
   */
  shri :: int * int -> int
  shri = ?(x, y); prim("SSL_shri",x,y)

strategies

  /**
   * Subtracts two numbers (integer or real)
   */
  subt :: ? * ? -> ?
  subt  = ?(x,y); (prim("SSL_subti",x,y) <+ prim("SSL_subtr",x,y))

  /**
   * Subtracts two integers
   */
  subti :: int * int -> int
  subti = ?(x,y); prim("SSL_subti",x,y)

  /**
   * Subtracts two integers
   */
  int-subt(|int) :: int -> int
  int-subt(|y) =
    ?x; prim("SSL_subti", x, y)

  /**
   * Subtracts two reals
   */
  subtr :: real * real -> real
  subtr = ?(x,y); prim("SSL_subtr",x,y)

strategies

  /**
   * Multiplies two numbers (integer or real)
   */
  mul :: ? * ? -> ?
  mul   = ?(x,y); (prim("SSL_muli",x,y) <+ prim("SSL_mulr",x,y))

  /**
   * Multiplies two integers
   */
  muli :: int * int -> int
  muli  = ?(x,y); prim("SSL_muli",x,y)

  /**
   * Multiplies two reals
   */
  mulr :: real * real -> real
  mulr  = ?(x,y); prim("SSL_mulr",x,y)

strategies

  /**
   * Divides two numbers (integer or real)
   */
  div :: ? * ? -> ?
  div = ?(x,y); (prim("SSL_divi",x,y) <+ prim("SSL_divr",x,y))

  /**
   * Divides two integers
   */
  divi :: int * int -> int
  divi  = ?(x,y); prim("SSL_divi",x,y)

  /**
   * Divides two reals
   */
  divr :: real * real -> real
  divr  = ?(x,y); prim("SSL_divr",x,y)

strategies

  /**
   * Returns the modulo (remainder after division) of two integers or reals.
   */
  mod :: ? * ? -> ?
  mod = ?(x,y); (prim("SSL_modi",x,y) <+ prim("SSL_modr",x,y))

  /**
   * Returns the modulo (remainder after division) of two integers
   */
  modi :: int * int -> int
  modi =
    ?(x,y); prim("SSL_modi",x,y)

  /**
   * Returns the modulo (remainder after division) of two floats
   */
  modr :: real * real -> real
  modr =
    ?(x,y); prim("SSL_modr",x,y)

strategies

  gt :: ? * ? -> ? * ?
  gt    = ?(x,y); where(prim("SSL_gti",x,y) <+ prim("SSL_gtr",x,y))

  gti :: int * int -> int * int
  gti    = ?(x,y); where(prim("SSL_gti",x,y))

  gtr :: real * real -> real * real
  gtr    = ?(x,y); where(prim("SSL_gtr",x,y))

  geq :: ? * ? -> ? * ?
  geq = ?(x,x) <+ gt

  lt :: ? * ? -> ? * ?
  lt  = not(geq)

  leq :: ? * ? -> ? * ?
  leq = not(gt)

  int-geq :: int * int -> int * int
  int-geq = ?(x,x) <+ gti

  int-lt :: int * int -> int * int
  int-lt = not(int-geq)

  int-leq :: int * int -> int * int
  int-leq = not(gti)

strategies

  /**
   * @type Int -> Int
   */
  int-leq(|int) :: int -> int
  int-leq(|y) =
    not(int-gt(|y))

  /**
   * @type Int -> Int
   */
  int-gt(|int) :: int -> int
  int-gt(|y) =
    ?x; where(prim("SSL_gti",x,y))

  /**
   * @type Int -> Int
   */
  int-lt(|int) :: int -> int
  int-lt(|y) =
    ?x; where(prim("SSL_lti", x, y))

strategies

  // :: Int * Int * Int -> fail?
  leq-leq :: ? * ? * ? -> ? * ? * ?
  leq-leq = comp-comp(leq, leq)

  leq-lt :: ? * ? * ? -> ? * ? * ?
  leq-lt  = comp-comp(leq, lt)

   lt-leq :: ? * ? * ? -> ? * ? * ?
   lt-leq = comp-comp(lt,  leq)

   lt-lt :: ? * ? * ? -> ? * ? * ?
   lt-lt  = comp-comp(lt,  lt)

  // Int * Int -> fail?, Int * Int -> fail? :: Int * Int * Int -> fail?
  comp-comp(a * a -> b, a * a -> c) :: a * a * a -> a * a * a
  comp-comp(s1, s2) =
      ?(x, y, z)
    ; where(<s1> (x, y); <s2> (y, z))

strategies

  /**
   * @type  Int -> fail?
   */
  even :: int -> int
  even = where(<modi> (<id>, 2) => 0)

  /**
   * @type (Int, Int) -> Int
   */
  max :: ? * ? -> ?
  max = gt < Fst + Snd

  min :: ? * ? -> ?
  min = gt < Snd + Fst

  int-max :: int * int -> int
  int-max = gti < Fst + Snd

  int-min :: int * int -> int
  int-min = gti < Snd + Fst

  /**
   * @type  Int -> Int
   */
  pos :: int -> int
  pos = where(<int-geq> (<id>, 0))

  neg :: int -> int
  neg = where(<int-lt>  (<id>, 0))

  int :: ? -> int
  int   = ?x; prim("SSL_int",x)

strategies

  /**
   * Sets a seed for the following sequence of next-random calls.
   * Typically, the seed is set to the Unix time (the result of the strategy time).
   *
   * @see    man srand
   * @since  0.9.4
   * @type   Int -> ()
   */
  set-random-seed :: int -> ?
  set-random-seed = ?seed; prim("SSL_srand", seed)

  /**
   * Gets the maximum random number that will be returned by the next-random number generator.
   * Corresponds to RAND_MAX in C.
   *
   * @type _ -> Int()
   */
  get-random-max :: ? -> int
  get-random-max = prim("SSL_RAND_MAX")

  /**
   * Returns a random number between 0 and get-random-max.
   *
   * For a given seed, this strategy always returns the same sequence  of numbers.
   * If no seed value has been set using set-random-seed, then the seed is 1, which
   * means that the sequence of random numbers will always be the same if you set no seed.
   *
   * @see    man rand
   * @since  0.9.4
   * @type   _ -> Int
   */
  next-random :: ? -> int
  next-random = prim("SSL_rand")

strategies

  apply-int-to-str-tuple(int * int -> int) :: string * string -> string
  apply-int-to-str-tuple(s) =
    (string-to-int, string-to-int) ; s ; int-to-string

  addS :: string * string -> string
  addS  = apply-int-to-str-tuple(add)

  subtS :: string * string -> string
  subtS = apply-int-to-str-tuple(subt)

  mulS :: string * string -> string
  mulS  = apply-int-to-str-tuple(mul)

  divS :: string * string -> string
  divS  = apply-int-to-str-tuple(div)

  modS :: string * string -> string
  modS  = apply-int-to-str-tuple(mod)

  maxS :: string * string -> string
  maxS  = apply-int-to-str-tuple(max)

  minS :: string * string -> string
  minS  = apply-int-to-str-tuple(min)

  gtS :: string * string -> string * string
  gtS   = where((string-to-int, string-to-int); gt)

  geqS :: string * string -> string * string
  geqS  = where((string-to-int, string-to-int); geq)

  ltS :: string * string -> string * string
  ltS   = where((string-to-int, string-to-int); lt)

  leqS :: string * string -> string * string
  leqS  = where((string-to-int, string-to-int); leq)

  /**
   * Increments a number.
   *
   * @type Int -> Int
   */
  inc :: ? -> ?
  inc = <add>  (<id>, 1)

  /**
   * Increments an integer
   *
   * @type Int -> Int
   */
  int-inc :: int -> int
  int-inc =
    int-add(|1)

  /**
   * Decrements a number.
   *
   * @type Int -> Int
   */
  dec :: ? -> ?
  dec = <subt> (<id>, 1)

  /**
   * Decrements an integer.
   *
   * @type Int -> Int
   */
  int-dec :: int -> int
  int-dec =
    int-subt(|1)

strategies

  log2 :: int -> int
  log2 =
    !(<id>, 0);
    repeat((!(<divi>(<id>, 2), <modi; ?0>(<id>, 2)); Fst, int-inc));
    ?(1, <id>)

strategies

  gcd :: int * int -> int
  gcd =
    (abs,abs)
  ; let
      gcd' :: int * int -> int
      gcd' = \ (x,0) -> x \ + \ (x,y) -> <gcd'>(y,<modi>(x,y)) \
    in
      gcd'
    end

  abs :: int -> int
  abs =
    (is-int + is-real)
    ; if neg then
        <subti> (0, <id>)
      end

signature
  sorts
    IntI
  constructors
    Infinite : IntI
             : int -> IntI

rules

  add-inf =
    let add-inf1: (Infinite(), _) -> Infinite()
        add-inf2: (_, Infinite()) -> Infinite()
     in (add-inf1 + add-inf2) <+ add
    end

  lt-inf = ?(<is-int>, Infinite()) <+ (is-int, is-int); lt

strategies

  new-counter =
    new; reset-counter

  reset-counter = ?c;
    where(<set-counter> (c, 0))

  set-counter =
    ?(c,n); rules( Counter : c -> n )

  get-counter =
    Counter <+ <set-counter> (<id>, 0); !0

  next-counter =
    ?c; get-counter; inc; where(<set-counter> (c, <id>))

strategies

  int-to-string :: int -> string
  int-to-string = ?x; prim("SSL_int_to_string",x)

  string-to-int :: string -> int
  string-to-int = ?x; prim("SSL_string_to_int",x)

/**
 * Conversion of strings to integers
 */
strategies

 /**
  * @type String -> Int
  * @inc hex-string-test
  */
  hex-string-to-int :: string -> int
  hex-string-to-int = <generic-string-to-int> (<id>, 16)

 /**
  * @type String -> Int
  * @inc dec-string-test
  */
  dec-string-to-int :: string -> int
  dec-string-to-int = <generic-string-to-int> (<id>, 10)

  oct-string-to-int :: string -> int
  oct-string-to-int = <generic-string-to-int> (<id>, 8)

 /**
  * @type String -> Int
  * @inc bin-string-test
  */
  bin-string-to-int :: string -> int
  bin-string-to-int = <generic-string-to-int> (<id>, 2)

  /**
   * @type List(Char) -> Int
   */
  hex-chars-to-int :: List(int) -> int
  hex-chars-to-int = <generic-chars-to-int> (<id>, 16)

  /**
   * @type List(Char) -> Int
   */
  dec-chars-to-int :: List(int) -> int
  dec-chars-to-int = <generic-chars-to-int> (<id>, 10)

  /**
   * @type List(Char) -> Int
   */
  oct-chars-to-int :: List(int) -> int
  oct-chars-to-int = <generic-chars-to-int> (<id>, 8)

  /**
   * @type List(Char) -> Int
   */
  bin-chars-to-int :: List(int) -> int
  bin-chars-to-int = <generic-chars-to-int> (<id>, 2)

  /**
   * @type String * Int -> Int
   */
  generic-string-to-int :: string * int -> int
  generic-string-to-int =
      (explode-string, id)
    ; generic-chars-to-int

  /**
   * @type List(Char) * Int -> Int
   */
  generic-chars-to-int :: List(int) * int -> int
  generic-chars-to-int =
    neg-chars-to-int <+ pos-chars-to-int

  // :: List(Char) * Int -> Int
  neg-chars-to-int :: List(int) * int -> int
  neg-chars-to-int:
    (['-' | chars], radix) -> <muli> (-1, <pos-chars-to-int> (chars, radix))
      where <gt> (<length> chars, 0)

  // :: List(Char) * Int -> Int
  pos-chars-to-int :: List(int) * int -> int
  pos-chars-to-int =
      ?([char | chars], r)
    ; <foldl(<addi> (<char-to-digit> (<Fst>, r), <muli> (<Snd>, r)))>
        (chars, <char-to-digit> (char, r))

  // :: Char -> Int
  char-to-digit :: int * int -> int
  char-to-digit:
    (x, radix) -> result
      where <is-num> x
          ; <subti> (x, '0') => result
          ; <int-lt> (result, radix)

  char-to-digit:
    (x, 16) -> <addi> (10, <subti> (x, 'a'))
      where <leq-leq> ('a', x, 'f')

  char-to-digit:
    (x, 16) -> <addi> (10, <subti> (x, 'A'))
      where <leq-leq> ('A', x, 'F')
