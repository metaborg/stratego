module main

imports

libstratego-lib
libstrc

libspoofax/term/annotation

utils
environment
signatures
immutable/map
immutable/set

rules

desugar-SType = otf(\FunNoArgsType(i, o) -> FunTType([], [], i, o)\)
desugar-SType = otf(\FunType(targs, i, o) -> FunTType([], targs, i, o)\)

desugar-Type = otf(\SortVar("str") -> StringT()\)
desugar-Type = otf(\SortVar("int") -> IntT()\)
desugar-Type = otf(\SortVar("real") -> RealT()\)

strategies

// This is the mapping from the directed consistency rule (t ~> t) to coercions (t ~> t : c)
computeCoercion(|lvl, from, to): subj -> <computeCoercion(|subj)> (lvl, from, to)
computeCoercion(|from, to): subj -> <computeCoercion(|subj)> (Err(), from, to)

// computeCoercion :: Type * Type -> Coercion
computeCoercion: (from, to) -> <computeCoercion(|from)> (Err(), from, to)

// computeCoercion :: MessageType * Type * Type -> Coercion
computeCoercion(|subj): (_, _, Dyn()) -> Id()
computeCoercion(|subj): (_, ErrT(), _) -> Id()
computeCoercion(|subj): (Err(), Dyn(), to) -> RuntimeCheck(to)
computeCoercion(|subj): (Warn(), Dyn(), to) -> Id()
computeCoercion(|subj): (lvl, from, to) -> coercion
  where if <CanCoerce> (from, to)
    then coercion := Id()
    else rules(Message :+ lvl -> (subj, NoInjectionBetween(from, to)))
       ; if Err() := lvl
           then coercion := Fail()
           else coercion := Id()
         end
  end

// computeSCoercion :: (|SType, SType) ? -> SCoercion
computeSCoercion: (_, SDyn()) -> SId()
computeSCoercion: (SDyn(), sft@FunTType(_, _, _, _)) -> SRuntimeCheck(sft)

// Add a cast after the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()).
insertCastAfter(|from, to) = insertCastAfter(|Err(), from, to)
insertCastAfter(|lvl, from, to): strat -> strat'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)>)
  ; strat' := <try(rm-redundant-cast)> Seq(strat, cast)

// Add a cast before the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastBefore(|from, to) = insertCastBefore(|Err(), from, to)
insertCastBefore(|lvl, from, to): strat -> strat'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)>)
  ; strat' := <try(rm-redundant-cast)> Seq(cast, strat)

// Add a cast on the current term (the App or `<cast(to)> term`) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastApp(|from, to) = insertCastApp(|Err(), from, to)
insertCastApp(|lvl, from, to): term -> term'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)>)
  ; term' := <try(rm-redundant-cast)> App(cast, term)

// Used to remove Id() casts
rm-redundant-cast: Seq(Cast(Id()), strat) -> strat
rm-redundant-cast: Seq(strat, Cast(Id())) -> strat
rm-redundant-cast: App(Cast(Id()), term) -> term

toBinding-DefHasType: DefHasType(name, stype) -> (name{}, stype)
toBinding-SDefT: d@SDefT(name, sargs, targs, _) ->
  ( name{}
  , <otf(!FunTType(
      <map(otf(toBinding-SDefT-Typedid))> sargs
    , <map(otf(!Dyn()))> targs
    , <otf(!Dyn())> d
    , <otf(!Dyn())> d))> d)
toBinding-SDefT-Typedid = ?VarDec(_, <toBinding-SDefT-ConstType + toBinding-SDefT-FunType>)
toBinding-SDefT-Typedid: DefaultVarDec(_) -> FunTType([], [], Dyn(), Dyn())
toBinding-SDefT-ConstType: ConstType(s) -> Dyn()
toBinding-SDefT-FunType: FunType(a*, r) -> SDyn()

strategies // entry-points from Java

// This is a quick&dirty testing entry point for running this code on a ctree file. 
// insertCasts :: Map(String, SType) * Map(String, OldType) * Set(String, String) * Map(Type * Type, Type) * MessageType * Module -> (Module, List(Message))
insert-casts-top-level: ast ->
  <Specification(map(Imports(id) + Signature(id) + Strategies(map(insertCasts-Def(|strats, constrs, injection-closure, lub-map, Err())))))> ast
  with
    (constrs, injs) := <extract-constrs-inj> ast
  ; injection-closure := <compute-closure> (injs, <immap-values-imset> injs)
  ; lub-map := <lub-map> injection-closure
  ; strats := <extract-strategy-types> ast

extract-constrs-inj =
  ?Specification(<filter(?Signature(<filter(?Constructors(<id>));concat>));concat>)
; partition(extract-constr, extract-inj)
; (immap-from-list, immap-from-list)

extract-constr: OpDecl(c, t) -> (c, t)
extract-constr: OpDeclQ(c, t) -> (c, t)
extract-constr: OpDeclInj(t@FunType([_, _ | _], _)) -> ("", t)

extract-inj: OpDeclInj(FunType([from], to)) -> (from, to)

compute-closure: (map1, []) -> map1
compute-closure: (map1, frontier1) -> map3
  with
    pairs := <imset-elements;filter(\k -> (k, <immap-get(|k)> map1)\)> frontier1
  ; frontier2 := <map(Snd);foldr(imset-new, imset-union)> pairs
  ; map2 := <immap-union(imset-union)> (map1, <immap-from-list> pairs)
  ; map3 := <compute-closure> (map2, frontier2)

lub-map: injection-closure -> <imset-union> (forward, backward)
with
  pairs := <immap-to-list> injection-closure
; forward := <map(\(k, v) -> <imset-map(!(k, <id>))> v\);foldr(imset-new, imset-union)> pairs
; backward := <imset-map(Swap)> forward

extract-strategy-types =
  ?Specification(<filter(?Signature(<filter(?Strategies(<id>));concat>));concat>)
; map(extract-strategy-type)
; immap-from-list

extract-strategy-type = toBinding-DefHasType <+ toBinding-SDefT


insertCasts-Def(|strats, constrs, injection-closure, lub-map, lvl): ast ->
  <insert-casts> (strats, constrs, injection-closure, lub-map, lvl, ast)

/**
 * insert-casts/0 inserts casts into a Stratego strategy/rule definition based on a gradual type system.
 * strats: map of top-level-definition names to the type description of the strategy
 * constrs: map of constructor definition names to type description
 * injection-closure: map of injections from one type to another (the transitive closure)
 * lub-map: map representing the least-upper-bound of the type lattice
 * lvl: the level of strictness of constructors (Err() = strict, Warn() = non-strict, no casts)
 * ast: the stratego strategy/rule ast
 */
// insertCasts :: Map(String * Int * Int, SType) * Map(String * Int, OldType) * Set(String, String) * Map(Type * Type, Type) * MessageType * Decl -> (Decl, List(Message))
insert-casts: (strats, constrs, injection-closure, lub-map, lvl, ast) -> (ast', errs, warns, notes)
  with {| CanCoerce, LUB, Message, ConstructorStrictness:
    rules(CanCoerce: (from, to) ->
      <imset-contains(|(from, to)) <+ <eq> (from, to) <+ <?ErrT() + ?FailT()> from> injection-closure)
  ; rules(LUB: pair -> <if eq then Fst else <immap-get(|pair)> lub-map end> pair)
  ; rules(ConstructorStrictness := lvl)
  ; ast' := <insertCasts-Def(|<new-env> (strats, constrs), <new-st>)> ast
  ; errs := <bagof-Message> Err()
  ; warns := <bagof-Message> Warn()
  ; notes := <bagof-Message> Note()
  |}

strategies // Def

// insertCasts-Def :: (|Environment, Store) Def -> Def
insertCasts-Def(|e1, st1):
  AnnoDef(annos, s@SDefT(name, _, _, _)) -> AnnoDef(annos, s')
  with
    if <fetch(?Extend() + Override())> annos
      // Leaving this in the env for ProceedT/2 and ProceedNoArgs/0 handling
      then e2 := <strat-copy-type(|name{}, ProceedNoArgs())> e1
      else e2 := e1
    end
  ; (s', _) := <insertCasts-StrategyDef(|e2, st1)> s

insertCasts-Def(|e1, st1) = ?AnnoDef(_, ExtSDef(_, _, _))

insertCasts-Def(|e1, st1) = insertCasts-StrategyDef(|e1, st1)

strategies // StrategyDef

// insertCasts-StrategyDef :: (|Environment, Store) Decl -> (Decl, Store)
insertCasts-StrategyDef(|e1, st1):
  SDefT(x, s*, t*, s1) -> (SDefT(x, s*, t*, s3), st3)
  with
    FunTType(st*, tt*, t1, t2) := <strat-lookup(|x{})> e1
  ; e2 := <strat-merge-env(keep-right)> (e1, <zip-new-env> (s*, st*))
  ; st2 := <term-merge-env(keep-right);current-type(|t1)> (st1, <zip-new-env> (t*, tt*))
  ; (s2, st3) := <insertCasts-Strategy(|e2, st2)> s1
  ; s3 := <insertCastAfter(|<current-type> st3, t2)> s2

insertCasts-StrategyDef(|e1, st1) =
    \ExtSDefInl(name, sargs, targs, body) -> SDefT(name, sargs, targs, body)\
  ; insertCasts-StrategyDef(|e1, st1)
  ; (\SDefT(name, sargs, targs, body) -> ExtSDefInl(name, sargs, targs, body)\, id, id)

insertCasts-StrategyDef(e1, st1) = ?ExtSDef(_, _, _)

strategies // Strategy

// insertCasts-Strategy :: (|Environment, Store) Strategy -> (Strategy, Store)
insertCasts-Strategy(|e1, st1):
  Let(d1*, s1) -> (Let(d2*, s2), st3)
  with
    e2 := <strat-merge-env(keep-right)> (e1, <getDefTypes> d1*)
  ; let
      threader = \(d, st) -> <insertCasts-StrategyDef(|e2, st)> d\
    in (d2*, st2) := <thread-map(threader)> (d1*, st1)
    end
  ; (s2, st3) := <insertCasts-Strategy(|e2, st2)> s1

//outputType, outTerms|strats, constrs, terms, inputType
insertCasts-Strategy(|e1, st1):
  c@CallT(SVar(x), s*, t*) -> result
  with
    if t1 := <strat-lookup(|x{})> e1
      then
        result := <insertCasts-CallT(|e1, st1)> (c, t1)
      else
        rules(Message :+ Err() -> (x, UnresolvedName()))
      ; result := (c, <current-type(|ErrT())> st1)
    end

insertCasts-CallT(|e1, st1):
  (CallT(s, s1*, t1*), FunTType(st*, tt*, t1, t2)) -> (call, st4)
  with
    s2* := <zip> (s1*, st*)
  ; t2* := <zip> (t1*, tt*)
  ; let
      insertCasts-Sarg = \(b, st) -> <insertCasts-Sarg(|e1, st)> b\
      insertCasts-Targ = \(b, st) -> <insertCasts-Targ(|e1, st)> b\
    in
      (s3*, st2) := <thread-map(insertCasts-Sarg)> (s2*, st1)
    ; (t3*, st3) := <thread-map(insertCasts-Targ)> (t2*, st2)
    end
  ; st4 := <current-type(|t2)> st3
  ; call := <insertCastBefore(|<current-type> e1, t1)> CallT(s, s3*, t3*)

insertCasts-CallT(|e1, st1):
  (call, SDyn()) -> (call, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  call@CallDynamic(_, _, _) -> (call, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  s@Fail() -> (s, <current-type(|FailT())> st1)

insertCasts-Strategy(|e1, st1):
  s@Id() -> (s, st1)

insertCasts-Strategy(|e1, st1):
  p@ProceedT(s1*, t1*) -> (call, st4)
  with
    FunTType(st*, tt*, t1, t2) := <strat-lookup(|ProceedNoArgs())> e1
  ; if not(<eq> (<length> st*, <length> s1*); <eq> (<length> tt*, <length> t1*))
      then rules(Message :+ Err() -> (p, ProceedWrongNumberOfArguments(<length> st*, <length> tt*)))
    end
  ; s2* := <zip> (s1*, st*)
  ; t2* := <zip> (t1*, tt*)
  ; let
      insertCasts-Sarg = \(b, st) -> <insertCasts-Sarg(|e1, st)> b\
      insertCasts-Targ = \(b, st) -> <insertCasts-Targ(|e1, st)> b\
    in
      (s3*, st2) := <thread-map(insertCasts-Sarg)> (s2*, st1)
    ; (t3*, st3) := <thread-map(insertCasts-Targ)> (t2*, st2)
    end
  ; st4 := <current-type(|t2)> st3
  ; call := <insertCastBefore(|<current-type> e1, t1)> ProceedT(s3*, t3*)

insertCasts-Strategy(|e1, st1):
  p@ProceedNoArgs() -> (call, st2)
  with
    FunTType(st*, tt*, t1, t2) := <strat-lookup(|ProceedNoArgs())> e1
  ; if not([] := st*; [] := tt*)
      then rules(Message :+ Err() -> (p, ProceedWrongNumberOfArguments(<length> st*, <length> tt*)))
    end
  ; st2 := <current-type(|t2)> st1
  ; call := <insertCastBefore(|<current-type> e1, t1)> p

insertCasts-Strategy(|e1, st1):
  Match(trm1) -> (Match(trm2), st3)
  with
    (trm2, st2) := <insertCasts-MatchTerm(|e1, st1)> trm1
  ; st3 := <current-type(|<LUB> (<current-type> st1, <current-type> st2))> st2

insertCasts-Strategy(|e1, st1):
  Build(trm1) -> (Build(trm2), st3)
  with
    (trm2, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; st3 := <current-type(|<LUB> (<current-type> st1, <current-type> st2))> st2

//outputType, outTerms|strats, constrs, terms, inputType
insertCasts-Strategy(|e1, st1):
  Scope(x*, s1) -> (Scope(x*, s2), st3)
  with
    // TODO: support type annotations on local variables
    st2 := <term-merge-env(keep-right)> (st1, <map(!(<id>, Dyn())); immap-from-list> x*)
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1

insertCasts-Strategy(|e1, st1):
  Seq(s1, s2) -> (Seq(s3, s4), st3)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, st2)> s2

insertCasts-Strategy(|e1, st1):
  GuardedLChoice(s1, s2, s3) -> (GuardedLChoice(s4, s5, s6), st5)
  with
    (s4, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s5, st3) := <insertCasts-Strategy(|e1, st2)> s2
  ; (s6, st4) := <insertCasts-Strategy(|e1, st1)> s3
  ; st5 := <st-merge(LUB <+ !Dyn())> (st3, st4)

insertCasts-Strategy(|e1, st1):
  s@PrimT(_, _, _) -> (s, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  s@Some(_) -> (s, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  s@One(_) -> (s, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  s@All(_) -> (s, <current-type(|Dyn())> st1)

insertCasts-Strategy(|e1, st1):
  s@ImportTerm(_) -> (s, <current-type(|Dyn())> st1)

insertCasts-Sarg(|e1, st1):
  (c@CallT(SVar(v), [], []), t1@FunTType([_|_], [_|_], _, _)) -> (s, st1)
  with
    t2 := <strat-lookup(|v{})> e1
  ; s := <insertCasts-Sarg-CallNoArgs> (v, t1, t2)

insertCasts-Sarg(|e1, st1):
  (s1, t1@FunTType(st*, tt*, t2, t3)) -> (s2, st2)
with
  (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|t2)> st1)> s1
; if not([] := st*; [] := tt*)
    then rules(Message :+ Err() -> (s1, CallStrategyArgumentTakesParameters(t1)))
  end
; s3 := <rm-redundant-proxy> Proxy(Id(), <computeCoercion(|<current-type> st2, t3)>, s2)

insertCasts-Sarg(|e1, st1):
  (s1, SDyn()) -> (s2, st2)
  with (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|Dyn())> st1)> s1

insertCasts-Sarg-CallNoArgs:
  (v, t1@FunTType(st1*, tt1*, t2, t3), t4@FunTType(st2*, tt2*, t4, t5)) -> ProxyT(sc*, tc*, c1, c2, v)
  with
    if not(<eq> (<length> st1*, <length> st2*); <eq> (<length> tt1*, <length> tt2*))
      then rules(Message :+ Err() -> (v, TypeMismatch(t1, t4)))
    end
  ; sc* := <zip(computeSCoercion)> (st1*, st2*)
  ; tc* := <zip(computeCoercion)> (tt1*, tt2*)
  ; c1 := <computeCoercion(|t2, t4)>
  ; c2 := <computeCoercion(|t5, t3)>

insertCasts-Sarg-CallNoArgs:
  (v, FunTType(st*, tt*, t1, t2), SDyn()) -> ProxyT(sc*, tc*, Id(), c, v)
  with
    sc* := <map(!Id())> st*
  ; tc* := <map(!Id())> tt*
  ; c := <computeCoercion(|Dyn(), t2)>

rm-redundant-proxy = try(?Proxy(Id(), Id(), <id>))

insertCasts-Targ(|e1, st1):
  t1 -> (t3, st2)
  with
    (t2, st2) := <insertCasts-BuildTerm(|e1, st1)> t1
  ; t3 := <insertCastAfter(|<current-type> st2, <current-type> st1)> t2

strategies // Terms

insertCasts-MatchTerm(|e1, st1):
  trm@Var(v) -> (trm, st2)
  with
    t1 := <current-type> st1
  ; if t2 := <term-lookup(|v{})> st1
      then if not(st2 := <term-put(|v{}, <LUB> (t1, t2))> st1)
        then
          rules(Message :+ Err() -> (v, VariableBoundToIncompatibleType(t2, t1)))
        ; st2 := st1
      end
      else st2 := <term-put(|v{}, t1)> st1
    end

insertCasts-MatchTerm(|e1, st1):
  As(Var(v), trm1) -> (As(Var(v), trm2), st2)
  with
    t1 := <current-type> st1
  ; if t2 := <term-lookup(|v{})> st1
      then if not(st2 := <term-put(|v{}, <LUB> (t1, t2))> st1)
        then
          rules(Message :+ Err() -> (v, VariableBoundToIncompatibleType(t2, t1)))
        ; st2 := st1
      end
      else st2 := <term-put(|v{}, t1)> st1
    end
  ; trm2 := <insertCasts-MatchTerm(|e1, st2)> trm1

insertCasts-MatchTerm(|e1, st1):
  trm@Wld() -> (trm, st1)

insertCasts-MatchTerm(|e1, st1):
  Int(_) -> <insertCasts-MatchTerm-Lit(|e1, st1, IntT())>

insertCasts-MatchTerm(|e1, st1):
  Real(_) -> <insertCasts-MatchTerm-Lit(|e1, st1, RealT())>

insertCasts-MatchTerm(|e1, st1):
  Str(_) -> <insertCasts-MatchTerm-Lit(|e1, st1, StringT())>

insertCasts-MatchTerm-Lit(|e1, st1, t1):
  trm -> (trm, <current-type(|t1)> st1)
  with
    t2 := <current-type> st1
  ; if not(<CanCoerce>(t1, t2))
      then rules(Message :+ Err() -> (trm, TypeMismatch(t1, t2)))
    end

insertCasts-MatchTerm(|e1, st1):
  op@Op(cnstr, trm1*) -> (Op(cnstr, trm2*), st2)
  with
    t1 := <current-type> st1
  ; FunType(t1*, t2) := <constr-lookup(|cnstr{})> e1
  ; lvl := <ConstructorStrictness>
  ; if not(<CanCoerce> (t2, t1))
      then rules(Message :+ lvl -> (op, TypeMismatch(t2, t1)))
    end
  ; let
      threader = \((c, t), st) -> <insertCasts-MatchTerm(|e1, <current-type(|t)> st)> c\
      map-targs = if not(Err() := lvl) then map(!Dyn()) else id end
    in
      t2* := <map-targs> t1*
    ; (trm2*, st2) := <thread-map(threader)> (<zip> (trm1*, t2*), st1)
    end

insertCasts-MatchTerm(|e1, st1) =
    \OpQ(c, c*) -> Op(c, c*)\
  ; insertCasts-MatchTerm(|e1, st1)
  ; (\Op(c, c*) -> OpQ(c, c*)\, id)

insertCasts-MatchTerm(|e1, st1):
  Explode(trm1, trm2) -> (Explode(trm3, trm4), st3)
  with
    (trm3, st2) := <insertCasts-MatchTerm(|e1, <current-type(|StringT())> st1)> trm1
  ; (trm4, st3) := <insertCasts-MatchTerm(|e1, <current-type(|Sort("List", [Dyn()]))> st2)> trm2

insertCasts-MatchTerm(|e1, st1):
  Anno(trm1, trm2) -> (Anno(trm3, trm4), st3)
  with
    (trm3, st2) := <insertCasts-MatchTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-MatchTerm(|e1, <current-type(|Sort("List", [Dyn()]))> st2)> trm2

insertCasts-BuildTerm(|e1, st1):
  Var(v) -> (Var(v), <current-type(|t)> st1)
  with
    if not(t := <term-lookup(|v{})> st1)
      then
        rules(Message :+ Err() -> (v, BuildUnboundTerm()))
      ; t := ErrT()
    end

insertCasts-BuildTerm(|e1, st1):
  trm1@As(Var(v), trm2) -> (As(Var(v), trm3), <current-type(|ErrT())> st2)
  with
    (trm3, st2) := <insertCasts-BuildTerm(|e1, st1)> trm2
  ; rules(Message :+ Err() -> (trm1, AsInBuildTerm()))

insertCasts-BuildTerm(|e1, st1):
  trm@Wld() -> (trm, <current-type(|ErrT())> st1)
  with
    rules(Message :+ Err() -> (trm, WldInBuildTerm()))

insertCasts-BuildTerm(|e1, st1):
  trm@Int(_) -> (trm, <current-type(|IntT())> st1)

insertCasts-BuildTerm(|e1, st1):
  trm@Real(_) -> (trm, <current-type(|RealT())> st1)

insertCasts-BuildTerm(|e1, st1):
  trm@Str(_) -> (trm, <current-type(|StringT())> st1)

insertCasts-BuildTerm(|e1, st1):
  Op(cnstr, trm1*) -> (Op(cnstr, trm2*), st3)
  with
    t1 := <current-type> st1
  ; FunType(t1*, t2) := <constr-lookup(|cnstr{})> e1
  ; lvl := <ConstructorStrictness>
  ; let threader = {c', st':
      \((c, et), st) -> (<insertCastApp(|lvl, <current-type> st', et)> c', st')
        with (c', st') := <insertCasts-BuildTerm(|e1, st)> c\}
    in (trm2*, st2) := <thread-map(threader)> (<zip> (trm1*, t1*), st1)
    end
  ; st3 := <current-type(|t2)> st2

insertCasts-BuildTerm(|e1, st1) =
    \OpQ(c, c*) -> Op(c, c*)\
  ; insertCasts-BuildTerm(|e1, st1)
  ; (\Op(c, c*) -> OpQ(c, c*)\, id)

insertCasts-BuildTerm(|e1, st1):
  Explode(trm1, trm2) -> (Explode(trm3, trm4), <current-type(|Dyn())> st3)
  with
    (trm3, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-BuildTerm(|e1, st2)> trm2
  ; if not(<CanCoerce> (<current-type> st2, StringT()))
      then rules(Message :+ Err() -> (trm1, NonStringInExplode(<current-type> st2)))
    end
  ; if not(<CanCoerce> (<current-type> st3, Sort("List", [Dyn()])))
      then rules(Message :+ Err() -> (trm2, NonListInAnno(<current-type> st3)))
    end

insertCasts-BuildTerm(|e1, st1):
  Anno(trm1, trm2) -> (Anno(trm3, trm4), st3)
  with
    (trm3, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-BuildTerm(|e1, st2)> trm2
  ; if not(<CanCoerce> (<current-type> st3, Sort("List", [Dyn()])))
      then rules(Message :+ Err() -> (trm2, NonListInAnno(<current-type> st3)))
    end

strategies // Helpers

getDefTypes =
  with(
      (haveTypes, defNames) := <partition(?DefHasType(<rm-annotations>, _), ?SDefT(<rm-annotations>, _, _, _))>
      // detect duplicates in haveTypes => errors
    ; <foldl(getDefTypes-detect-duplicates)> (haveTypes, <imset-new>)
      // detect missing definitions for haveTypes => errors
    ; imset-subtract(|<imset-from-list> defNames)
    ; imset-map(where({?name; rules(Message :+ Err() -> (name, MissingDefinitionForTypeDefinition()))}))
  )
  ; partition(toBinding-DefHasType, toBinding-SDefT)
  ; (immap-from-list, immap-from-list)
  ; immap-union(?(<id>, _))

internal getDefTypes-detect-duplicates: (name, set) -> <imset-insert(|name)> set
  with if <imset-contains(|name)> set
    then rules(Message :+ Err() -> (name, DuplicateTypeDefinition()))
  end
