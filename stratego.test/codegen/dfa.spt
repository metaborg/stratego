module codegen/dfa
language stratego

test Lists (Cons/Nil) [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)

strategies

length_0_0( | ) =
  match sequential
    case | Nil( ){^_}: !0{^Nil( )}
    case | Cons(_, Nil( ){^_}){^_}: !1{^Nil( )}
    case | Cons(_, _){^_}: id
  end
]] transform "Test -> MultiMatch to DFA" to [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)

strategies

length_0_0( | ) =
  switch current.type {
    alt LIST:
      switch current {
        alt (Nil, 0):
          !0{^Nil( )}
        alt (Cons, 2):
          switch current.tail.type {
            alt LIST:
              switch current.tail {
                alt (Nil, 0):
                  !1{^Nil( )}
                default: id
              }
            default: id
          }
        default: fail
      }
    default: fail
  }
]]

test Tuples (mutually inclusive -> complex default) [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)

strategies

comp_0_0( | ) =
  match sequential
    case | (Nil( ){^_}, _){^_}: !1{^Nil( )}
    case | (_, Nil( ){^_}){^_}: !2{^Nil( )}
  end
]] transform "Test -> MultiMatch to DFA" to [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)

strategies

comp_0_0( | ) =
  switch current.type {
    alt TUPLE:
      switch current.size {
        alt (2):
          switch current.1.type {
            alt LIST:
              switch current.1 {
                alt (Nil, 0):
                  !1{^Nil( )}
                default: switch current.2.type {
                           alt LIST:
                             switch current.2 {
                               alt (Nil, 0):
                                 !2{^Nil( )}
                               default: fail
                             }
                           default: fail
                         }
              }
            default: switch current.2.type {
                       alt LIST:
                         switch current.2 {
                           alt (Nil, 0):
                             !2{^Nil( )}
                           default: fail
                         }
                       default: fail
                     }
          }

        default: fail
      }
    default: fail
  }
]]

test Mixed types [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)
Car1 : a -> List(a)
Car2 : a -> List(a)

strategies

uncar2_0_0( | ) =
  match sequential
    case | Car1(_){^_}: Cons_2_0(!1{^Nil( )}, Nil_0_0( | )| )
    case | Car2(_){^_}: Cons_2_0(!2{^Nil( )}, Nil_0_0( | )| )
    case | "abc"{^_}: !"cba"{^Nil( )}
    case | 8{^_}: !54{^Nil( )}
    case | 5.4{^_}: !8{^Nil( )}
  end
]] transform "Test -> MultiMatch to DFA" to [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)
Car1 : a -> List(a)
Car2 : a -> List(a)

strategies

uncar2_0_0( | ) =
  switch current.type{
    alt APPL:
      switch current.con {
        alt (Car1, 1):
          Cons_2_0(!1{^Nil( )}, Nil_0_0( | )| )
        alt (Car2, 1):
          Cons_2_0(!2{^Nil( )}, Nil_0_0( | )| )
        default: fail
      }
    alt STRING:
      switch current.str {
        alt "abc":
          !"cba"{^Nil( )}
        default: fail
      }
    alt INT:
      switch current.int {
        alt 8:
          !54{^Nil( )}
        default: fail
      }
    alt REAL:
      switch current.real {
        alt 5.4:
          !8{^Nil( )}
        default: fail
      }
    default: fail
  }
]]

test Aliases [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)
C1 : Term( ) * Term( ) -> Term( )
C2 : Term( )

strategies

s_0_1( | x4 : ATerm( )) =
  match sequential
    case | C1(x4@_, _){^_}: !1{^Nil( )}
    case y10 | C1(y10@_, _){^_}: !y10
    case z7 | z7@C2( ){^_}: !3{^Nil( )}
  end
]] transform "Test -> MultiMatch to DFA" to [[
specification

signature
constructors

Nil : List(a)
Cons : a * List(a) -> List(a)
C1 : Term( ) * Term( ) -> Term( )
C2 : Term( )

strategies

s_0_1( | x4 : ATerm( )) =
  {y10, z7: switch current.type {
              alt APPL:
                switch current.con {
                  alt (C1, 2)
                    where !current.1; ?x4:
                      !1{^Nil( )}
                    where !current.1; ?y10:
                      !y10
                  alt (C2, 0)
                    where !current; ?z7:
                      !3{^Nil( )}
                  default:
                    fail
                }
              default:
                fail
            } }
]]
