module analysis/main

imports

libstratego-lib
libstrc

libspoofax/term/annotation
libspoofax/stratego/debug

signatures/strategoGT-sig
signatures/sugar/modules-sig
signatures/gradual-types/signatures-sig
signatures/gradual-types/internal-sig

analysis/utils
analysis/environment
analysis/signatures
analysis/defs

strategies // entry-points from Java

/**
 * insert-casts/0 inserts casts into a Stratego strategy/rule definition based on a gradual type system.
 * strats: map of top-level-definition names to the type description of the strategy
 * constrs: map of constructor definition names to type description
 * injection-closure: map of injections from one type to another (the transitive closure)
 * lub-map: map representing the least-upper-bound of the type lattice
 * ast: the stratego strategy/rule ast
 */
// insert-casts :: Map(String * Int * Int, SType) * Rel(String * Int, ConstrType) * Rel(String, String) * Map(Type * Type, Type) * MessageType * Decl -> (Decl, List(Message))
local-insert-casts: (strats, constrs, injection-closure, lub-map, ast) -> (ast', errs, warns, notes)
  with {| local-CanCoerce, local-LUB, local-Message:
    ast' := <local-insertCasts(|strats, constrs, injection-closure, lub-map)> ast
    ; msg* := <bagof-local-Message>
    ; errs := <filter(?(MTError(), <id>))> msg*
    ; warns := <filter(?(MTWarning(), <id>))> msg*
    ; notes := <filter(?(MTNote(), <id>))> msg*
  |}

// insertCasts :: Map(String * Int * Int, SType) * Rel(String * Int, ConstrType) * Rel(String, String) * Map(Type * Type, Type) * MessageType * Module -> Module
local-insertCasts(|strats, constrs, injection-closure, lub-map): ast -> ast'
  with
    rules(local-CanCoerce: (from, to) -> <id>
      where <local-can-coerce(|injection-closure)> (from, to))
  ; rules(local-LUB: pair -> <local-lub(|lub-map)> pair)
  ; ast' := <local-insertCasts-Def(|<local-new-env> (strats, constrs), <local-new-st>)> ast

local-can-coerce(|injection-closure) = ?(ErrT(), _)
local-can-coerce(|injection-closure) = ?(_, ErrT())
local-can-coerce(|injection-closure) = ?(FailT(), _)
//local-can-coerce(|injection-closure) = ?(_, Dyn())
local-can-coerce(|injection-closure) = ?(_, DynT(_))
// We assume co-variant type parameters
local-can-coerce(|injection-closure): (Sort(x, t1*), Sort(x, t2*)) -> <id>
  where
    <zip(local-CanCoerce)> (t1*, t2*)
local-can-coerce(|injection-closure) = eq
local-can-coerce(|injection-closure): (from, to) -> <imrel-contains(|from, to)> injection-closure

local-lub(|lub-map): (x, x) -> x
local-lub(|lub-map): (ErrT(), x) -> x
local-lub(|lub-map): (x, ErrT()) -> x
local-lub(|lub-map): (FailT(), x) -> x
local-lub(|lub-map): (x, FailT()) -> x
local-lub(|lub-map): (DynT(_), _) -> DynT(Dyn())
local-lub(|lub-map): (_, DynT(_)) -> DynT(Dyn())
local-lub(|lub-map): pair -> <immap-get(|pair) <+ immap-get(|<Swap> pair)> lub-map

local-constr-lookup(|name, arity, t1) =
    local-constr-lookup(|name, arity)
  ; imset-filter(where(\ConstrType(_, t2) -> <local-CanCoerce> (t2, t1)\))
  ; imset-to-list
