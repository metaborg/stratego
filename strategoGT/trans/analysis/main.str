module analysis/main

imports

libstratego-lib
libstrc

libspoofax/term/annotation
libspoofax/stratego/debug

signatures/strategoGT-sig
signatures/sugar/modules-sig

analysis/utils
analysis/environment
analysis/signatures
analysis/defs
immutable/map
immutable/set

strategies // entry-points from Java

/**
 * insert-casts/0 inserts casts into a Stratego strategy/rule definition based on a gradual type system.
 * strats: map of top-level-definition names to the type description of the strategy
 * constrs: map of constructor definition names to type description
 * injection-closure: map of injections from one type to another (the transitive closure)
 * lub-map: map representing the least-upper-bound of the type lattice
 * lvl: the level of strictness of constructors (Err() = strict, Warn() = non-strict, no casts)
 * ast: the stratego strategy/rule ast
 */
// insert-casts :: Map(String * Int * Int, SType) * Map(String * Int, ConstrType) * Set(String, String) * Map(Type * Type, Type) * MessageType * Decl -> (Decl, List(Message))
insert-casts: (strats, constrs, injection-closure, lub-map, lvl, ast) -> (ast', errs, warns, notes)
  with {| CanCoerce, LUB, Message, ConstructorStrictness:
    ast' := <insertCasts(|strats, constrs, injection-closure, lub-map, lvl)> ast
  ; errs := <bagof-Message> Err()
  ; warns := <bagof-Message> Warn()
  ; notes := <bagof-Message> Note()
  |}

// insertCasts :: Map(String, SType) * Map(String, ConstrType) * Set(String, String) * Map(Type * Type, Type) * MessageType * Module -> Module
insertCasts(|strats, constrs, injection-closure, lub-map, lvl): ast -> ast'
  with
    rules(CanCoerce: (from, to) ->
      <imset-contains(|(from, to)) <+ <can-coerce> (from, to)> injection-closure)
  ; rules(LUB: pair -> <if eq then Fst else <immap-get(|pair)> lub-map end> pair)
  ; rules(ConstructorStrictness := lvl)
  ; ast' := <insertCasts-Def(|<new-env> (strats, constrs), <new-st>)> ast

can-coerce = ?(ErrT(), _)
can-coerce = ?(FailT(), _)
can-coerce = ?(_, Dyn())
// We assume co-variant type parameters
can-coerce: (Sort(x, t1*), Sort(x, t2*)) -> <id>
  where
    <zip(CanCoerce)> (t1*, t2*)
can-coerce = eq
