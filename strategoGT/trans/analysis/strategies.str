module analysis/strategies

imports

libstratego-aterm
libstratego-lib

libspoofax/term/annotation
libspoofax/stratego/debug

signatures/strategoGT-sig
signatures/core/strategies-sig
signatures/core/terms-sig
signatures/sugar/modules-sig
signatures/sugar/strategies-sig
signatures/sugar/rules-sig
signatures/gradual-types/signatures-sig
signatures/gradual-types/strategies-sig 
signatures/gradual-types/internal-sig

analysis/utils
analysis/environment 
analysis/signatures
analysis/defs
analysis/terms
analysis/main
analysis/dynamic-rules
analysis/terms

//immutable/-

strategies

strat-lookup-call(register-fresh|x, sn, tn, t) =
  strat-lookup(|x, sn, tn, t);fresh-type-vars(register-fresh)

strat-lookup-call(|x) =
    strat-env
  ; immap-filter-keys(?(x, _, _))
  ; immap-values

strategies // Strategy (core)

insertCasts-Strategy(|e1, st1) = otf12(insertCasts-Strategy-(|e1, st1))

// insertCasts-Strategy-(|Environment, Store) :: Strategy -> (Strategy, Store)
insertCasts-Strategy-(|e1, st1):
  Let(d1*, s1) -> (Let(d2*, s2), st3)
  with
    e2 := <strat-merge-env(keep-right)> (e1, <getDefTypes;immap-map-values(\st -> st{LocalDef()}\)> d1*)
  ; (d2*, st2) := <thread-map(insertCasts-Def(|e2))> (d1*, st1)
  ; (s2, st3) := <insertCasts-Strategy(|e2, <current-type-of(| st1)> st2)> s1

insertCasts-Strategy(|e1, st1):
  c1@CallT(SVar(x), s*, t*) -> result
  with
    if t1 := <strat-lookup-call(?freshvars|x{}, <length> s*, <length> t*, <current-type> st1)> e1
      then
        (c2, st2) := <insertCasts-CallT(|e1, st1)> (c1, t1)
      ; result := (c2, <type-var-clear(|freshvars)> st2)
      else
        <report-Err> (x, UnresolvedStrategy(<length> s*, <length> t*))
      ; (c2, st2) := <insertCasts-CallT(|e1, st1)> (c1, SErrT())
      ; result := (c2, <current-type(|ErrT())> st2)
    end

insertCasts-CallT(|e1, st1) = otf22(insertCasts-CallT-(|e1, st1))

insertCasts-CallT(|e1, st1): 
  (c1@CallT(v, s1*, t1*), FunTType(st*, tt*, t1, t2)) -> (c2, st6)
  with
    s2* := <zip> (s1*, st*)
  ; t2* := <zip> (t1*, tt*)
  ; t3 := <current-type> st1
  ; (s3*, st3) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
  ; (t3*, st4) := <thread-map(insertCasts-Targ(|e1))> (t2*, st3)
  ; (c2, st5) := <insertCastBefore(|t3, t1)> (<otf(!CallT(v, s3*, t3*))> c1, st4)
  ; st6 := <current-type(|<instantiate-type-vars(|st4)> t2)> st5

insertCasts-CallT(|e1, st1): 
  (c1@CallT(v, s1*, t1*), FunTType(st*, tt*, TP())) -> (c2, st5)
  with
    s2* := <zip> (s1*, st*)
  ; t2* := <zip> (t1*, tt*)
  ; t3 := <current-type> st1
  ; if <oncetd(?DynT())> t3
      then <report-Err> (c1, MatchNotSpecificEnoughForTP(t3))
    end
  ; (s3*, st3) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
  ; (t3*, st4) := <thread-map(insertCasts-Targ(|e1))> (t2*, st3)
  ; c2 := <otf(!CallT(v, s3*, t3*))> c1
  ; st5 := <current-type-of(| st1)> st4

insertCasts-CallT-(|e1, st1):
  (c1@CallT(v, s1*, t1*), SDyn()) -> (CallT(v, s3*, t3*), st4)
  with
    s2* := <map-pair-right(|SDyn())> s1*
  ; t2* := <map-pair-right(|DynT())> t1*
  ; t3 := <current-type> st1
  ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
  ; (t3*, st3) := <thread-map(insertCasts-Targ(|e1))> (t2*, st2)
  ; st4 := <current-type(|DynT())> st3

insertCasts-CallT-(|e1, st1):
  (c1@CallT(v, s1*, t1*), SErrT()) -> (CallT(v, s3*, t3*), st4)
  with
    s2* := <map-pair-right(|SErrT())> s1*
  ; t2* := <map-pair-right(|ErrT())> t1*
  ; t3 := <current-type> st1
  ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
  ; (t3*, st3) := <thread-map(insertCasts-Targ(|e1))> (t2*, st2)
  ; st4 := <current-type(|ErrT())> st3

insertCasts-Strategy-(|e1, st1):
  c1@CallDynamic(trm1, s1*, t1*) -> (CallDynamic(trm3, s3*, t3*), st6)
  with
    (trm2, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; t1 := <current-type> st2
  ; (trm3, st3) := <insertCastApp(|t1, StringT())> (trm2, st2)
  ; s2* := <map-pair-right(|SErrT())> s1*
  ; t2* := <map-pair-right(|ErrT())> t1*
  ; (s3*, st4) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st3)
  ; (t3*, st5) := <thread-map(insertCasts-Targ(|e1))> (t2*, st4)
  ; st6 := <current-type(|ErrT())> st5
  ; <report-Err> (c1, CallDynamicNotSupported())

insertCasts-Strategy(|e1, st1):
  s@Fail() -> (s, <current-type(|ErrT())> st1)

insertCasts-Strategy(|e1, st1):
  s@Id() -> (s, st1)

insertCasts-Strategy-(|e1, st1):
  p@ProceedT(s1*, t1*) -> ('call, st6)
  with
    if FunTType(st*, tt*, t1, t2) := <strat-lookup-call(?freshvars|ProceedNoArgs(), <length> s1*, <length> t1*, <current-type> st1)> e1
    then
      s2* := <zip> (s1*, st*)
    ; t2* := <zip> (t1*, tt*)
    ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
    ; (t3*, st3) := <thread-map(insertCasts-Targ(|e1))> (t2*, st2)
    ; st4 := <current-type(|t2)> st3
    ; ('call, st5) := <insertCastBefore(|<current-type> st1, t1)> (<otf(!ProceedT(s3*, t3*))> p, st4)
    ; st6 := <type-var-clear(|freshvars)> st5
    else
      <report-Err> (p, ProceedInNonExtendStrategy())
    ; s2* := <map-pair-right(|SErrT())> s1*
    ; t2* := <map-pair-right(|ErrT())> t1*
    ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
    ; (t3*, st3) := <thread-map(insertCasts-Targ(|e1))> (t2*, st2)
    ; 'call := ProceedT(s3*, t3*)
    ; st6 := <current-type(|ErrT())> st3
    end

insertCasts-Strategy-(|e1, st1):
  p@ProceedNoArgs() -> ('call, st4)
  with
    if FunTType(st*, tt*, t1, t2) := <strat-lookup-call(?freshvars|ProceedNoArgs(), 0, 0, <current-type> st1)> e1
    then
      if not([] := st*; [] := tt*)
        then <report-Err> (p, ProceedWrongNumberOfArguments(<length> st*, <length> tt*))
      end
    ; st2 := <current-type(|t2)> st1
    ; ('call, st3) := <insertCastBefore(|<current-type> st1, t1)> (p, st2)
    ; st4 := <type-var-clear(|freshvars)> st3
    else
      <report-Err> (p, ProceedInNonExtendStrategy())
    ; st4 := <current-type(|ErrT())> st1
    ; 'call := p
    end

insertCasts-Strategy-(|e1, st1):
  Match(trm1) -> (<seqs> [Match(trm2) | s2*], st2)
  with
    (trm2, (st2, s*)) := <insertCasts-MatchTerm(|e1, st1)> trm1
  ; s2* := <?[] <+ ![Where(<seqs> s*)]> s*

insertCasts-Strategy-(|e1, st1):
  Build(trm1) -> (Build(trm2), st2)
  with
    (trm2, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1

insertCasts-Strategy-(|e1, st1):
  Scope(x*, s1) -> (Scope(x*, s2), st4)
  with
    // TODO: support type annotations on local variables
    new := <map-pair-right(|DynT()); immap-from-list> x*
  ; orig := <term-env;immap-intersect(keep-left|new)> st1
  ; st2 := <term-merge-env(keep-right)> (st1, new)
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1
  ; st4 := <term-env(immap-subtract(|new);immap-union(fail|orig))> st3

insertCasts-Strategy-(|e1, st1):
  Seq(s1, s2) -> (Seq(s3, s4), st3)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, st2)> s2

insertCasts-Strategy-(|e1, st1):
  GuardedLChoice(s1, s2, s3) -> (GuardedLChoice(s4, s5, s6), st5)
  with
    (s4, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s5, st3) := <insertCasts-Strategy(|e1, st2)> s2
  ; (s6, st4) := <insertCasts-Strategy(|e1, st1)> s3
  ; st5 := <st-merge(LUB <+ !DynT())> (st3, st4)

insertCasts-Strategy-(|e1, st1):
  PrimT(x, s1*, t1*) -> (PrimT(x, s2*, t2*), st4)
  with
    (s2*, st2) := <thread-map(insertCasts-Sarg-Type(|e1, SDyn()))> (s1*, st1)
  ; (t2*, st3) := <thread-map(insertCasts-Targ(|e1))> (<map-pair-right(|DynT())> t1*, st2)
  ; st4 := <current-type(|DynT())> st3

insertCasts-Strategy-(|e1, st1):
  Some(s1) -> (Some(s2), <current-type-of(| st1)> st2)
  where
    not(<current-type;oncetd(?DynT())> st1)
  ; (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType([], [], TP()))

insertCasts-Strategy-(|e1, st1):
  Some(s1) -> (Some(s2), <current-type(|DynT())> st2)
  with
    (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType())

insertCasts-Strategy-(|e1, st1):
  One(s1) -> (One(s2), <current-type-of(| st1)> st2)
  where
    not(<current-type;oncetd(?DynT())> st1)
  ; (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType([], [], TP()))

insertCasts-Strategy-(|e1, st1):
  One(s1) -> (One(s2), <current-type(|DynT())> st2)
  with
    (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType())

insertCasts-Strategy-(|e1, st1):
  All(s1) -> (All(s2), <current-type-of(| st1)> st2)
  where
    not(<current-type;oncetd(?DynT())> st1)
  ; (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType([], [], TP()))

insertCasts-Strategy-(|e1, st1):
  All(s1) -> (All(s2), <current-type(|DynT())> st2)
  with
    (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType())

insertCasts-Strategy(|e1, st1):
  s@ImportTerm(_) -> (s, <current-type(|DynT())> st1)

insertCasts-Sarg(|e1):
  (b, st1) -> <insertCasts-Sarg(|e1, st1)> b

insertCasts-Sarg-Type(|e1, t):
  (trm, st1) -> <insertCasts-Sarg(|e1, st1)> (trm, t)

insertCasts-Sarg(|e1, st1):
  (c@CallT(v@SVar(x), [], []), t1@FunTType(st*, tt*, _)) -> (s, st3)
  with
    if t2 := <strat-lookup-call(?freshvars|x{}, 0, 0, <current-type> st1)> e1
      then
        (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, t2)
      ; st3 := <type-var-clear(|freshvars)> st2
      else
        <report-Err> (x, UnresolvedStrategy(0, 0))
      ; (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, SErrT())
      ; st3 := <current-type(|ErrT())> st2
    end

insertCasts-Sarg(|e1, st1):
  (c@Call(v@SVar(x), []), t1@FunTType(st*, tt*, _)) -> (s, st3)
  with
    if t2 := <strat-lookup-call(?freshvars|x{}, 0, 0, <current-type> st1)> e1
      then
        (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, t2)
      ; st3 := <type-var-clear(|freshvars)> st2
      else
        <report-Err> (x, UnresolvedStrategy(0, 0))
      ; (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, SErrT())
      ; st3 := <current-type(|ErrT())> st2
    end

insertCasts-Sarg(|e1, st1):
  (c@CallNoArgs(v@SVar(x)), t1@FunTType(st*, tt*, _)) -> (s, st3)
  with
    if t2 := <strat-lookup-call(?freshvars|x{}, 0, 0, <current-type> st1)> e1
      then
        (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, t2)
      ; st3 := <type-var-clear(|freshvars)> st2
      else
        <report-Err> (x, UnresolvedStrategy(0, 0))
      ; (s, st2) := <insertCasts-Sarg-CallNoArgs(|st1)> (v, t1, SErrT())
      ; st3 := <current-type(|ErrT())> st2
    end

insertCasts-Sarg(|e1, st1):
  (s1, t1@FunTType(st*, tt*, t2, t3)) -> (s2, st4)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|<instantiate-type-vars(|st1)> t2)> st1)> s1
  ; if not([] := st*; [] := tt*)
      then <report-Err> (s1, CallStrategyArgumentTakesParameters(t1))
    end
  ; t4 := <current-type> st2
  ; (c, st4) := <computeCoercion(|s1, st2)> (t4, t3)
  ; s3 := <rm-redundant-proxy> Proxy(Id(), c, s2)

insertCasts-Sarg(|e1, st1):
  (s1, t1@FunTType(st*, tt*, TP())) -> (s2, st2)
  with
    tv := <newname> "tp"
  ; t2 := Sort(TP(), []){tv}
  ; (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|t2)> st1)> s1
  ; if not([] := st*; [] := tt*)
      then <report-Err> (s1, CallStrategyArgumentTakesParameters(t1))
    end
  ; t4 := <current-type> st2
  ; if <eq> (t2, t4)
      <+ <eq> (t4, <type-var-lookup(|tv)> st2)
         ; <not(oncetd(?DynT()))> t4
      <+ <?ErrT()> t4
      then id
      else <report-Err> (s1, MatchNotSpecificEnoughForTP(t4{t2}))
    end

insertCasts-Sarg(|e1, st1):
  (c@CallT(v@SVar(x), [], []), SDyn()) -> (c, st2)
  with
    switch <strat-lookup-call(|x{})> e1
      case ?[]:
        <report-Err> (x, UnresolvedStrategy("0", "0"))
      ; st2 := <current-type(|ErrT())> st1
      case ?st*@[_, _ | _]; not(getfirst(?FunTType([], [], _) <+ ?SDyn(){LocalDef()})):
        <report-Err> (x, AmbiguousStrategyResolution(st*))
      ; st2 := <current-type(|ErrT())> st1
      otherwise:
        st2 := st1
    end

insertCasts-Sarg(|e1, st1):
  (c@Call(v@SVar(x), []), SDyn()) -> (c, st2)
  with
    switch <strat-lookup-call(|x{})> e1
      case ?[]:
        <report-Err> (x, UnresolvedStrategy("0", "0"))
      ; st2 := <current-type(|ErrT())> st1
      case ?st*@[_, _ | _]; not(getfirst(?FunTType([], [], _) <+ ?SDyn(){LocalDef()})):
        <report-Err> (x, AmbiguousStrategyResolution(st*))
      ; st2 := <current-type(|ErrT())> st1
      otherwise:
        st2 := st1
    end

insertCasts-Sarg(|e1, st1):
  (c@CallNoArgs(v@SVar(x)), SDyn()) -> (c, st2)
  with
    switch <strat-lookup-call(|x{})> e1
      case ?[]:
        <report-Err> (x, UnresolvedStrategy("0", "0"))
      ; st2 := <current-type(|ErrT())> st1
      case ?st*@[_, _ | _]; not(getfirst(?FunTType([], [], _) <+ ?SDyn(){LocalDef()})):
        <report-Err> (x, AmbiguousStrategyResolution(st*))
      ; st2 := <current-type(|ErrT())> st1
      otherwise:
        st2 := st1
    end

insertCasts-Sarg(|e1, st1):
  (s1, SDyn()) -> (s2, st2)
  with (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|DynT())> st1)> s1

insertCasts-Sarg(|e1, st1):
  (s1, SErrT()) -> (s2, st2)
  with (s2, st2) := <insertCasts-Strategy(|e1, <current-type(|ErrT())> st1)> s1

insertCasts-Sarg-CallNoArgs(|st1) = otf32(insertCasts-Sarg-CallNoArgs-(|st1))

/**
 * t1 is the expected type of the sarg, t4 is the actual type. Build a proxy that turns the input
 *  types from t1 (as it will be used) into the t4 types, output type the other way around.
 */
insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t1@FunTType(st1*, tt1*, t2, t3), t4@FunTType(st2*, tt2*, t5, t6)) ->
    (<rm-redundant-proxy> ProxyT(sc*, tc*, c1, c2, v), st5)
  with
    if not(<eq> (<length> st1*, <length> st2*); <eq> (<length> tt1*, <length> tt2*))
      then <report-Err> (v, TypeMismatch(t1, t4))
    end
  ; (sc*, st2) := <thread-map(computeSCoercion(|v))> (<zip> (st1*, st2*), st1)
  ; (tc*, st3) := <thread-map(\(tp, st) -> <computeCoercion(|v, st)> tp\)> (<zip> (tt1*, tt2*), st2)
  ; (c1, st4) := <computeCoercion(|v, st3)> (t2, t5)
  ; (c2, st5) := <computeCoercion(|v, st4)> (t6, t3)

insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t1@FunTType(st1*, tt1*, TP()), t4@FunTType(st2*, tt2*, TP())) ->
    (<rm-redundant-proxy> ProxyT(sc*, tc*, Id(), Id(), v), st3)
  with
    if not(<eq> (<length> st1*, <length> st2*); <eq> (<length> tt1*, <length> tt2*))
      then <report-Err> (v, TypeMismatch(t1, t4))
    end
  ; (sc*, st2) := <thread-map(computeSCoercion(|v))> (<zip> (st1*, st2*), st1)
  ; (tc*, st3) := <thread-map(\(tp, st) -> <computeCoercion(|v, st)> tp\)> (<zip> (tt1*, tt2*), st2)

insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t1@FunTType(st1*, tt1*, TP()), _) ->
    (v, st1)
  with
    <report-Err> (v, MatchNotSpecificEnoughForTP(t1))

insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t1@FunTType(st1*, tt1*, t5, t6), t4@FunTType(st2*, tt2*, TP())) ->
    (<rm-redundant-proxy> ProxyT(sc*, tc*, RuntimeCheck(t5), Id(), v), st3)
  with
    if not(<eq> (<length> st1*, <length> st2*); <eq> (<length> tt1*, <length> tt2*))
      then <report-Err> (v, TypeMismatch(t1, t4))
    end
  ; if not(<eq> (t5, t6)) <+ <oncetd(?DynT())> (t5, t6)
      then <report-Err> (v, MatchNotSpecificEnoughForTP(t6{t5}))
    end
  ; (sc*, st2) := <thread-map(computeSCoercion(|v))> (<zip> (st1*, st2*), st1)
  ; (tc*, st3) := <thread-map(\(tp, st) -> <computeCoercion(|v, st)> tp\)> (<zip> (tt1*, tt2*), st2)

insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t0@FunTType(st*, tt*, t1, t2), SDyn()) ->
    (<rm-redundant-proxy> ProxyT(sc*, tc*, Id(), c, v), st3)
  with
//    st2 := <discover-stype-vars> ((t0, SDyn()), st1)
    sc* := <map(!SId())> st*
  ; tc* := <map(!Id())> tt*
  ; (c, st3) := <computeCoercion(|v, st1)> (DynT(), t2)

insertCasts-Sarg-CallNoArgs-(|st1):
  (v, t0@FunTType(st*, tt*, t1, t2), SErrT()) ->
    (v, st1)

rm-redundant-proxy =
     ?Proxy(Id(){^_}, Id(){^_}, <!CallNoArgs(<id>)>)
  <+ ProxyT(map(?SId(){^_}), map(?Id(){^_}), ?Id(){^_}, ?Id(){^_}, ?v);!CallNoArgs(v)
  <+ id

insertCasts-Targ(|e1):
  ((trm1, t1), st1) -> <insertCasts-BuildTerm(|e1, st1, t1)> trm1

strategies // Strategy (sugar)

insertCasts-Strategy(|e1, st1) =
  otf(\Call(svar, s*) -> CallT(svar, s*, [])\)
; insertCasts-Strategy(|e1, st1)

insertCasts-Strategy-(|e1, st1):
  ScopeDefault(s1) -> (ScopeDefault(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, <new-st;current-type(|<current-type> st1)>)> s1
    // Note how we only preserve the current type of st2 here 
  ; st3 := <current-type-of(| st2)> st1

insertCasts-Strategy-(|e1, st1):
  BA(s1, trm1) -> (BA(s2, trm2), st3)
  with
    (trm2, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1

insertCasts-Strategy-(|e1, st1):
  LChoice(s1, s2) -> (LChoice(s3, s4), st4)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, st1)> s2
  ; st4 := <st-merge(LUB <+ !DynT())> (st2, st3)

insertCasts-Strategy-(|e1, st1):
  Rec(x, s1) -> (Rec(x, s2), st2)
  with
    e2 := <strat-merge-env(keep-right)> (e1, <immap-from-list> [(x{}, FunTType())])
  ; (s2, st2) := <insertCasts-Strategy(|e2, st1)> s1

insertCasts-Strategy-(|e1, st1):
  Not(s1) -> (Not(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <current-type-of(| st1)> st2

insertCasts-Strategy-(|e1, st1):
  Where(s1) -> (Where(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <current-type(|st1)> st2

insertCasts-Strategy-(|e1, st1):
  With(s1) -> (With(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <current-type(|st1)> st2

insertCasts-Strategy-(|e1, st1):
  Test(s1) -> (Test(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <current-type(|st1)> st2

insertCasts-Strategy-(|e1, st1):
  Test(s1) -> (Test(s2), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <current-type(|st1)> st2

insertCasts-Strategy(|e1, st1):
  s@PrimNoArgs(_) -> (s, <current-type(|DynT())> st1)

insertCasts-Strategy-(|e1, st1):
  Prim(x, t1*) -> (Prim(x, t2*), st3)
  with
    (t2*, st2) := <thread-map(insertCasts-Targ(|e1))> (<map-pair-right(|DynT())> t1*, st1)
  ; st3 := <current-type(|DynT())> st2


litCongruence(|st1, t1) = otf12(litCongruence-(|st1, t1))

// Note how we don't add a cast here. Literal congruences are allow to fail based on wrong type, we
//  don't want them to crash instead.
litCongruence-(|st1, t1):
  s -> (s, st2)
  with
    t2 := <current-type> st1
  // Give a warning when it's guaranteed to fail based on type.
  ; _ := <computeCoercion(|s, st1)> (t2, t1)
  ; st2 := <current-type(|t1)> st1

insertCasts-Strategy(|e1, st1):
  s@StrCong(_) -> <litCongruence(|st1, StringT())> s

insertCasts-Strategy(|e1, st1):
  s@IntCong(_) -> <litCongruence(|st1, IntT())> s

insertCasts-Strategy(|e1, st1):
  s@RealCong(_) -> <litCongruence(|st1, RealT())> s

insertCasts-Strategy(|e1, st1):
  s@CharCong(_) -> <litCongruence(|st1, IntT())> s

insertCasts-Strategy-(|e1, st1):
  s1@CongQ(x, s1*) -> (s2, st5)
  with
    t1 := <current-type> st1
  ; t* := <constr-lookup-to(|x, <length> s1*, t1, st1)> e1
  ; if [(ConstrType(t1*, t2), st2)] := t*
    then
      if DynT() := t1
        then t2* := <map(!DynT())> t1*
        else t2* := t1*
      end
    ; (s2*, st3) := <thread-map(insertCasts-Sarg(|e1))> (<zip> (s1*, t2*), st2)
    // We cannot assume correct output as congruences can be extended arbitrarily by users
    ; st4 := <current-type(|DynT())> st3
    ; (s2, st5) := <insertCastBefore(|t1, t2)> (<otf(!CongQ(x, s2*))> s1, st4)
    else if [] := t*
        then <report-Err> (x, UnresolvedConstructor(<length> s1*, t1))
           ; (s2*, st2) := <thread-map(insertCasts-Sarg-Type(|e1, ErrT()))> (s1*, st1)
           ; st5 := <current-type(|ErrT())> st1
        else <report-Warn> (x, AmbiguousConstructorUse(<map(?ConstrType(_, <id>))> t*))
           ; (s2*, st2) := <thread-map(insertCasts-Sarg-Type(|e1, DynT()))> (s1*, st1)
           ; st5 := <current-type(|DynT())> st1
      end
    ; s2 := CongQ(x, s1*)
    end

insertCasts-Strategy(|e1, st1):
  s@EmptyTupleCong() -> <litCongruence(|st1, TupleT([]))> s

insertCasts-Strategy-(|e1, st1):
  TupleCong(s1, s1*) -> (TupleCong(s2, s2*), st4)
  with
    t1 := <current-type> st1
  ; t1* := <tupleTypes(|<length;inc> s1*)> t1
  ; (s2, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType(<Hd> t1*, DynT()))
  ; (s2*, st3) := <thread-map(insertCasts-Sarg(|e1))> (<zip> (s1*, <Tl;map(!FunTType(<id>, DynT()))> t1*), st2)
  ; t2* := <map(!DynT())> t1* // TODO: extract types from insertCasts-Sarg?
  ; st4 := <current-type(|TupleT(t1*))> st3

insertCasts-Strategy-(|e1, st1):
  s1@ListCongNoTail(s1*) -> (ListCongNoTail(s2*), st4)
  with
    t1 := <current-type> st1
  ; t2 := <listType> t1
  ; if t3@ListT(_) := <pushDyn> t1
      then st2 := st1
      else t3 := ListT()
      // Give a warning when it's guaranteed to fail based on type.
      ; (_, st2) := <computeCoercion(|s1, st1)> (t1, ListT())
    end
  ; (s2*, st3) := <thread-map(insertCasts-Sarg-Type(|e1, FunTType(t2)))> (s1*, st1)
  ; st4 := <current-type(|t3)> st3

insertCasts-Strategy-(|e1, st1):
  s1@ListCong(s1*, s2) -> (ListCong(s2*, s3), st5)
  with
    t1 := <current-type> st1
  ; t2 := <listType> t1
  ; if t3@ListT(_) := <pushDyn> t1
      then st2 := st1
      else t3 := ListT()
      // Give a warning when it's guaranteed to fail based on type.
      ; (_, st2) := <computeCoercion(|s1, st1)> (t1, ListT())
    end
  ; (s2*, st3) := <thread-map(insertCasts-Sarg-Type(|e1, FunTType(t2)))> (s1*, st2)
  ; (s3, st4) := <insertCasts-Sarg(|e1, st3)> (s2, FunTType(t3))
  ; st5 := <current-type(|t3)> st4

insertCasts-Strategy-(|e1, st1):
  ExplodeCong(s1, s2) -> (ExplodeCong(s3, s4), st4)
  with
    // Note that constructors can be strings (in case of applications and tuples) or the empty list (in case of a list)
    (s3, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType())
  ; (s4, st3) := <insertCasts-Sarg(|e1, st2)> (s2, FunTType(DynT(ListT())))
  ; st4 := <current-type(|DynT())> st3

insertCasts-Strategy(|e1, st1):
  s@AM(s1, trm1) -> (<seqs> [<otf(!AM(s2, trm2))> s | s*], st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (trm2, (st3, s*)) := <insertCasts-MatchTerm(|e1, st2)> trm1

insertCasts-Strategy(|e1, st1):
  s@Assign(trm1, trm2) -> (<seqs> [<otf(!Assign(trm3, trm4))> s | s*], st3)
  with
    (trm4, st2) := <insertCasts-BuildTerm(|e1, st1)> trm2
  ; (trm3, (st3, s*)) := <insertCasts-MatchTerm(|e1, st2)> trm1

insertCasts-Strategy-(|e1, st1):
  AnnoCong(s1, s2) -> (AnnoCong(s3, s4), st4)
  with
    (s3, st2) := <insertCasts-Sarg(|e1, st1)> (s1, FunTType())
  ; (s4, st3) := <insertCasts-Sarg(|e1, st2)> (s2, FunTType(DynT(ListT())))
  ; st4 := <current-type(|DynT())> st3


insertCasts-Strategy(|e1, st1) =
    otf(\CallNoArgs(svar) -> CallT(svar, [], [])\)
  ; insertCasts-Strategy(|e1, st1)

insertCasts-Rule(|e1, st1) = otf12(insertCasts-Rule-(|e1, st1))

insertCasts-Rule-(|e1, st1):
  Rule(trm1, trm2, cs1) -> (Rule(trm3, trm4, cs3), st4)
  with
    (trm3, (st2, s*)) := <insertCasts-MatchTerm(|e1, st1)> trm1
  ; (cs2, st3)  := <thread-map(insertCasts-RuleCond(|e1))> (cs1, st2)
  ; cs3 := <RuleDef-after-match> (s*, cs2)
  ; (trm4, st4) := <insertCasts-BuildTerm(|e1, st3)> trm2

insertCasts-Strategy-(|e1, st1):
  LRule(r1@Rule(trm, _, _)) -> (LRule(r2), st4)
  with
    new := <collect-all(?Var(<id>));map-pair-right(|DynT());immap-from-list> trm
  ; orig := <term-env;immap-intersect(keep-left|new)> st1
  ; st2 := <term-merge-env(keep-right)> (st1, new)
  ; (r2, st3) := <insertCasts-Rule(|e1, st2)> r1
  ; st4 := <term-env(immap-subtract(|new);immap-union(fail|orig))> st3

insertCasts-Strategy-(|e1, st1):
  SRule(r1) -> (SRule(r2), st2)
  with
    (r2, st2) := <insertCasts-Rule(|e1, st1)> r1

insertCasts-Strategy-(|e1, st1):
  Choice(s1, s2) -> (Choice(s3, s4), st4)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, st1)> s2
  ; st4 := <st-merge(LUB <+ !DynT())> (st2, st3)

insertCasts-Strategy-(|e1, st1):
  RChoice(s1, s2) -> (RChoice(s3, s4), st4)
  with
    (s4, st2) := <insertCasts-Strategy(|e1, st1)> s2
  ; (s3, st3) := <insertCasts-Strategy(|e1, st1)> s1
  ; st4 := <st-merge(LUB <+ !DynT())> (st2, st3)

insertCasts-Strategy-(|e1, st1):
  p@Proceed(s1*) -> ('call, st4)
  with
    if FunTType(st*, tt*, t1, t2) := <strat-lookup-call(?freshvars|ProceedNoArgs(), <length> s1*, 0, <current-type> st1)> e1
    then
      if 0 := <length> tt*; <eq> (<length> s1*, <length> st*)
      then
        s2* := <zip> (s1*, st*)
      ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
      ; st3 := <current-type(|t2)> st2
      ; ('call, st4) := <insertCastBefore(|<current-type> st1, t1)> (<otf(!Proceed(s3*))> p, st3)
      else
        <report-Err> (p, ProceedWrongNumberOfArguments(<length> st*, "0"))
      ; s2* := <map-pair-right(|SErrT())> s1*
      ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
      ; st4 := <current-type(|ErrT())> st2
      ; 'call := Proceed(s3*)
      end
    else
        <report-Err> (p, ProceedInNonExtendStrategy())
      ; s2* := <map-pair-right(|SErrT())> s1*
      ; (s3*, st2) := <thread-map(insertCasts-Sarg(|e1))> (s2*, st1)
      ; st4 := <current-type(|ErrT())> st2
      ; 'call := Proceed(s3*)
    end

insertCasts-Strategy-(|e1, st1):
  CondChoice(s1, s2, s3) -> (CondChoice(s4, s5, s6), st5)
  with
    (s4, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s5, st3) := <insertCasts-Strategy(|e1, <current-type-of(| st1)> st2)> s2
  ; (s6, st4) := <insertCasts-Strategy(|e1, st1)> s3
  ; st5 := <st-merge(LUB <+ !DynT())> (st3, st4)

insertCasts-Strategy-(|e1, st1):
  IfThen(s1, s2) -> (IfThen(s3, s4), st3)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, <current-type-of(| st1)> st2)> s2

insertCasts-Strategy-(|e1, st1):
  SwitchChoiceNoOtherwise(s1, sc1*) -> (SwitchChoiceNoOtherwise(s2, sc2*), st3)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; t1 := <current-type> st1
  ; t2 := <current-type> st2
  ; (sc2*, _, st3) := <map-LUB(insertCasts-SwitchCase(|e1, t1, t2))> (sc1*, st2)

insertCasts-Strategy-(|e1, st1):
  SwitchChoice(s1, sc1*, s2) -> (SwitchChoice(s3, sc2*, s4), st4)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; t1 := <current-type> st1
  ; t2 := <current-type> st2
  ; (sc2*, _, st3) := <map-LUB(insertCasts-SwitchCase(|e1, t1, t2))> (sc1*, st2)
  ; (s4, st4) := <insertCasts-Strategy(|e1, <current-type(|t1)> st3)> s2

insertCasts-SwitchCase(|e1, t1, t2) = otf22(insertCasts-SwitchCase-(|e1, t1, t2))

insertCasts-SwitchCase-(|e1, t1, t2):
  (SwitchCase(s1, s2), st1) -> (SwitchCase(s3, s4), st3)
  with
    (s3, st2) := <insertCasts-Strategy(|e1, <current-type(|t2)> st1)> s1
  ; (s4, st3) := <insertCasts-Strategy(|e1, <current-type(|t1)> st2)> s2

strategies // The Cast & Proxy extension

insertCasts-Strategy(|e1, st1):
  s@Cast(Fail()) -> (s, st2)
  with
    st2 := <current-type(|ErrT())> st1

insertCasts-Strategy(|e1, st1):
  s@Cast(Id()) -> (s, st1)

insertCasts-Strategy(|e1, st1):
  s@Cast(RuntimeCheck(t)) -> (s, st2)
  with
    st2 := <current-type(|<desugar-Type> t)> st1

insertCasts-Strategy(|e1, st1):
  s@TypeTest(t) -> (s, st3)
  with
    t1 := <current-type> st1
  ; t2 := <desugar-Type> t
  ; t3 := <TP2tv> t1
  ; if Sort(TP(), []) := t1; <oncetd(?DynT())> t2
      then <report-Err> (t, MatchNotSpecificEnoughForTP(t2))
    end
  ; if r := <CanCoerce> ((t2, t3), st1)
      then st2 := <Snd> r
      else <report-Err> (s, NoInjectionBetween(t2,t3))
         ; st2 := st1
    end
  ; st3 := <current-type(|t2)> st2

insertCasts-Strategy(|e1, st1):
  Proxy(c1, c2, s1) -> (Proxy(c1, c2, s2), st2)
  with
    (_, st2) := <insertCasts-Strategy(|e1, st1)> Cast(c1)
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1
  ; (_, st4) := <insertCasts-Strategy(|e1, st3)> Cast(c2)

insertCasts-Strategy(|e1, st1):
  s1@ProxyT(sc1*, tc1*, c1, c2, SVar(x)) -> (s1, st1)
  with
    t1 := <strat-lookup-call(?freshvars|x{}, 0, 0, <current-type> st1)> e1
    // TODO: check that t1 corresponds to the coercions in the ProxyT
