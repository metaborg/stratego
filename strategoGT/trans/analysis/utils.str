module analysis/utils

imports

signatures/gradual-types/modules-sig
signatures/gradual-types/signatures-sig
signatures/sugar/signatures-sig
analysis/signatures

analysis/main
analysis/environment
immutable/map
immutable/set

libspoofax/stratego/debug

strategies

// origin-track-forced
otf(s) = ![<id>]; all(s); ?[<id>]

strategies

desugar-SType = otf(\FunNoArgsType(i, o) -> FunTType([], [], <desugar-Type> i, <desugar-Type> o)\)
desugar-SType = otf(\FunType(targs, i, o) -> FunTType([], <map(desugar-Type)> targs, <desugar-Type> i, <desugar-Type> o)\)
desugar-SType = otf(FunTType(map(desugar-SType), map(desugar-Type), desugar-Type, desugar-Type))

desugar-Type = otf(\SortVar("str") -> StringT()\)
desugar-Type = otf(\SortVar("int") -> IntT()\)
desugar-Type = otf(\SortVar("real") -> RealT()\)
desugar-Type = otf(\SortNoArgs(x) -> Sort(x, [])\)
desugar-Type = otf(\SortList(xs) -> <foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs\)
desugar-Type = otf(\SortListTl(xs, y) -> <foldr(!y, !Sort("Cons",[<Fst>,<Snd>]))> xs\)
desugar-Type = otf(\SortTuple(xs) -> TupleT(<map(desugar-Type)> xs)\)
desugar-Type = id

arityOf-SType: FunTType(st*, tt*, _, _) -> (<length> st*, <length> tt*)

strategies

name-of-StrategyDef-RuleDef: SDefT(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
name-of-StrategyDef-RuleDef: SDef(name, s*, _) -> (name{}, <length> s*, 0)
name-of-StrategyDef-RuleDef: SDefNoArgs(name, _) -> (name{}, 0, 0)
name-of-StrategyDef-RuleDef: ExtSDefInl(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
name-of-StrategyDef-RuleDef: ExtSDef(name, s*, t*) -> (name{}, <length> s*, <length> t*)

name-of-StrategyDef-RuleDef: RDefT(name, s*, t*, _) -> (name{}, <length> s*, <length> t*)
name-of-StrategyDef-RuleDef: RDef(name, s*, _) -> (name{}, <length> s*, 0)
name-of-StrategyDef-RuleDef: RDefNoArgs(name, _) -> (name{}, 0, 0)

name-of-DefHasType: DefHasType(name, <desugar-SType>) -> (name{}, <length> s*, <length> t*)
  with ?FunTType(s*, t*, _, _)

strategies

// This is the mapping from the directed consistency rule (t ~> t) to coercions (t ~> t : c)
computeCoercion(|lvl, from, to): subj -> <computeCoercion(|subj)> (lvl, from, to)
computeCoercion(|from, to): subj -> <computeCoercion(|subj)> (Err(), from, to)

// computeCoercion :: Type * Type -> Coercion
computeCoercion: (from, to) -> <computeCoercion(|from)> (Err(), from, to)

// computeCoercion :: MessageType * Type * Type -> Coercion
computeCoercion(|subj): (_, _, Dyn()) -> Id()
computeCoercion(|subj): (_, ErrT(), _) -> Id()
computeCoercion(|subj): (Err(), Dyn(), to) -> RuntimeCheck(to)
computeCoercion(|subj): (Warn(), Dyn(), to) -> Id()
computeCoercion(|subj): (lvl, from, to) -> coercion
  where if <CanCoerce> (from, to)
    then coercion := Id()
    else rules(Message :+ lvl -> (subj, NoInjectionBetween(from, to)))
       ; <debug(|"Message: ")> (lvl, subj, NoInjectionBetween(from, to))
       ; if Err() := lvl
           then coercion := Fail()
           else coercion := Id()
         end
  end

// computeSCoercion :: (|SType, SType) ? -> SCoercion
computeSCoercion: (_, SDyn()) -> SId()
computeSCoercion: (SDyn(), sft@FunTType(_, _, _, _)) -> SRuntimeCheck(sft)

// Add a cast after the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()).
insertCastAfter(|from, to) = insertCastAfter(|Err(), from, to)
insertCastAfter(|lvl, from, to): strat -> strat'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)> strat)
  ; strat' := <try(rm-redundant-cast)> Seq(strat, cast)

// Add a cast before the current strategy (in sequence) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastBefore(|from, to) = insertCastBefore(|Err(), from, to)
insertCastBefore(|lvl, from, to): strat -> strat'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)> strat)
  ; strat' := <try(rm-redundant-cast)> Seq(cast, strat)

// Add a cast on the current term (the App or `<cast(to)> term`) if necessary to go from `from` to `to`
// Doesn't insert Cast(Id()). Adds error message when inserting Cast(Fail()). 
insertCastApp(|from, to) = insertCastApp(|Err(), from, to)
insertCastApp(|lvl, from, to): term -> term'
  with
    cast := Cast(<computeCoercion(|lvl, from, to)> term)
  ; term' := <try(rm-redundant-cast)> App(cast, term)

// Used to remove Id() casts
rm-redundant-cast: Seq(Cast(Id()), strat) -> strat
rm-redundant-cast: Seq(strat, Cast(Id())) -> strat
rm-redundant-cast: App(Cast(Id()), term) -> term

toBinding-DefHasType: DefHasType(name, stype) -> ((name{}, snum, tnum), stype')
  with
    stype' := <desugar-SType> stype
  ; (snum, tnum) := <arityOf-SType> stype'

toBinding-ExtSDef: d@ExtSDef(name, sargs, targs) ->
  ( (name{}, <length> sargs, <length> targs)
  , <otf(!FunTType(
      <map(otf(toBinding-ExtSDef-Typedid))> sargs
    , <map(otf(!Dyn()))> targs
    , <otf(!Dyn())> d
    , <otf(!Dyn())> d))> d)
toBinding-ExtSDef-Typedid = ?VarDec(_, <toBinding-ExtSDef-ConstType + toBinding-ExtSDef-FunType>)
toBinding-ExtSDef-Typedid: DefaultVarDec(_) -> FunTType([], [], Dyn(), Dyn())
toBinding-ExtSDef-ConstType: ConstType(s) -> Dyn()
toBinding-ExtSDef-FunType: FunType(a*, r) -> SDyn()

strategies // Helpers

getDefTypes =
  with(
      map(try(extToNormal))
    ; (haveTypes, defs) := <partition(name-of-DefHasType)>
    ; defNames := <filter(name-of-StrategyDef-RuleDef)> defs
      // detect duplicates in haveTypes => errors
    ; <foldl(getDefTypes-detect-duplicates)> (haveTypes, <imset-new>)
      // detect missing definitions for haveTypes => errors
    ; imset-subtract(|<imset-from-list> defNames)
    ; imset-map(where({?(name, _, _); rules(Message :+ Err() -> (name, MissingDefinitionForTypeDefinition()))}))
  )
  ; map(try(simpleDef))
  ; partition(toBinding-DefHasType, toBinding-ExtSDef)
  ; (immap-from-list, immap-from-list)
  ; immap-union(keep-left)

getDefTypes-detect-duplicates: (name, set) -> <imset-insert(|name)> set
  with if <imset-contains(|name)> set
    then rules(Message :+ Err() -> (name, DuplicateTypeDefinition()))
  end

extToNormal: ExtSDefInl(n, s, t, b) -> SDefT(n, s, t, b)

simpleDef: ExtSDefInl(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: SDefT(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: SDef(n, s, _) -> ExtSDef(n, s, [])
simpleDef: SDefNoArgs(n, _) -> ExtSDef(n, [], [])
simpleDef: RDefT(n, s, t, _) -> ExtSDef(n, s, t)
simpleDef: RDef(n, s, _) -> ExtSDef(n, s, [])
simpleDef: RDefNoArgs(n, _) -> ExtSDef(n, [], [])

strategies // imrel

imrel-new = immap-new

imrel-from-list = map((id, ![<id>];imset-from-list)); immap-from-list(imset-union)

imrel-to-list = immap-to-list; mapconcat(?(k, <id>); imset-to-list; map(!(k, <id>)))

imrel-keys = immap-keys
imrel-keys-imset = immap-keys-imset

imrel-values-imset = immap-values;foldr(imset-new, imset-union)
imrel-values = imrel-values-imset; imset-to-list

imrel-contains-key(|k) = where(immap-get(|k))
imrel-contains-key(eq|k) = where(immap-get(eq|k))

imrel-contains(|k, v) = where(immap-get(|k);imset-contains(|v))
imrel-contains(eq|k, v) = where(immap-get(eq|k);imset-contains(|v))

imrel-get(|k) = immap-get(|k)
imrel-get(eq|k) = immap-get(eq|k)

imrel-put(|k, v) =
    where(vset := <(immap-get(|k) <+ imset-new);imset-insert(|v)>)
  ; immap-put(|k, vset)

imrel-put(eq|k, v) =
    where(vset := <(immap-get(eq|k) <+ imset-new);imset-insert(|v)>)
  ; immap-put(eq|k, vset)

immap-remove(|k) = immap-remove(|k)
immap-remove(eq|k) = immap-remove(eq|k)
immap-remove(|k, v) =
    where(vset := <(immap-get(|k) <+ imset-new);imset-remove(|v)>)
  ; immap-put(|k, vset)
immap-remove(eq|k, v) =
    where(vset := <(immap-get(eq|k) <+ imset-new);imset-remove(|v)>)
  ; immap-put(eq|k, vset)


