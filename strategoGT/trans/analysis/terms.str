module analysis/terms

imports

libstratego-lib
libstrc

libspoofax/term/annotation
libspoofax/stratego/debug

signatures/strategoGT-sig
signatures/sugar/modules-sig

analysis/utils
analysis/environment
analysis/signatures
analysis/defs
analysis/strategies
analysis/main
immutable/map
immutable/set

strategies // Terms in match position (core)

insertCasts-MatchTerm(|e1, st1) =
    insertCasts-StMatchTerm(|e1, <stMatchTerm-from-st> st1)
  ; (id, st-from-stMatchTerm)

insertCasts-StMatchTerm-Type(|e1):
  ((trm, t), st1) -> <insertCasts-StMatchTerm(|e1, <current-type(|t)> st1)> trm

insertCasts-StMatchTerm-Type(|e1, t):
  (trm, st1) -> <insertCasts-StMatchTerm(|e1, <current-type(|t)> st1)> trm

insertCasts-StMatchTerm(|e1, st1) = otf12(insertCasts-StMatchTerm-(|e1, st1))

insertCasts-StMatchTerm(|e1, st1):
  trm@Var(v) -> (trm, st2)
  with
    t1 := <current-type> st1
  ; if t2 := <term-lookup(|v{})> st1
      then if not(st2 := <term-put(|v{}, <LUB> (t1, t2))> st1)
        then
          <report-Err> (v, VariableBoundToIncompatibleType(t2, t1))
        ; st2 := st1
      end // TODO: do this for both unresolved names and unbound names
      else st2 := <term-put(|v{}, t1)> st1
    end

insertCasts-StMatchTerm(|e1, st1):
  trm@Wld() -> (trm, st1)

insertCasts-StMatchTerm-(|e1, st1):
  Anno(trm1, trm2) -> (Anno(trm3, trm4), st4)
  with
    (trm3, st2) := <insertCasts-StMatchTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-StMatchTerm(|e1, <current-type(|ListT())> st2)> trm2
  ; st4 := <current-type(|<current-type> st2)> st3

insertCasts-StMatchTerm-(|e1, st1):
  As(v1, trm1) -> (As(v2, trm2), st3)
  with
    (v2, st2) := <insertCasts-StMatchTerm(|e1, st1)> v1
  ; (trm2, st3) := <insertCasts-StMatchTerm(|e1, st2)> trm1

insertCasts-StMatchTerm(|e1, st1):
  Int(_) -> <insertCasts-StMatchTerm-Lit(|e1, st1, IntT())>

insertCasts-StMatchTerm(|e1, st1):
  Real(_) -> <insertCasts-StMatchTerm-Lit(|e1, st1, RealT())>

insertCasts-StMatchTerm(|e1, st1):
  Str(_) -> <insertCasts-StMatchTerm-Lit(|e1, st1, StringT())>

insertCasts-StMatchTerm-Lit(|e1, st1, t1):
  trm -> (trm, <current-type(|t1)> st1)
  with
    t2 := <current-type> st1
  ; if not(<CanCoerce>(t1, t2))
      then <report-Err> (trm, TypeMismatch(t1, t2))
    end

insertCasts-StMatchTerm-(|e1, st1):
  Op(cnstr, trm1*) -> (Op(cnstr, trm2*), st3)
  with
    t1 := <current-type> st1
  ; if ConstrType(t1*, t2) := <constr-lookup(|cnstr, <length> trm1*)> e1
    then
      lvl := <ConstructorStrictness>
    ; if not(<CanCoerce> (t2, t1))
        then <report> (lvl, cnstr, TypeMismatch(t2, t1))
      end
    ; if not(Err() := lvl)
        then t2* := <map(!Dyn())> t1*
        else t2* := t1*
      end
    ; (trm2*, st2) := <thread-map(insertCasts-StMatchTerm-Type(|e1))> (<zip> (trm1*, t2*), st1)
    ; st3 := <current-type(|t2)> st2
    else
      <report-Err> (cnstr, UnresolvedName())
    ; st3 := <current-type(|ErrT())> st1
    ; trm2* := trm1*
    end

insertCasts-StMatchTerm(|e1, st1) =
    otf(\OpQ(c, c*) -> Op(c, c*)\)
  ; insertCasts-StMatchTerm(|e1, st1)
  ; (otf(\Op(c, c*) -> OpQ(c, c*)\), id)

insertCasts-StMatchTerm-(|e1, st1):
  Explode(trm1, trm2) -> (Explode(trm3, trm4), st4)
  with
    // Note that constructors can be strings (in case of applications and tuples) or the empty list (in case of a list)
    (trm3, st2) := <insertCasts-StMatchTerm(|e1, <current-type(|Dyn())> st1)> trm1
  ; (trm4, st3) := <insertCasts-StMatchTerm(|e1, <current-type(|ListT())> st2)> trm2
  ; st4 := <current-type(|Dyn())> st3

strategies // Terms in build position (core)

insertCasts-BuildTerm(|e1, st1) =
    insertCasts-StBuildTerm(|e1, <stBuildTerm-from-st> st1)
  ; (id, st-from-stBuildTerm)

insertCasts-StBuildTerm(|e1):
  (trm, st1) -> <insertCasts-StBuildTerm(|e1, st1)> trm

insertCasts-StBuildTerm(|e1, st1) = otf12(insertCasts-StBuildTerm-(|e1, st1))

insertCasts-StBuildTerm(|e1, st1):
  bt@Var(v) -> (bt, st2)
  with
  // TODO: distinguish between unresolved name and unbound name
    if not(t := <term-lookup(|v{})> st1)
      then
        <report-Err> (v, UnresolvedName())
      ; t := ErrT()
    end
  ; st2 := <current-type(|t)> st1

insertCasts-StBuildTerm(|e1, st1):
  trm@Wld() -> (trm, <current-type(|ErrT())> st1)
  with
    <report-Err> (trm, WldInBuildTerm())

insertCasts-StBuildTerm-(|e1, st1):
  Anno(trm1, trm2) -> (Anno(trm3, trm4), st4)
  with
    (trm3, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-StBuildTerm(|e1, st2)> trm2
  ; if not(<CanCoerce> (<current-type> st3, ListT()))
      then <report-Err> (trm2, NonListInAnno(<current-type> st3))
    end
  ; st4 := <current-type(|<current-type> st2)> st3

insertCasts-StBuildTerm-(|e1, st1):
  trm1@As(Var(v), trm2) -> (As(Var(v), trm3), <current-type(|ErrT())> st2)
  with
    (trm3, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm2
  ; <report-Err> (trm1, AsInBuildTerm())

insertCasts-StBuildTerm(|e1, st1):
  trm@Int(_) -> (trm, <current-type(|IntT())> st1)

insertCasts-StBuildTerm(|e1, st1):
  trm@Real(_) -> (trm, <current-type(|RealT())> st1)

insertCasts-StBuildTerm(|e1, st1):
  trm@Str(_) -> (trm, <current-type(|StringT())> st1)

insertCasts-StBuildTerm-(|e1, st1):
  Op(cnstr, trm1*) -> (Op(cnstr, trm2*), st3)
  with
    if ConstrType(t1*, t2) := <constr-lookup(|cnstr, <length> trm1*)> e1
    then
      lvl := <ConstructorStrictness>
    ; let threader = {c', st':
        \((c, et), st) -> (<insertCastApp(|lvl, <current-type> st', et)> c', st')
          with (c', st') := <insertCasts-StBuildTerm(|e1, st)> c\}
      in (trm2*, st2) := <thread-map(threader)> (<zip> (trm1*, t1*), st1)
      end
    ; st3 := <current-type(|t2)> st2
    else
      <report-Err> (cnstr, UnresolvedName())
    ; st3 := <current-type(|ErrT())> st1
    ; trm2* := trm1*
    end

insertCasts-StBuildTerm(|e1, st1) =
    otf(\OpQ(c, c*) -> Op(c, c*)\)
  ; insertCasts-StBuildTerm(|e1, st1)
  ; (otf(\Op(c, c*) -> OpQ(c, c*)\), id)

insertCasts-StBuildTerm-(|e1, st1):
  Explode(trm1, trm2) -> (Explode(trm3, trm5), st4)
  with
    (trm3, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; (trm4, st3) := <insertCasts-StBuildTerm(|e1, st2)> trm2
    // Note that constructors can be strings (in case of applications and tuples) or the empty list (in case of a list)
  ; if not(<CanCoerce> (<current-type> st2, StringT()) + <CanCoerce> (<current-type> st2, ListT()))
      then <report-Err> (trm1, NonStringOrListInExplodeConsPosition(<current-type> st2))
    end
    // TODO: support cast to string-or-list for the constructor
  ; trm5 := <insertCastApp(|<current-type> st3, ListT())> trm4
  ; st4 := <current-type(|Dyn())> st3

strategies // Terms in match position (sugar)

insertCasts-StMatchTerm(|e1, st1):
  trm@BuildDefault(_) -> (trm, st1)
  with
    <report-Err> (trm, BuildDefaultInMatchTerm())

insertCasts-StMatchTerm-(|e1, st1):
  AnnoList(trm1, trm1*) -> (AnnoList(trm2, trm2*), st4)
  with
    (trm2, st2) := <insertCasts-StMatchTerm(|e1, st1)> trm1
  ; (trm2*, st3) := <thread-map(insertCasts-StMatchTerm-Type(|e1, Dyn()))> (trm1*, st2)
  ; st4 := <current-type(|<current-type> st2)> st3

insertCasts-StMatchTerm-(|e1, st1):
  NoAnnoList(trm1) -> (NoAnnoList(trm2), st2)
  with
    (trm2, st2) := <insertCasts-StMatchTerm(|e1, st1)> trm1

insertCasts-StMatchTerm-(|e1, st1):
  App(s1, trm1) -> (App(s2, trm2), st5)
  with
    (trm2, st2) := <insertCasts-BuildTerm(|e1, st1)> trm1
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1
  ; st4 := <term-env(<term-env> st3)> st1
  ; if not(st5 := <output-type(|<current-type> st3)> st4)
      then
          <report-Warn> (s1, MultipleAppsInMatch())
        ; st5 := st4
    end

insertCasts-StMatchTerm-(|e1, st1):
  RootApp(s1) -> (RootApp(s2), st4)
  with
    (s2, st2) := <insertCasts-Strategy(|e1, st1)> s1
  ; st3 := <term-env(<term-env> st2)> st1
  ; if not(st4 := <output-type(|<current-type> st2)> st3)
      then
          <report-Warn> (s1, MultipleAppsInMatch())
        ; st4 := st3
    end

insertCasts-StMatchTerm(|e1, st1):
  Char(_) -> <insertCasts-StMatchTerm-Lit(|e1, st1, IntT())>

insertCasts-StMatchTerm-(|e1, st1):
  Tuple(trm1*) -> (Tuple(trm2*), st3)
  with
    t1 := <current-type> st1
  ; t1* := <map(!Dyn())> trm1*
  ; t2 := TupleT(t1*)
  ; lvl := <ConstructorStrictness>
  ; if not(<CanCoerce> (t2, t1))
      then <report> (lvl, "", TypeMismatch(t2, t1))
    end
  ; (trm2*, st2) := <thread-map(insertCasts-StMatchTerm-Type(|e1))> (<zip> (trm1*, t1*), st1)
  ; st3 := <current-type(|t2)> st2

insertCasts-StMatchTerm-(|e1, st1):
  List(trm1*) -> (List(trm2*), st3)
  with
    t1 := <current-type> st1
  ; t1* := <map(!Dyn())> trm1*
  ; t2 := ListT()
  ; lvl := <ConstructorStrictness>
  ; if not(<CanCoerce> (t2, t1))
      then <report> (lvl, "", TypeMismatch(t2, t1))
    end
  ; (trm2*, st2) := <thread-map(insertCasts-StMatchTerm-Type(|e1))> (<zip> (trm1*, t1*), st1)
  ; st3 := <current-type(|t2)> st2

insertCasts-StMatchTerm-(|e1, st1):
  ListTail(trm1*, trm1) -> (ListTail(trm2*, trm2), st4)
  with
    t1 := <current-type> st1
  ; t1* := <map(!Dyn())> trm1*
  ; t2 := ListT()
  ; lvl := <ConstructorStrictness>
  ; if not(<CanCoerce> (t2, t1))
      then <report> (lvl, "", TypeMismatch(t2, t1))
    end
  ; (trm2*, st2) := <thread-map(insertCasts-StMatchTerm-Type(|e1))> (<zip> (trm1*, t1*), st1)
  ; (trm2, st3) := <insertCasts-StMatchTerm(|e1, <current-type(|ListT())> st2)> trm1
  ; st4 := <current-type(|t2)> st3

insertCasts-StMatchTerm(|e1, st1):
  trm@BuildDefaultPT(_) -> (trm, st1)
  with
    <report-Err> (trm, BuildDefaultInMatchTerm())

strategies // Terms in build position (sugar)

insertCasts-StBuildTerm-(|e1, st1):
  trm@BuildDefault(trm1) -> (BuildDefault(trm2), st2)
  with
    (trm2, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; <report-Err> (trm, BuildDefaultInBuildTerm())

insertCasts-StBuildTerm-(|e1, st1):
  AnnoList(trm1, trm1*) -> (AnnoList(trm2, trm2*), st4)
  with
    (trm2, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; (trm2*, st3) := <thread-map(insertCasts-StBuildTerm(|e1))> (trm1*, st2)
  ; st4 := <current-type(|<current-type> st2)> st3

insertCasts-StBuildTerm-(|e1, st1):
  NoAnnoList(trm1) -> (NoAnnoList(trm2), st2)
  with
    (trm2, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1

insertCasts-StBuildTerm-(|e1, st1):
  App(s1, trm1) -> (App(s2, trm2), st5)
  with
    st2 := <st-from-stBuildTerm-input> st1
  ; (trm2, st3) := <insertCasts-BuildTerm(|e1, st2)> trm1
  ; (s2, st4) := <insertCasts-Strategy(|e1, st3)> s1
  ; st5 := <term-env(<term-env> st4);current-type(|<current-type> st4)> st1

insertCasts-StBuildTerm-(|e1, st1):
  RootApp(s1) -> (RootApp(s2), st4)
  with
    st2 := <st-from-stBuildTerm-input> st1
  ; (s2, st3) := <insertCasts-Strategy(|e1, st2)> s1
  ; st4 := <term-env(<term-env> st3);current-type(|<current-type> st3)> st1

insertCasts-StBuildTerm(|e1, st1):
  trm@Char(_) -> (trm, <current-type(|IntT())> st1)

insertCasts-StBuildTerm-(|e1, st1):
  Tuple(trm1*) -> (Tuple(trm2*), st3)
  with
    t1 := TupleT(<map(!Dyn())> trm1*)
  ; (trm2*, st2) := <thread-map(insertCasts-StBuildTerm(|e1))> (trm1*, st1)
  ; st3 := <current-type(|t1)> st2

insertCasts-StBuildTerm-(|e1, st1):
  List(trm1*) -> (List(trm2*), st3)
  with
    t1 := ListT()
  ; (trm2*, st2) := <thread-map(insertCasts-StBuildTerm(|e1))> (trm1*, st1)
  ; st3 := <current-type(|t1)> st2

insertCasts-StBuildTerm-(|e1, st1):
  ListTail(trm1*, trm1) -> (ListTail(trm2*, trm3), st4)
  with
    (trm2*, st2) := <thread-map(insertCasts-StBuildTerm(|e1))> (trm1*, st1)
  ; (trm2, st3) := <insertCasts-StBuildTerm(|e1, st2)> trm1
  ; trm3 := <insertCastApp(|<current-type> st3, ListT())> trm2
  ; st4 := <current-type(|ListT())> st3

insertCasts-StBuildTerm-(|e1, st1):
  trm@BuildDefaultPT(trm1) -> (BuildDefaultPT(trm2), st2)
  with
    (trm2, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; <report-Err> (trm, BuildDefaultInBuildTerm())

strategies // Terms in match position (string quotations)

insertCasts-StMatchTerm-(|e1, st1):
  trm@StringQuotation1(p, sqp1*) -> (StringQuotation1(p, sqp2*), st2)
  with
    (sqp2*, st2) := <thread-map(insertCasts-Match-StringQuotedPart(|e1))> (sqp1*, st1)
  ; <report-Err> (trm, StringQuotationInMatchTerm())

insertCasts-StMatchTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation2(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StMatchTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation2(p, sqp*)\)

insertCasts-StMatchTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation3(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StMatchTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation3(p, sqp*)\)

insertCasts-StMatchTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation4(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StMatchTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation4(p, sqp*)\)

insertCasts-Match-StringQuotedPart(|e1) = otf22(insertCasts-Match-StringQuotedPart-(|e1))

insertCasts-Match-StringQuotedPart-(|e1):
  (StringEscape1(p, trm1), st1) -> (StringEscape1(p, trm2), st2)
  with
    (trm2, st2) := <insertCasts-StMatchTerm(|e1, <current-type(|StringT())> st1)> trm1

insertCasts-Match-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape2(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Match-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape2(p, sqp*)\)

insertCasts-Match-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape3(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Match-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape3(p, sqp*)\)

insertCasts-Match-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape4(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Match-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape4(p, sqp*)\)

strategies // Terms in build position (string quotations)

insertCasts-StBuildTerm-(|e1, st1):
  StringQuotation1(p, sqp1*) -> (StringQuotation1(p, sqp2*), st2)
  with
    (sqp2*, st2) := <thread-map(insertCasts-Build-StringQuotedPart(|e1))> (sqp1*, st1)

insertCasts-StBuildTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation2(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StBuildTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation2(p, sqp*)\)

insertCasts-StBuildTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation3(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StBuildTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation3(p, sqp*)\)

insertCasts-StBuildTerm(|e1, st1) =
  otf12-sugar(
      \StringQuotation4(p, sqp*) -> StringQuotation1(p, sqp*)\
    , insertCasts-StBuildTerm(|e1, st1)
    , \StringQuotation1(p, sqp*) -> StringQuotation4(p, sqp*)\)

insertCasts-Build-StringQuotedPart(|e1) = otf22(insertCasts-Build-StringQuotedPart-(|e1))

insertCasts-Build-StringQuotedPart-(|e1):
  (StringEscape1(p, trm1), st1) -> (StringEscape1(p, trm3), st2)
  with
    (trm2, st2) := <insertCasts-StBuildTerm(|e1, st1)> trm1
  ; trm3 := <insertCastApp(|<current-type> st2, StringT())> trm2

insertCasts-Build-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape2(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Build-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape2(p, sqp*)\)

insertCasts-Build-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape3(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Build-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape3(p, sqp*)\)

insertCasts-Build-StringQuotedPart(|e1) =
  otf22-sugar(
      \StringEscape4(p, sqp*) -> StringEscape1(p, sqp*)\
    , insertCasts-Build-StringQuotedPart(|e1)
    , \StringEscape1(p, sqp*) -> StringEscape4(p, sqp*)\)

