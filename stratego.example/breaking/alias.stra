module lists

signature
  sorts List
  constructors
    Nil   :                List(a)
    Cons  : a * List(a) -> List(a)

strategies
  comp = match sequential
           case | x@Nil(): !x
           case | y@Cons(z, zz@Nil()): !z
         end

//===================================================

s(|x) = match sequential
          case   | C1(x, _): !1 // x == bound
          case y | C1(y, _): !y // y == unbound; case matches C1(_, _)
          case z | z@C2(): !3   // matches on C2(), binds it to z
        end

// desugars to: (linearise)

s(|x) = match sequential
          case   | C1(x1, _) where x1 := x: !1
          case y | C1(y, _): !y
          case z | z@C2(): !3
        end

// compiles to: (non-linear consistency checks and (sub)term bindings)

s(|x) = switch current.type {
          alt APPL:
            switch current.con {
              alt (C1, 2) where x1 := current.1; x1 := x:
                            !1
                          where y := current.1:
                            !y
//              alt (C1, 2) where x1 ::= [cur, sub 1]; x1 := x:
//                !1
//              alt (C1, 2) where y ::= [cur, sub 1]:
//                !y
              alt (C2, 0) where z := current:
                !3
              default: fail
            }
          default: fail
        }
