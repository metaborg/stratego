module jasmin-all

strategies // definition stubs

is-string :: ? -> string
is-string = fail

string-replace(|string, string) :: string -> string
string-replace(|from, to) = fail

box2text-string(|int) :: ? -> string
box2text-string(|len) = fail

strip-annos = fail

prettyprint-jasmin-ClassName = fail
prettyprint-jasmin-MethodName = fail
prettyprint-jasmin-FieldName = fail
prettyprint-jasmin-ParameterDescriptor = fail
prettyprint-jasmin-ReturnDescriptor = fail

map(a -> b) :: List(a) -> List(b)
map(s) = fail
concat-strings :: List(string) -> string
concat-strings = fail

string-starts-with(|string) :: string -> string
string-starts-with(|prefix) = fail
has-annotation(? -> ?) :: ? -> ?
has-annotation(s) = fail

task-create-error-on-failure(|t1,t2,t3) = fail
nabl-lookup-all(|t1) = fail
task-create-error-on-multiple(|t1,t2,t3) = fail
nabl-lookup-lexical(|t1,t2) = fail
type-lookup(|t1) = fail
type-match(|t1,t2) = fail

filter(a -> b) :: List(a) -> List(b)
filter(s) = fail

get-in-stack :: ? -> string
get-in-stack = fail
get-out-stack :: ? -> string
get-out-stack = fail

foldl(a * b -> b) :: List(a) * b -> b
foldl(s) = fail
Snd :: a * b -> b // stricter than the implementation
Snd = fail
partition(a -> b) :: List(a) -> List(b) * List(a)
partition(s) = fail
concat :: List(List(a)) -> List(a)
concat = fail
alltd(? -> ?) :: ? -> ?
alltd(s) = fail

get-pop-type = fail
get-push-type = fail
get-next-instr = fail

dec :: int -> int
dec = fail
dec-string-to-int :: string -> int
dec-string-to-int = fail
try(a -> b) :: a -> ?
try(s) = fail
reverse :: List(a) -> List(a)
reverse = fail
preserve-annos(a -> b) :: a -> b
preserve-annos(s) = fail
split-after :: string * string -> string * string
split-after = fail
rtrim-chars(int -> int) :: string -> string
rtrim-chars(s) = fail
string-ends-with(|string) :: string -> string
string-ends-with(|t) = fail
conc :: List(a) * List(a) -> List(a)
conc = fail
new :: ? -> string
new = fail
leq :: a * a -> a * a
leq = fail
repeat(? -> a | int) :: ? -> a
repeat(s|t) = fail
mapconcat(a -> List(b)) :: List(a) -> List(b)
mapconcat(s) = fail
uniq :: List(a) -> List(a)
uniq = fail
lookup :: a * List(a * b) -> b
lookup = fail
eq :: a * a -> a * a
eq = fail
unify(? -> a) :: List(? * ?) -> List(a * ?)
unify(s) = fail
mkterm :: ? * List(?) -> ?
mkterm = fail
fetch(a -> b) :: List(a) -> List(?)
fetch(s) = fail
if(? -> a, a -> b, ? -> b) :: ? -> b
if(s1,s2,s3) = fail
topdown(? -> ?) :: ? -> ?
topdown(s) = fail
is-subterm :: a * b -> a * b
is-subterm = fail
elem :: a * List(a) -> List(a)
elem = fail

task-create-id(|t1,t2) = fail
type-is(|t) = fail

newname :: string -> string
newname = fail

store-in-stack(|t1,t2) = fail
store-out-stack(|t1,t2) = fail

string-tokenize(|List(int)) :: string -> List(string)
string-tokenize(|t) = fail
init :: List(a) -> List(a)
init = fail
separate-by(|?) :: List(?) -> List(?)
separate-by(|t) = fail
guarantee-extension(|string) :: string -> string
guarantee-extension(|t) = fail
dirname :: string -> string
dirname = fail
addS :: string * string -> string
addS = fail
subtS :: string * string -> string
subtS = fail
mulS :: string * string -> string
mulS = fail
index :: int * List(a) -> a
index = fail
string-to-int :: string -> int
string-to-int = fail
at-index(a -> ?) :: int * List(a) -> List(?)
at-index(s) = fail
inc :: int -> int
inc = fail
length :: List(?) -> int
length = fail
int-to-string :: int -> string
int-to-string = fail
geqS :: string * string -> string * string
geqS = fail
gtS :: string * string -> string * string
gtS = fail
leqS :: string * string -> string * string
leqS = fail
ltS :: string * string -> string * string
ltS = fail
getfirst(a -> b) :: List(a) -> b
getfirst(s) = fail
drop(|int) :: List(a) -> List(a)
drop(|t) = fail
take(|int) :: List(a) -> List(a)
take(|t) = fail
Tl :: List(a) -> List(a)
Tl = fail
at-index(a -> ? | int) :: List(a) -> List(?)
at-index(s|t) = fail

analyze-all(s1,s2,s3|t) = fail
language = fail
analysis-resolve(|t1,t2) = fail
get-type = fail
analysis-propose-completions(|t1,t2) = fail
analysis-debug-project(|t) = fail
analysis-debug-partition(|t) = fail
analysis-debug-index-partition(|t) = fail
analysis-debug-index-project(|t) = fail
analysis-debug-task-project(|t) = fail
analysis-debug-task-partition(|t) = fail
analysis-debug-task-selection(|t) = fail
pp-debug = fail

get-extension :: string -> string
get-extension = fail
bottomup(? -> ?) :: ? -> ?
bottomup(s) = fail
is-list :: ? -> List(?)
is-list = fail
mod :: a * a -> a
mod = fail
divi :: int * int -> int
divi = fail
muli :: int * int -> int
muli = fail
addi :: int * int -> int
addi = fail
foldr(List(a) -> b, a * b -> b) :: List(a) -> b
foldr(s1, s2) = fail
explode-term :: ? -> ? * List(?)
explode-term = fail
unzip(a -> b * c) :: List(a) -> List(b) * List(c)
unzip(s) = fail
is-int :: ? -> int
is-int = fail
subti :: int * int -> int
subti = fail

signature constructors
  Use : Task -> Query
  NablNsMethod : NablNs
  NablNsField : NablNs
  ASMClass : int * int * ClassName * None * ClassName * List(a) * List(ASMField) * List(ASMMethod) -> ASMClass
  ASMMethod : int * MethodName * string * None * List(a) * List(OpInstruction) -> ASMMethod
  ASMField : int * FieldName * string * None * None -> ASMField
  None : None

imports
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Descriptors-sig


signature
  constructors
    RuntimeVisible             : ClassName * List(AnnotationField) -> Annotation
    RuntimeInvisible           : ClassName * List(AnnotationField) -> Annotation
    RuntimeVisibleParam        : Int * ClassName * List(AnnotationField) -> Annotation
    RuntimeInvisibleParam      : Int * ClassName * List(AnnotationField) -> Annotation
    AnnotationDefault          : AnnotationName * List(Constant) -> Annotation
    AnnotationField            : AnnotationName * AnnotationDescriptor * List(Constant) -> AnnotationField
    NestedAnnotation           : AnnotationName * Annotation -> AnnotationField

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig


signature
  constructors
    IADD              : Instruction
    IAND              : Instruction
    IDIV              : Instruction
    IMUL              : Instruction
    INEG              : Instruction
    IOR               : Instruction
    IREM              : Instruction
    ISHL              : Instruction
    ISHR              : Instruction
    ISUB              : Instruction
    IUSHR             : Instruction
    IXOR              : Instruction
    LADD              : Instruction
    LAND              : Instruction
    LDIV              : Instruction
    LMUL              : Instruction
    LNEG              : Instruction
    LOR               : Instruction
    LREM              : Instruction
    LSHL              : Instruction
    LSHR              : Instruction
    LSUB              : Instruction
    LUSHR             : Instruction
    LXOR              : Instruction
    FADD              : Instruction
    FDIV              : Instruction
    FMUL              : Instruction
    FNEG              : Instruction
    FREM              : Instruction
    FSUB              : Instruction
    DADD              : Instruction
    DDIV              : Instruction
    DMUL              : Instruction
    DNEG              : Instruction
    DREM              : Instruction
    DSUB              : Instruction
    IINC              : VarRef * Amount -> Instruction
    IINC_W            : VarRef * Amount -> Instruction
                      : Int -> Amount
    Neg               : NegInt -> Amount
    FCMPG             : Instruction
    FCMPL             : Instruction
    DCMPG             : Instruction
    DCMPL             : Instruction
    LCMP              : Instruction

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig


signature
  constructors
    RelativeFwd           : Int -> RelOffset
    RelativeBwd           : Int -> RelOffset
                          : LabelRef -> Target
                          : RelOffset -> Target
    IFEQ                  : Target -> Instruction
    IFLT                  : Target -> Instruction
    IFLE                  : Target -> Instruction
    IFNE                  : Target -> Instruction
    IFGT                  : Target -> Instruction
    IFGE                  : Target -> Instruction
    IFNULL                : Target -> Instruction
    IFNONNULL             : Target -> Instruction
    IF_ICMPEQ             : Target -> Instruction
    IF_ICMPLT             : Target -> Instruction
    IF_ICMPLE             : Target -> Instruction
    IF_ICMPNE             : Target -> Instruction
    IF_ICMPGT             : Target -> Instruction
    IF_ICMPGE             : Target -> Instruction
    IF_ACMPEQ             : Target -> Instruction
    IF_ACMPNE             : Target -> Instruction
    Table                 : Int * List(TableEntry) * LabelRef -> Instruction
    Lookup                : List(LookupEntry) * LabelRef -> Instruction
                          : LabelRef -> TableEntry
    NPAIR                 : Int * LabelRef -> LookupEntry
    GOTO                  : LabelRef -> Instruction
    GOTO_W                : LabelRef -> Instruction
    JSR                   : LabelRef -> Instruction
    JSR_W                 : LabelRef -> Instruction

signature
  constructors
    I2L               : Instruction
    I2F               : Instruction
    I2D               : Instruction
    L2F               : Instruction
    L2D               : Instruction
    F2D               : Instruction
    I2B               : Instruction
    I2S               : Instruction
    I2C               : Instruction
    L2I               : Instruction
    F2I               : Instruction
    F2L               : Instruction
    D2I               : Instruction
    D2L               : Instruction
    D2F               : Instruction

imports
  signatures/JasminXT-Types-sig


signature
  constructors
    JBCFieldDesc               : FieldType -> FieldDescriptor
                               : FieldType -> ParameterDescriptor
                               : FieldType -> AnnotationDescriptor
                               : FieldType -> ReturnDescriptor
    Void                       : ReturnDescriptor
    JBCMethodDesc              : List(ParameterDescriptor) * ReturnDescriptor -> MethodDescriptor

imports
  signatures/JasminXT-Descriptors-sig
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Annotations-sig


signature
  constructors
    JBCLimitStack              : Int -> Directive
    JBCLimitLocals             : Int -> Directive
    JBCLine                    : Int -> Directive
    JBCVarDecl                 : Int * VarName * FieldDescriptor * LabelRef * LabelRef -> Directive
    JBCThrows                  : ClassRef -> Directive
    JBCCatch                   : ClassRef * LabelRef * LabelRef * LabelRef -> Directive
    JBCSignature               : STRING -> Directive
    JBCStack                   : StackDirOffset * List(StackDirLocalVar) * List(StackDirStackVar) -> Directive
    JBCStack                   : Int * StackDirOffset * List(StackDirLocalVar) * List(StackDirStackVar) -> Directive
    JBCDeprecated              : Directive
    JBCAttribute               : AttributeName * FileName -> Directive
    Offset                     : LabelRef -> StackDirOffset
    None                       : StackDirOffset
    LocalVar                   : VerificationType -> StackDirLocalVar
    StackVar                   : VerificationType -> StackDirStackVar
    Top                        : VerificationType
    Integer                    : VerificationType
    Float                      : VerificationType
    Long                       : VerificationType
    Double                     : VerificationType
    Null                       : VerificationType
    UninitThis                 : VerificationType
    Object                     : ClassName -> VerificationType
    Uninit                     : LabelRef -> VerificationType

signature
  constructors
    ATHROW            : Instruction

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Descriptors-sig
  signatures/JasminXT-Annotations-sig


signature
  constructors
    JBCField                     : List(FieldAccess) * FieldName * FieldDescriptor * FieldSignatureSpec * InitialValue -> Field
    JBCExtField                  : List(FieldAccess) * FieldName * FieldDescriptor * FieldSignatureSpec * InitialValue * List(FieldAttribute) -> Field
    JBCSignature                 : STRING -> FieldAttribute
    JBCDeprecated                : FieldAttribute
    JBCAttribute                 : AttributeName * FileName -> FieldAttribute
    JBCAnnotation                : Annotation -> FieldAttribute
    FieldSig                     : STRING -> FieldSignatureSpec
    None                         : FieldSignatureSpec
    InitVal                      : Constant -> InitialValue
    None                         : InitialValue
    PUBLIC                       : FieldAccess
    PRIVATE                      : FieldAccess
    PROTECTED                    : FieldAccess
    STATIC                       : FieldAccess
    FINAL                        : FieldAccess
    VOLATILE                     : FieldAccess
    TRANSIENT                    : FieldAccess
    FPSTRICT                     : FieldAccess
    SYNTHETIC                    : FieldAccess

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Descriptors-sig


signature
  constructors
    JBCHeader                    : BytecodeSpec * SourceSpec * ClassSpec * SuperSpec * List(ImplementsSpec) * SignatureSpec * EnclosingSpec * List(DebugSpec) * List(InnerClassSpec) * List(InnerInterfaceSpec) -> JasminHeader
    JBCVersion                   : MajorVersion * MinorVersion -> BytecodeSpec
    None                         : BytecodeSpec
    Major                        : Int -> MajorVersion
    Minor                        : Int -> MinorVersion
    None                         : MinorVersion
    JBCSource                    : STRING -> SourceSpec
    None                         : SourceSpec
    JBCClass                     : List(ClassAccess) * ClassName -> ClassSpec
    JBCInterface                 : List(ClassAccess) * ClassName -> ClassSpec
    PUBLIC                       : ClassAccess
    FINAL                        : ClassAccess
    INTERFACE                    : ClassAccess
    ABSTRACT                     : ClassAccess
    SUPER                        : ClassAccess
    JBCSuper                     : ClassName -> SuperSpec
    JBCImplements                : ClassName -> ImplementsSpec
    JBCSignature                 : STRING -> SignatureSpec
    None                         : SignatureSpec
    JBCEnclosing                 : MethodDescriptor -> EnclosingSpec
    None                         : EnclosingSpec
    JBCDebug                     : STRING -> DebugSpec
    JBCInnerClass                : InnerClassAccess * InnerClassName * InnerName * OuterName -> InnerClassSpec
    JBCInnerInterface            : InnerClassAccess * InnerClassName * InnerName * OuterName -> InnerInterfaceSpec
                                 : ClassAccess -> InnerClassAccess
    None                         : InnerClassAccess
                                 : ClassName -> InnerClassName
    None                         : InnerClassName
    InnerNameSpec                : List(ClassName) -> InnerName
    None                         : InnerName
    OuterNameSpec                : ClassName -> OuterName
    None                         : OuterName

imports
  signatures/JasminXT-Arithmetic-sig
  signatures/JasminXT-Control-sig
  signatures/JasminXT-Conversion-sig
  signatures/JasminXT-Exceptions-sig
  signatures/JasminXT-LoadStore-sig
  signatures/JasminXT-InvokeReturn-sig
  signatures/JasminXT-Objects-sig
  signatures/JasminXT-Stack-sig
  signatures/JasminXT-Synchronisation-sig
  signatures/JasminXT-Numbers-sig


signature
  constructors
    NOP                 : Instruction
    BREAKPOINT          : Instruction
    PC                  : Int * Instruction -> PCInstruction
                        : Instruction -> PCInstruction

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Descriptors-sig
  signatures/JasminXT-Numbers-sig


signature
  constructors
    INVOKESPECIAL     : MethodRef -> Instruction
    INVOKEVIRTUAL     : MethodRef -> Instruction
    INVOKESTATIC      : MethodRef -> Instruction
    INVOKEINTERFACE   : MethodRef * Int -> Instruction
    RETURN            : Instruction
    IRETURN           : Instruction
    LRETURN           : Instruction
    FRETURN           : Instruction
    DRETURN           : Instruction
    ARETURN           : Instruction
    RET               : VarRef -> Instruction
    RET_W             : VarRef -> Instruction

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Strings-sig


signature
  constructors
    BIPUSH            : Int -> Instruction
    SIPUSH            : Int -> Instruction
    ICONST_M1         : Instruction
    ICONST_0          : Instruction
    ICONST_1          : Instruction
    ICONST_2          : Instruction
    ICONST_3          : Instruction
    ICONST_4          : Instruction
    ICONST_5          : Instruction
    LCONST_0          : Instruction
    LCONST_1          : Instruction
    FCONST_0          : Instruction
    FCONST_1          : Instruction
    FCONST_2          : Instruction
    DCONST_0          : Instruction
    DCONST_1          : Instruction
    ACONST_NULL       : Instruction
    LDC               : Constant -> Instruction
    LDC_W             : Constant -> Instruction
    LDC2_W            : Constant -> Instruction
    ILOAD             : VarRef -> Instruction
    LLOAD             : VarRef -> Instruction
    FLOAD             : VarRef -> Instruction
    DLOAD             : VarRef -> Instruction
    ALOAD             : VarRef -> Instruction
    ILOAD_W           : VarRef -> Instruction
    LLOAD_W           : VarRef -> Instruction
    FLOAD_W           : VarRef -> Instruction
    DLOAD_W           : VarRef -> Instruction
    ALOAD_W           : VarRef -> Instruction
    ILOAD_0           : Instruction
    ILOAD_1           : Instruction
    ILOAD_2           : Instruction
    ILOAD_3           : Instruction
    ALOAD_0           : Instruction
    ALOAD_1           : Instruction
    ALOAD_2           : Instruction
    ALOAD_3           : Instruction
    LLOAD_0           : Instruction
    LLOAD_1           : Instruction
    LLOAD_2           : Instruction
    LLOAD_3           : Instruction
    DLOAD_0           : Instruction
    DLOAD_1           : Instruction
    DLOAD_2           : Instruction
    DLOAD_3           : Instruction
    FLOAD_0           : Instruction
    FLOAD_1           : Instruction
    FLOAD_2           : Instruction
    FLOAD_3           : Instruction
    ISTORE            : VarRef -> Instruction
    LSTORE            : VarRef -> Instruction
    FSTORE            : VarRef -> Instruction
    DSTORE            : VarRef -> Instruction
    ASTORE            : VarRef -> Instruction
    ISTORE_W          : VarRef -> Instruction
    LSTORE_W          : VarRef -> Instruction
    FSTORE_W          : VarRef -> Instruction
    DSTORE_W          : VarRef -> Instruction
    ASTORE_W          : VarRef -> Instruction
    ISTORE_0          : Instruction
    ISTORE_1          : Instruction
    ISTORE_2          : Instruction
    ISTORE_3          : Instruction
    ASTORE_0          : Instruction
    ASTORE_1          : Instruction
    ASTORE_2          : Instruction
    ASTORE_3          : Instruction
    LSTORE_0          : Instruction
    LSTORE_1          : Instruction
    LSTORE_2          : Instruction
    LSTORE_3          : Instruction
    FSTORE_0          : Instruction
    FSTORE_1          : Instruction
    FSTORE_2          : Instruction
    FSTORE_3          : Instruction
    DSTORE_0          : Instruction
    DSTORE_1          : Instruction
    DSTORE_2          : Instruction
    DSTORE_3          : Instruction

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Descriptors-sig
  signatures/JasminXT-Instructions-sig
  signatures/JasminXT-Directives-sig


signature
  constructors
    JBCMethod              : List(MethodAccess) * MethodName * MethodDescriptor * List(Statement) -> Method
    PUBLIC                 : MethodAccess
    PRIVATE                : MethodAccess
    PROTECTED              : MethodAccess
    STATIC                 : MethodAccess
    FINAL                  : MethodAccess
    SYNCHRONIZED           : MethodAccess
    NATIVE                 : MethodAccess
    ABSTRACT               : MethodAccess
                           : PCInstruction -> Statement
                           : Directive -> Statement
                           : Label -> Statement
    JBCLabel               : LabelName -> Label

imports
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Descriptors-sig


signature
  constructors
                           : string -> Identifier
                           : string -> SQIdentifier
                           : string -> QualifiedName
                           : string -> LabelName
                           : STRING -> FileName
                           : QualifiedName -> ClassName
                           : Identifier -> AttributeName
                           : Identifier -> AnnotationName
                           : Identifier -> FieldName
                           : Identifier -> MethodName
    Init                   : MethodName
                           : SQIdentifier -> VarName
    CRef                   : ClassName -> ClassRef
    VarNum                 : Int -> VarRef
    LabelRef               : LabelName -> LabelRef
    Absolute               : Int -> LabelRef
    FRef                   : FieldName -> FRef
    MRef                   : MethodName -> MRef
    JBCFieldRef            : ClassRef * FRef * FieldDescriptor -> FieldRef
    JBCMethodRef           : ClassRef * MRef * MethodDescriptor -> MethodRef
    ByteName               : BaseTypeName
    CharName               : BaseTypeName
    DoubleName             : BaseTypeName
    FloatName              : BaseTypeName
    IntName                : BaseTypeName
    LongName               : BaseTypeName
    ShortName              : BaseTypeName
    BooleanName            : BaseTypeName
    Reference              : ClassRef -> ObjectType
                           : ObjectType -> FieldType

signature
  constructors
                   : string -> Double
                   : string -> Float
                   : string -> Int
                   : string -> NegInt
    Double         : Double -> Constant
    Float          : Float -> Constant
    Int            : Int -> Constant

imports
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Types-sig


signature
  constructors
    NEW                : ClassRef -> Instruction
    NEWARRAY           : BaseTypeName -> Instruction
    ANEWARRAY          : ANewArrayArg -> Instruction
                       : ClassRef -> ANewArrayArg
                       : ArrayType -> ANewArrayArg
    MULTIANEWARRAY     : ArrayType * Int -> Instruction
    GETFIELD           : FieldRef -> Instruction
    PUTFIELD           : FieldRef -> Instruction
    GETSTATIC          : FieldRef -> Instruction
    PUTSTATIC          : FieldRef -> Instruction
    IALOAD             : Instruction
    LALOAD             : Instruction
    BALOAD             : Instruction
    CALOAD             : Instruction
    SALOAD             : Instruction
    FALOAD             : Instruction
    DALOAD             : Instruction
    AALOAD             : Instruction
    IASTORE            : Instruction
    LASTORE            : Instruction
    BASTORE            : Instruction
    CASTORE            : Instruction
    SASTORE            : Instruction
    FASTORE            : Instruction
    DASTORE            : Instruction
    AASTORE            : Instruction
    ARRAYLENGTH        : Instruction
    CHECKCAST          : ClassRef -> Instruction
    INSTANCEOF         : ClassRef -> Instruction

signature
  constructors
    POP               : Instruction
    POP2              : Instruction
    DUP               : Instruction
    DUP2              : Instruction
    DUP_X1            : Instruction
    DUP2_X1           : Instruction
    DUP_X2            : Instruction
    DUP2_X2           : Instruction
    SWAP              : Instruction

signature
  constructors
                   : string -> STRING
                   : string -> StringChar
                   : string -> HexDigit
    String         : STRING -> Constant

signature
  constructors
    MONITORENTER      : Instruction
    MONITOREXIT       : Instruction

signature
  constructors
    Byte                : BaseType
    Char                : BaseType
    Double              : BaseType
    Float               : BaseType
    Int                 : BaseType
    Long                : BaseType
    Short               : BaseType
    Boolean             : BaseType
                        : BaseType -> FieldType
                        : ArrayType -> FieldType
                        : FieldType -> ComponentType
    Array               : ComponentType -> ArrayType

signature
  constructors
     : string -> EOF

imports
  signatures/JasminXT-Whitespace-sig
  signatures/JasminXT-Header-sig
  signatures/JasminXT-Fields-sig
  signatures/JasminXT-Methods-sig


signature
  constructors
                       : JasminFile -> Start
    JBCFile            : JasminHeader * List(Field) * List(Method) -> JasminFile

imports
  signatures/-    // jasmin AST nodes
  libspoofax/sdf/pp // pp-* strategies
  gpp     // box language AST nodes
  pp/JasminXT-Descriptors-pp
  pp/JasminXT-Names-pp
  pp/JasminXT-Types-pp

imports
  signatures/-
  analysis/types/constraints

strategies
  // desugar = JBCMethod(id, id, id, map({\ x -> NamedInstruction(<new>, x) \}))

  desugar-all = id // alltd(desugar)

imports
  signatures/-
  analysis/types/constraints

rules
  analysis-builtin-partitions :: ? -> List(string * JasminFile)
  analysis-builtin-partitions:
        _ -> [ ( "String.class"
             , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC(), FINAL()], "java/lang/String")
  , JBCSuper("Ljava/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, [ JBCExtField(
      [STATIC(), PUBLIC()]
    , "CASE_INSENSITIVE_ORDER"
    , JBCFieldDesc(Reference(CRef("java/util/Comparator")))
    , None()
    , None()
    , []
    )
  ]
, [ JBCMethod([], Init(), JBCMethodDesc([], Void()), [])
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte())], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte()), Reference(CRef("java/nio/charset/Charset"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte()), Int()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte()), Int(), Int()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Array(Byte()), Int(), Int(), Reference(CRef("java/nio/charset/Charset"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte()), Int(), Int(), Int()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Array(Byte()), Int(), Int(), Reference(CRef("java/lang/String"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Byte()), Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Char())], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Char()), Int(), Int()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Array(Int()), Int(), Int()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/StringBuffer"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/StringBuilder"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "charAt"
    , JBCMethodDesc([Int()], Char())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "codePointAt"
    , JBCMethodDesc([Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "codePointBefore"
    , JBCMethodDesc([Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "codePointCount"
    , JBCMethodDesc([Int(), Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "compareTo"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "compareToIgnoreCase"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "concat"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "contains"
    , JBCMethodDesc([Reference(CRef("java/lang/CharSequence"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "contentEquals"
    , JBCMethodDesc([Reference(CRef("java/lang/CharSequence"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "contentEquals"
    , JBCMethodDesc([Reference(CRef("java/lang/StringBuffer"))], Boolean())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "copyValueOf"
    , JBCMethodDesc([Array(Char())], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "copyValueOf"
    , JBCMethodDesc(
        [Array(Char()), Int(), Int()]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "endsWith"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "equals"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "equalsIgnoreCase"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getBytes"
    , JBCMethodDesc([], Array(Byte()))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getBytes"
    , JBCMethodDesc([Reference(CRef("java/nio/charset/Charset"))], Array(Byte()))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getBytes"
    , JBCMethodDesc([Int(), Int(), Array(Byte()), Int()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getBytes"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Array(Byte()))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getChars"
    , JBCMethodDesc([Int(), Int(), Array(Char()), Int()], Void())
    , []
    )
  , JBCMethod([PUBLIC()], "hashCode", JBCMethodDesc([], Int()), [])
  , JBCMethod(
      [PUBLIC()]
    , "indexOf"
    , JBCMethodDesc([Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "indexOf"
    , JBCMethodDesc([Int(), Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "indexOf"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "indexOf"
    , JBCMethodDesc([Reference(CRef("java/lang/String")), Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "intern"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod([PUBLIC()], "isEmpty", JBCMethodDesc([], Boolean()), [])
  , JBCMethod(
      [PUBLIC()]
    , "lastIndexOf"
    , JBCMethodDesc([Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "lastIndexOf"
    , JBCMethodDesc([Int(), Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "lastIndexOf"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "lastIndexOf"
    , JBCMethodDesc([Reference(CRef("java/lang/String")), Int()], Int())
    , []
    )
  , JBCMethod([PUBLIC()], "length", JBCMethodDesc([], Int()), [])
  , JBCMethod(
      [PUBLIC()]
    , "matches"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "offsetByCodePoints"
    , JBCMethodDesc([Int(), Int()], Int())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "regionMatches"
    , JBCMethodDesc(
        [Boolean(), Int(), Reference(CRef("java/lang/String")), Int(), Int()]
      , Boolean()
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "regionMatches"
    , JBCMethodDesc(
        [Int(), Reference(CRef("java/lang/String")), Int(), Int()]
      , Boolean()
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "replace"
    , JBCMethodDesc([Char(), Char()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "replace"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/CharSequence")), Reference(CRef("java/lang/CharSequence"))]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "replaceAll"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/String"))]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "replaceFirst"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/String"))]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "split"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String"))]
      , Array(Reference(CRef("java/lang/String")))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "split"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Int()]
      , Array(Reference(CRef("java/lang/String")))
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "startsWith"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "startsWith"
    , JBCMethodDesc([Reference(CRef("java/lang/String")), Int()], Boolean())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "subSequence"
    , JBCMethodDesc([Int(), Int()], Reference(CRef("java/lang/CharSequence")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "substring"
    , JBCMethodDesc([Int()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "substring"
    , JBCMethodDesc([Int(), Int()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toCharArray"
    , JBCMethodDesc([], Array(Char()))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toLowerCase"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toLowerCase"
    , JBCMethodDesc([Reference(CRef("java/util/Locale"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toString"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toUpperCase"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toUpperCase"
    , JBCMethodDesc([Reference(CRef("java/util/Locale"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "trim"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Boolean()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Char()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Array(Char())], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc(
        [Array(Char()), Int(), Int()]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Double()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Float()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Int()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Long()], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "valueOf"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Reference(CRef("java/lang/String")))
    , []
    )
  ]
)
             )
           , ( "Object.class"
             , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC()], "java/lang/Object")
  , JBCSuper("java/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, []
, [ JBCMethod([], Init(), JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PROTECTED()]
    , "clone"
    , JBCMethodDesc([], Reference(CRef("java/lang/Object")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "equals"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Boolean())
    , []
    )
  , JBCMethod([PROTECTED()], "finalize", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "getClass"
    , JBCMethodDesc([], Reference(CRef("java/lang/Class")))
    , []
    )
  , JBCMethod([PUBLIC()], "hashCode", JBCMethodDesc([], Int()), [])
  , JBCMethod([PUBLIC()], "notify", JBCMethodDesc([], Void()), [])
  , JBCMethod([PUBLIC()], "notifyAll", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "toString"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod([PUBLIC()], "wait", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "wait"
    , JBCMethodDesc([Long()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "wait"
    , JBCMethodDesc([Long(), Int()], Void())
    , []
    )
  ]
)
               )
             , ( "System.class"
               , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC(), FINAL()], "java/lang/System")
  , JBCSuper("Ljava/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, [ JBCExtField(
      [STATIC(), PUBLIC()]
    , "err"
    , JBCFieldDesc(Reference(CRef("java/io/PrintStream")))
    , None()
    , None()
    , []
    )
  , JBCExtField(
      [STATIC(), PUBLIC()]
    , "in"
    , JBCFieldDesc(Reference(CRef("java/io/InputStream")))
    , None()
    , None()
    , []
    )
  , JBCExtField(
      [STATIC(), PUBLIC()]
    , "out"
    , JBCFieldDesc(Reference(CRef("java/io/PrintStream")))
    , None()
    , None()
    , []
    )
  ]
, [ JBCMethod(
      [STATIC(), PUBLIC()]
    , "arraycopy"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/Object")), Int(), Reference(CRef("java/lang/Object")), Int(), Int()]
      , Void()
      )
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "clearProperty"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "console"
    , JBCMethodDesc([], Reference(CRef("java/io/Console")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "currentTimeMillis"
    , JBCMethodDesc([], Long())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "exit"
    , JBCMethodDesc([Int()], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "gc"
    , JBCMethodDesc([], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getenv"
    , JBCMethodDesc([], Reference(CRef("java/util/Map")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getenv"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getProperties"
    , JBCMethodDesc([], Reference(CRef("java/util/Properties")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getProperty"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getProperty"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/String"))]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "getSecurityManager"
    , JBCMethodDesc([], Reference(CRef("java/lang/SecurityManager")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "identityHashCode"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Int())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "inheritedChannel"
    , JBCMethodDesc([], Reference(CRef("java/nio/channels/Channel")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "lineSeparator"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "load"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "loadLibrary"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "mapLibraryName"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "nanoTime"
    , JBCMethodDesc([], Long())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "runFinalization"
    , JBCMethodDesc([], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "runFinalizersOnExit"
    , JBCMethodDesc([Boolean()], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setErr"
    , JBCMethodDesc([Reference(CRef("java/io/PrintStream"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setIn"
    , JBCMethodDesc([Reference(CRef("java/io/InputStream"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setOut"
    , JBCMethodDesc([Reference(CRef("java/io/PrintStream"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setProperties"
    , JBCMethodDesc([Reference(CRef("java/util/Properties"))], Void())
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setProperty"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/String"))]
      , Reference(CRef("java/lang/String"))
      )
    , []
    )
  , JBCMethod(
      [STATIC(), PUBLIC()]
    , "setSecurityManager"
    , JBCMethodDesc([Reference(CRef("java/lang/SecurityManager"))], Void())
    , []
    )
  ]
)
               )
             , ( "PrintStream.class"
               , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC()], "java/io/PrintStream")
  , JBCSuper("Ljava/io/FilterOutputStream")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, [ JBCExtField(
      [PUBLIC()]
    , "out"
    , JBCFieldDesc(Reference(CRef("java/io/OutputStream")))
    , None()
    , None()
    , []
    )
  ]
, [ JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/io/File"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/io/File")), Reference(CRef("java/lang/String"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/io/OutputStream"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/io/OutputStream")), Boolean()], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/io/OutputStream")), Boolean(), Reference(CRef("java/lang/String"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/String"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "append"
    , JBCMethodDesc([Char()], Reference(CRef("java/io/PrintStream")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "append"
    , JBCMethodDesc([Reference(CRef("java/lang/CharSequence"))], Reference(CRef("java/io/PrintStream")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "append"
    , JBCMethodDesc(
        [Reference(CRef("java/lang/CharSequence")), Int(), Int()]
      , Reference(CRef("java/io/PrintStream"))
      )
    , []
    )
  , JBCMethod([PUBLIC()], "checkError", JBCMethodDesc([], Boolean()), [])
  , JBCMethod([PROTECTED()], "clearError", JBCMethodDesc([], Void()), [])
  , JBCMethod([PUBLIC()], "close", JBCMethodDesc([], Void()), [])
  , JBCMethod([PUBLIC()], "flush", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Boolean()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Char()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Array(Char())], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Double()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Float()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Int()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Long()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "print"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod([PUBLIC()], "println", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Boolean()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Char()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Array(Char())], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Double()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Float()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Int()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Long()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Reference(CRef("java/lang/Object"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "println"
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod([PROTECTED()], "setError", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "write"
    , JBCMethodDesc([Array(Byte()), Int(), Int()], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "write"
    , JBCMethodDesc([Int()], Void())
    , []
    )
  ]
)
               )
             , ( "Exception.class"
               , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC()], "java/lang/Exception")
  , JBCSuper("java/lang/Throwable")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, []
, [ JBCMethod([], Init(), JBCMethodDesc([], Void()), [])
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/Throwable"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/Throwable")), Boolean(), Boolean()]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/Throwable"))], Void())
    , []
    )
  ]
)
               )
             , ( "Throwable.class"
               , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC()], "java/lang/Throwable")
  , JBCSuper("java/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, []
, [ JBCMethod([], Init(), JBCMethodDesc([], Void()), [])
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/String"))], Void())
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/Throwable"))]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc(
        [Reference(CRef("java/lang/String")), Reference(CRef("java/lang/Throwable")), Boolean(), Boolean()]
      , Void()
      )
    , []
    )
  , JBCMethod(
      []
    , Init()
    , JBCMethodDesc([Reference(CRef("java/lang/Throwable"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "addSuppressed"
    , JBCMethodDesc([Reference(CRef("java/lang/Throwable"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "fillInStackTrace"
    , JBCMethodDesc([], Reference(CRef("java/lang/Throwable")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getCause"
    , JBCMethodDesc([], Reference(CRef("java/lang/Throwable")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getLocalizedMessage"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getMessage"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getStackTrace"
    , JBCMethodDesc([], Array(Reference(CRef("java/lang/StackTraceElement"))))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "getSuppressed"
    , JBCMethodDesc([], Array(Reference(CRef("java/lang/Throwable"))))
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "initCause"
    , JBCMethodDesc([Reference(CRef("java/lang/Throwable"))], Reference(CRef("java/lang/Throwable")))
    , []
    )
  , JBCMethod([PUBLIC()], "printStackTrace", JBCMethodDesc([], Void()), [])
  , JBCMethod(
      [PUBLIC()]
    , "printStackTrace"
    , JBCMethodDesc([Reference(CRef("java/io/PrintStream"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "printStackTrace"
    , JBCMethodDesc([Reference(CRef("java/io/PrintWriter"))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "setStackTrace"
    , JBCMethodDesc([Array(Reference(CRef("java/lang/StackTraceElement")))], Void())
    , []
    )
  , JBCMethod(
      [PUBLIC()]
    , "toString"
    , JBCMethodDesc([], Reference(CRef("java/lang/String")))
    , []
    )
  ]
)
               )
             , ( "Enumeration.class"
               , JBCFile(
  JBCHeader(
    None()
  , None()
  , JBCClass([PUBLIC()], "java/util/Enumeration")
  , JBCSuper("java/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  )
, []
, [ JBCMethod([PUBLIC()], "hasMoreElements", JBCMethodDesc([], Boolean()), [])
  , JBCMethod(
      [PUBLIC()]
    , "nextElement"
    , JBCMethodDesc([], Reference(CRef("java/lang/Object")))
    , []
    )
  ]
)
               )
             ]


imports
  signatures/-
  analysis/types/constraints
  names/analysis/names/binding
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  gpp
  src-gen/pp/-

strategies

  nabl-check-disable-duplicate(|uri, ns) = id
  nabl-check-disable-hiding(|uri, ns) = id
  nabl-check-disable-unresolved = id

  html-escape :: ? -> string
  html-escape = is-string ; string-replace(|"&", "&amp;") ; string-replace(|"<", "&lt;") ; string-replace(|">", "&gt;")

  abox2text :: Box -> string
  abox2text = box2text-string(|10000)
  pp-ClassName :: ClassName -> string
  pp-ClassName  = strip-annos ; prettyprint-jasmin-ClassName  ; abox2text <+ !"PRETTYPRINTFAILURE"
  pp-MethodName :: MethodName -> string
  pp-MethodName = strip-annos ; prettyprint-jasmin-MethodName ; abox2text; html-escape <+ !"PRETTYPRINTFAILURE"
  pp-FieldName :: FieldName -> string
  pp-FieldName  = strip-annos ; prettyprint-jasmin-FieldName  ; abox2text <+ !"PRETTYPRINTFAILURE"
  pp-ParameterDescriptors :: List(ParameterDescriptor) -> string
  pp-ParameterDescriptors = map(prettyprint-jasmin-ParameterDescriptor ; abox2text);concat-strings <+ !"PRETTYPRINTFAILURE"
  pp-ReturnDescriptor :: ReturnDescriptor -> string
  pp-ReturnDescriptor = prettyprint-jasmin-ReturnDescriptor ; abox2text <+ !"PRETTYPRINTFAILURE"

rules
  // Undefined reference errors
  nabl-constraint(|ctx):
    CRef(c) -> <fail>
      where
        not(<is-string;string-starts-with(|"java/")> c)
      where
        <has-annotation(?Use(task))> c
      ; msg  := $[Class [<pp-ClassName> c] is undefined]
      ; <task-create-error-on-failure(|ctx, task, msg)> c

  nabl-constraint(|ctx):
    JBCSuper(c) -> <fail>
      where
        not(<is-string;string-starts-with(|"java/")> c)
      where
        <has-annotation(?Use(task))> c
      ; msg  := $[Class [<pp-ClassName> c] is undefined]
      ; <task-create-error-on-failure(|ctx, task, msg)> c

  nabl-constraint(|ctx):
    JBCMethodRef(CRef(c), MRef(m), _) -> <fail>
      where
        not(<is-string;string-starts-with(|"java/")> c)
      where
        <has-annotation(?Use(task))> m
      ; msg  := $[Method [<pp-MethodName> m] is undefined]
      ; <task-create-error-on-failure(|ctx, task, msg)> m

  nabl-constraint(|ctx):
    JBCFieldRef(CRef(c), FRef(f), _) -> <fail>
      where
        not(<is-string;string-starts-with(|"java/")> c)
      where
        <has-annotation(?Use(task))> f
      ; msg  := $[Field [<pp-FieldName> f] is undefined]
      ; <task-create-error-on-failure(|ctx, task, msg)> f

  // Double names
  nabl-constraint(|ctx):
    JBCClass(_, c) -> <fail>
      where
        task := <nabl-lookup-all(|ctx)> c
      ; msg := $[Class [<pp-ClassName> c] was already defined]
      ; <task-create-error-on-multiple(|ctx, task, msg)> c

  nabl-constraint(|ctx):
    JBCMethod(_, m, type-desc@JBCMethodDesc(pd*, rd), _) -> <fail>
      where
        task := <nabl-lookup-lexical(|ctx, NablNsMethod())> m
      ; type := <type-lookup(|ctx)> task
      ; type-match := <type-match(|ctx, type-desc)> type
      ; msg := $[Method [<pp-MethodName> m]([<pp-ParameterDescriptors> pd*])[<pp-ReturnDescriptor> rd] was already defined]
      // TODO: This type-match task inexplicably comes up with many many method with the same descriptor.
      // ; <task-create-error-on-multiple(|ctx, type-match, msg)> m

  nabl-constraint(|ctx):
    JBCField(_, f, _, _, _) -> <fail>
      where
        task := <nabl-lookup-lexical(|ctx, NablNsField())> f
      ; msg := $[Field [<pp-FieldName> f] was already defined]
      ; <task-create-error-on-multiple(|ctx, task, msg)> f


imports
  signatures/-

rules

  class-name :: JasminFile -> ClassName
  class-name: JBCFile(JBCHeader(_, _, JBCClass(_, name), _, _, _, _, _, _, _), _, _) -> name


imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/match-Instruction
  analysis/types/complex-constraints/-

rules
  // Deprecated: legacy name
  stack-constraints(|?, ClassName) :: ? -> List(Constraint)
  stack-constraints(|ctx, classname) = collect-constraints(|ctx, classname)

  collect-constraints(|?, ClassName) :: ? -> List(Constraint)
  collect-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(_,r), []) -> [CEq(r, Void())]
  collect-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(p,r), l) -> [st-start, push-pop*, next*, cc*, reg-start, reg-next*]
    where l'@[h|t] := <filter(match-Instruction)> l
      ; h-in  := <get-in-stack>  h
        ; h-out := <get-out-stack> h
        ; next* := <foldl(next-constraints(|ctx));Snd> (t, (h-out, []))
        ; (cc*,todo) := <partition(complex-constraints(|r));(concat,id)> l'

      ; st-start := CEq(TypeVar(h-in), [])
        ; push-pop* := <filter(push-pop-constraints);concat> todo

        ; locals-start := ([ Reference(CRef(classname)) | p ], [])
        ; reg-start := CEq(<var-rename-hack> TypeVar(h-in), locals-start)
        ; reg-next* := <alltd(var-rename-hack)> next*
        // TODO: handle limits in constraints.
          // limit locals can be done with a single constraint wherever it is found, setting the locals CSub of [TOP(), ..., TOP()] of the size given in the limit locals phrase
          // limit stack may need intelligent constaints on every in/out stack.. Not sure yet how to solve this

  push-pop-constraints :: Instruction -> List(Constraint)
  push-pop-constraints: instr -> [n*,nr*]
    where push* := <push-type> instr
        ; pop*  := <pop-type> instr
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
        ; n*    := [ CEq(TypeVar(i-out), (push*, rest)), CEq(TypeVar(i-in), (pop*, rest)) ]
        ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  pop-type :: ? -> List(Type)
  pop-type = get-pop-type;not(?[])
  push-type :: ? -> List(Type)
  push-type = get-push-type;not(?[])

  next-constraints(|?) :: Instruction * (string * List(Constraint)) -> string * List(Constraint)
  next-constraints(|ctx): (instr, (prev-out, c*)) -> (<get-out-stack> instr, [c*, n*])
    where i-in := <get-in-stack> instr
        ; n* := <next-instr;map(next-helper(|ctx, prev-out, i-in))> instr

  next-helper(|?, string, string) :: Target -> Constraint
  next-helper(|ctx,prev-out,i-in) = \NEXT() -> CEq(TypeVar(prev-out),TypeVar(i-in))\
                                 <+ \LabelRef(l) -> CEq(TypeVar(prev-out),TypeVar(<get-in-stack> l))\
  next-instr :: ? -> List(Target)
  next-instr = get-next-instr <+ ![NEXT()]

  complex-constraints(|FieldType) :: Instruction -> List(Constraint)
  complex-constraints(|ret) = complex-constraint(|ret) <+ complex-constraint



imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  cc-r-match-int(|int) :: ? -> List(FieldType) * Type
  cc-r-match-int(|at) = where( rest := <fresh-var>
      ; first  := <safe-repeat(![<fresh-var> | <id>] | <dec> at)> [Int()])
    ; !(first, rest)

  // IINC and IINC_W
  complex-constraint :: Instruction -> List(Constraint)
  complex-constraint: instr@name#([VarNum(vn), _]) -> [nc*, nr*]
    where <string-starts-with(|"IINC")> name
    with i-in  := <get-in-stack> instr
       ; i-out := <get-out-stack> instr
       ; vn'   := <is-string;dec-string-to-int> vn
       ; stack := <cc-r-match-int(|vn')>
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in),  stack) // pop-reg-type
                  , CEq(<var-rename-hack> TypeVar(i-out), stack) // push-reg-type
                  ]
       ; nc*   := [ CEq(TypeVar(i-in), TypeVar(i-out)) ]

imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint: instr@ATHROW() -> [n*, nr*]
    with cref  := Reference(CRef("java/lang/Object"))
       ; i-in  := <get-in-stack> instr
       ; i-out := <get-out-stack> instr
       ; n* := [ CSub(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
               , CSub(TypeVar(i-out), [cref])               // push-type
               ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]

imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint: instr@name#([JBCMethodRef(cref, _, JBCMethodDesc(p, r))]) -> [n*,nr*]
    where (!"INVOKESPECIAL" => name + !"INVOKEVIRTUAL" => name + !"INVOKEINTERFACE" => name)
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack> instr
       ; rest  := <fresh-var>
       ; class-type := Reference(cref)
       ; out-stack := <try(?([Void()],<id>))> ([r], rest)
       ; n* := [ CSub(TypeVar(i-in), (<reverse> [class-type|p], rest))   // pop-type
               , CSub(TypeVar(i-out), out-stack)                       ] // push-type
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]

  complex-constraint: instr@INVOKESTATIC(JBCMethodRef(_, _, JBCMethodDesc(p, r))) -> [n*,nr*]
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack> instr
       ; rest  := <fresh-var>
       ; ret-type := <try(\[Void()] -> []\)> [r]
       ; n* := [ CSub(TypeVar(i-in), (<reverse> p, rest))   // pop-type
               , CSub(TypeVar(i-out), (ret-type, rest))   ] // push-type
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]

  cc-return(|ReturnDescriptor, ReturnDescriptor) :: Instruction -> List(Constraint)
  cc-return(|r, type): instr -> [n*,nr*]
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack> instr
       ; rest  := <fresh-var>
       ; ret-type := <try(\[Void()] -> []\)> [r]
       ; n* := [ CEq(TypeVar(i-out), [])              // push-type
               , CEq(TypeVar(i-out), rest)
               , CEq(TypeVar(i-in), (ret-type, rest)) // pop-type
               , CEq(r, type) ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint(|ReturnDescriptor) :: Instruction -> List(Constraint)
  complex-constraint(|r): RETURN()  -> <cc-return(|r, Void())>
  complex-constraint(|r): IRETURN() -> <cc-return(|r, Int())>
  complex-constraint(|r): LRETURN() -> <cc-return(|r, Long())>
  complex-constraint(|r): FRETURN() -> <cc-return(|r, Float())>
  complex-constraint(|r): DRETURN() -> <cc-return(|r, Double())>
  complex-constraint(|r): instr@ARETURN() -> [n*,nr*]
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; classtype := Reference(CRef("java/lang/Object"))
        ; n* := [ CEq(TypeVar(i-out), [])                 // push-type
                , CEq(TypeVar(i-out), rest)
                , CSub(TypeVar(i-in), ([classtype], rest)) // pop-type
                , CSub(classtype, r) ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]

imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  // treat *LOAD_#() and *STORE_#() as *LOAD(#) and *STORE(#) resp.
  complex-constraint: instr -> <complex-constraint> instr'
    where instr' := <preserve-annos(
      \name#([]) -> name'#([VarNum(i)])
        where (name', i) := <split-after;(rtrim-chars(?'_'),id)> (name, "_")
            ; <string-ends-with(|"STORE") + string-ends-with(|"LOAD")> name'\
    )> instr

  cc-r-match(|int, FieldType) :: string -> Constraint
  cc-r-match(|at, var): i-in -> CEq(<var-rename-hack> TypeVar(i-in), (first, rest))
    with rest   := <fresh-var>
       ; first  := <safe-repeat(![<fresh-var> | <id>] | <dec> at)> [var]
  cc-r-subst(|int, FieldType) :: string * string -> List(Constraint)
  cc-r-subst(|at, var): (i-in, i-out) ->
      [ CEq(<var-rename-hack> TypeVar(i-in),  (f-i-in, rest))
      , CEq(<var-rename-hack> TypeVar(i-out), (fSubst, rest)) ]
    with rest   := <fresh-var>
       ; first  := <safe-repeat(![<fresh-var> | <id>] | <dec> at)> []
       ; f-i-in := <conc> (first, [<fresh-var>])
       ; fSubst := <conc> (first, [var])

  complex-constraint: instr@name#([VarNum(vn)]) -> [nc*, nr*]
    where <string-starts-with(|"ALOAD")> name
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack>  instr
       ; class-type := Reference(CRef("java/lang/Object"))
       ; vn'   := <dec-string-to-int> vn
       ; var   := <fresh-var>
       ; nrm   := <cc-r-match(|vn', var)> i-in
       ; nr*   := [ nrm
                  , CSub(var, class-type)
                  , CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out))
                  ]
       ; rest  := <fresh-var>
       ; nc*   := [ CEq(TypeVar(i-out), ([var], rest))   // push-type
                  , CEq(TypeVar(i-in), rest)           ]

  complex-constraint: instr@name#([VarNum(vn)]) -> [nc*, nr*]
    where <string-starts-with(|"ASTORE")> name
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack>  instr
       ; var   := <fresh-var>
       ; rest  := <fresh-var>
       ; class-type := Reference(CRef("java/lang/Object"))
       ; nc*   := [ CEq(TypeVar(i-in), ([var], rest))
                  , COr([ [CSub(var, class-type)] // pop-type
                        , [CEq (var, ADDRESS() )] // pop-type
                        ])
                  , CEq(TypeVar(i-out), rest)
                  ]
       ; vn'   := <dec-string-to-int> vn
       ; nr*   := <cc-r-subst(|vn', var)> (i-in, i-out)

  cc-load-helper(|FieldType, string) :: Instruction -> List(Constraint)
  cc-load-helper(|type, vn): instr -> [nc*, nr*]
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack>  instr
       ; rest  := <fresh-var>
       ; vn'   := <dec-string-to-int> vn
       ; nr*   := [ <cc-r-match(|vn', type)> i-in
                  , CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
       ; nc*   := [ CEq(TypeVar(i-out), ([type],rest))   // push-type
                  , CEq(TypeVar(i-in), rest)           ]

  cc-store-helper(|FieldType, string) :: Instruction -> List(Constraint)
  cc-store-helper(|type, vn): instr -> [nc*, nr*]
    with i-out := <get-out-stack> instr
       ; i-in  := <get-in-stack>  instr
       ; rest  := <fresh-var>
       ; nc*   := [ CEq(TypeVar(i-in), ([type], rest))   // pop-type
                  , CEq(TypeVar(i-out), rest)          ]
       ; vn'   := <dec-string-to-int> vn
       ; nr*   := <cc-r-subst(|vn', type)> (i-in, i-out)


  complex-constraint: DLOAD (VarNum(vn)) -> <cc-load-helper (|Double(), <is-string> vn)>
  complex-constraint: DSTORE(VarNum(vn)) -> <cc-store-helper(|Double(), <is-string> vn)>
  complex-constraint: FLOAD (VarNum(vn)) -> <cc-load-helper (|Float() , <is-string> vn)>
  complex-constraint: FSTORE(VarNum(vn)) -> <cc-store-helper(|Float() , <is-string> vn)>
  complex-constraint: ILOAD (VarNum(vn)) -> <cc-load-helper (|Int()   , <is-string> vn)>
  complex-constraint: ISTORE(VarNum(vn)) -> <cc-store-helper(|Int()   , <is-string> vn)>
  complex-constraint: LLOAD (VarNum(vn)) -> <cc-load-helper (|Long()  , <is-string> vn)>
  complex-constraint: LSTORE(VarNum(vn)) -> <cc-store-helper(|Long()  , <is-string> vn)>


imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint: instr@AALOAD() -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef("java/lang/Object"))
        ; array-type := Array(<fresh-var>)
      ; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(class-type)], rest))   // pop-type
                     , CSub(TypeVar(i-out), ([class-type],rest))              ] // push-type
                   , [ CEq(TypeVar(i-in), ([Int(), Array(array-type)], rest))   // pop-type
                     , CEq(TypeVar(i-out), ([array-type],rest))               ] // push-type
                   ])]
  complex-constraint: instr@AASTORE() -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef("java/lang/Object"))
        ; array-type := Array(<fresh-var>)
      ; n* := [COr([ [ CSub(TypeVar(i-in), ([class-type, Int(), Array(class-type)], rest)) ] // pop-type
                   , [ CEq(TypeVar(i-in), ([array-type, Int(), Array(array-type)], rest))  ] // pop-type
                   ])]
  complex-constraint: instr@BALOAD() -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
      ; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(Boolean())], rest))   // pop-type
                     , CEq(TypeVar(i-out), ([Boolean()],rest))               ] // push-type
                   , [ CEq(TypeVar(i-in), ([Int(), Array(Byte())], rest))   // pop-type
                     , CEq(TypeVar(i-out), ([Byte()],rest))               ] // push-type
                   ])]
  complex-constraint: instr@BASTORE() -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
      ; n* := [COr([ [ CEq(TypeVar(i-in), ([Boolean(), Int(), Array(Boolean())], rest)) ] // pop-type
                   , [ CEq(TypeVar(i-in), ([Byte(), Int(), Array(Byte())], rest)) ]       // pop-type
                   ])]

  cc-aload-helper(|FieldType) :: Instruction -> List(Constraint)
  cc-aload-helper(|type): instr -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in), ([Int(), Array(type)], rest))   // pop-type
                , CEq(TypeVar(i-out), ([type],rest))               ] // push-type
  cc-astore-helper(|FieldType) :: Instruction -> List(Constraint)
  cc-astore-helper(|type): instr -> n*
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in), ([type, Int(), Array(type)], rest))   // pop-type
              , CEq(TypeVar(i-out), rest)                              ] // push-type
  complex-constraint: CALOAD()  -> <cc-aload-helper (|Char()  )>
  complex-constraint: CASTORE() -> <cc-astore-helper(|Char()  )>
  complex-constraint: DALOAD()  -> <cc-aload-helper (|Double())>
  complex-constraint: DASTORE() -> <cc-astore-helper(|Double())>
  complex-constraint: FALOAD()  -> <cc-aload-helper (|Float() )>
  complex-constraint: FASTORE() -> <cc-astore-helper(|Float() )>
  complex-constraint: IALOAD()  -> <cc-aload-helper (|Int()   )>
  complex-constraint: IASTORE() -> <cc-astore-helper(|Int()   )>
  complex-constraint: LALOAD()  -> <cc-aload-helper (|Long()  )>
  complex-constraint: LASTORE() -> <cc-astore-helper(|Long()  )>
  complex-constraint: SALOAD()  -> <cc-aload-helper (|Short() )>
  complex-constraint: SASTORE() -> <cc-astore-helper(|Short() )>

  complex-constraint: instr@CHECKCAST(_) -> n*
    where cref  := Reference(CRef("java/lang/Object"))
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
      ; n* := [ CSub(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
              , CEq(TypeVar(i-out), TypeVar(i-in))         // push-type
              ]

imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint: instr@POP() -> [n*,nr*]
    where type@TypeVar(type') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in),  ([type], rest)) // pop-type
              , CNEq(TypeVar(type'), Double())
              , CNEq(TypeVar(type'), Long())
              , CEq(TypeVar(i-out), rest)           // push-type
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@POP2() -> [n*,nr*]
    where type@TypeVar(type') := <fresh-var>
        ; type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type], rest))         // pop-type
                      , COr([ [ CEq(TypeVar(type'), Double()) ]
                            , [ CEq(TypeVar(type'), Long()) ]
                            ])
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2], rest)) // pop-type
                      , CNEq(TypeVar(type1'), Double())
                        , CNEq(TypeVar(type1'), Long())
                      , CNEq(TypeVar(type2'), Double())
                        , CNEq(TypeVar(type2'), Long())
                      ]
                    ])
              , CEq(TypeVar(i-out), rest)                           // push-type
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP() -> [n*,nr*]
    where type@TypeVar(type') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
              , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
              , CNEq(TypeVar(type'), Double())
              , CNEq(TypeVar(type'), Long())
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP2() -> [n*,nr*]
    where type@TypeVar(type')  := <fresh-var>
        ; type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
                      , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
                      , COr([ [ CEq(TypeVar(type'), Double()) ]
                            , [ CEq(TypeVar(type'), Long()) ]
                            ])
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2], rest))               // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type1, type2], rest)) // push-type
                      , CNEq(TypeVar(type1'), Double())
                        , CNEq(TypeVar(type1'), Long())
                      , CNEq(TypeVar(type2'), Double())
                        , CNEq(TypeVar(type2'), Long())
                      ]
                    ])
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP_X1() -> [n*,nr*]
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
              , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
              , CNEq(TypeVar(type1'), Double())
              , CNEq(TypeVar(type1'), Long())
              , CNEq(TypeVar(type2'), Double())
              , CNEq(TypeVar(type2'), Long())
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP2_X1() -> [n*,nr*]
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(type2'), Double())
                , CEq(TypeVar(type2'), Long())
                , COr([ [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
                      , COr([ [ CEq(TypeVar(type1), Double()) ]
                            , [ CEq(TypeVar(type1), Long()) ]
                            ])
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
                      , CNEq(TypeVar(type1'), Double())
                        , CNEq(TypeVar(type1'), Long())
                      , CNEq(TypeVar(type3'), Double())
                        , CNEq(TypeVar(type3'), Long())
                      ]
                    ])
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP_X2() -> [n*,nr*]
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(type1'), Double())
                , CEq(TypeVar(type1'), Long())
                , COr( [ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
                       , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
                       , CNEq(TypeVar(type2'), Double())
                       , CNEq(TypeVar(type2'), Long())
                       , CNEq(TypeVar(type3'), Double())
                       , CNEq(TypeVar(type3'), Long())
                       ]
                     , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
                       , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
                       , COr([ [ CEq(TypeVar(type2'), Double()) ]
                             , [ CEq(TypeVar(type2'), Long())   ]
                             ])
                       ]
                     ])
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@DUP2_X2() -> [n*,nr*]
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; type4@TypeVar(type4') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
                      , COr([ [ CEq(TypeVar(type1'), Double()) ]
                            , [ CEq(TypeVar(type1'), Long()) ]
                            ])
                      , CNEq(TypeVar(type2'), Double())
                        , CNEq(TypeVar(type2'), Long())
                      , CNEq(TypeVar(type3'), Double())
                        , CNEq(TypeVar(type3'), Long())
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
                      , COr([ [ CEq(TypeVar(type1'), Double()) ]
                            , [ CEq(TypeVar(type1'), Long()) ]
                            ])
                      , COr([ [ CEq(TypeVar(type2'), Double()) ]
                            , [ CEq(TypeVar(type2'), Long()) ]
                            ])
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
                      , CNEq(TypeVar(type1'), Double())
                        , CNEq(TypeVar(type1'), Long())
                      , CNEq(TypeVar(type2'), Double())
                        , CNEq(TypeVar(type2'), Long())
                      , COr([ [ CEq(TypeVar(type3'), Double()) ]
                            , [ CEq(TypeVar(type3'), Long()) ]
                            ])
                      ]
                    , [ CEq(TypeVar(i-in),  ([type1, type2, type3, type4], rest))               // pop-type
                      , CEq(TypeVar(i-out), ([type1, type2, type3, type4, type1, type2], rest)) // push-type
                      , CNEq(TypeVar(type1'), Double())
                        , CNEq(TypeVar(type1'), Long())
                      , CNEq(TypeVar(type2'), Double())
                        , CNEq(TypeVar(type2'), Long())
                      , CNEq(TypeVar(type3'), Double())
                        , CNEq(TypeVar(type3'), Long())
                      , CNEq(TypeVar(type4'), Double())
                        , CNEq(TypeVar(type4'), Long())
                      ]
                    ])
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@SWAP() -> [n*,nr*]
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest)) // pop-type
              , CEq(TypeVar(i-out), ([type2, type1], rest)) // push-type
              , CNEq(TypeVar(type1'), Double())
              , CNEq(TypeVar(type1'), Long())
              , CNEq(TypeVar(type2'), Double())
              , CNEq(TypeVar(type2'), Long())
              ]
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]

imports
  signatures/-
  names/analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint: instr@MONITORENTER() -> [n*,nr*]
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CSub(TypeVar(i-in), ([Reference(CRef("java/lang/Object"))],rest))   // pop-type
              , CEq(TypeVar(i-out), rest)                                         ] // push-type
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]
  complex-constraint: instr@MONITOREXIT() -> [n*,nr*]
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
        ; rest  := <fresh-var>
      ; n* := [ CSub(TypeVar(i-in), [Reference(CRef("java/lang/Object"))])   // pop-type
              , CEq(TypeVar(i-out), rest)                                  ] // push-type
       ; nr*   := [ CEq(<var-rename-hack> TypeVar(i-in), <var-rename-hack> TypeVar(i-out)) ]


signature
  constructors
    TOP    : Type
    BOTTOM : Type

    ADDRESS : Type

    // NamedInstruction : String * Instruction -> PCInstruction

           : Type -> FieldType

    // refering to the next line
    NEXT   : Target

    // Constraints for instructions
            : string -> TypeVar
    TypeVar : TypeVar -> Type
            : List(Type) -> Stack
            : Stack -> Type
    CEq     : ? * ? -> Constraint
    CNEq    : ? * ? -> Constraint
    CSub    : ? * ? -> Constraint
    CSup    : ? * ? -> Constraint
    COr     : List(List(Constraint)) -> Constraint
    : ObjectType -> Type
    : List(Type) -> Type

    // The variable has the same value as the variable with the name it contains
    Alias   : string -> Type

strategies
  fresh-var :: ? -> Type
  fresh-var = !TypeVar(<new>)

  var-rename-hack :: Type -> Type
  var-rename-hack: TypeVar(string) -> TypeVar(string') // Bug: note how aliases don't work here
    where <string-starts-with(|"in") + string-starts-with(|"out")> string
        ; string' := $[[string]-locals]

  // repeat that checks against negative numbers
  safe-repeat(a -> a | int) :: a -> a
  safe-repeat(s | n) =
    if <leq>(n, 0)
    then
      id
    else
      s; repeat(s|<dec>n)
    end

imports
  signatures/-
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/analysis/types/-
  trans/analysis/names/-

rules
  solve-test-constraints :: ? -> List(?)
  solve-test-constraints: x -> ["Equality", eq*, "Subtyping", sub*, "Or", or*, "inequality", notEq*, "complex", complex*, "stack", stack*, "real", real*]
    where eq* := <solve-eq-test-constraints> x
      ; sub* := <solve-sub-test-constraints> x
      ; or* := <solve-or-test-constraints> x
      ; notEq* := <solve-not-test-constraints> x
      ; complex* := [] // TODO testcases
      ; stack* := <solve-stack-test-constraints> x
      ; real* := <solve-real-test-constraints> x

rules
  solve-eq-test-constraints :: ? -> List(?)
  solve-eq-test-constraints: _ -> [a, b, c, d, e, f, g, h, i, j, k, l]
    where a := <try(solve-constraints)> [] // empty list
      ; b := <try(solve-constraints)> [CEq(TypeVar("test"), [])] // one element in list
      ; c := <try(solve-constraints)> [CEq(TypeVar("test"), []), // two elements in list
                         CEq(TypeVar("test2"), [])]
      ; d := <try(solve-constraints)> [CEq(TypeVar("test"), [Int()]), // two elements, one dependency
                         CEq(TypeVar("test2"), []),
                         CEq(TypeVar("abc"), TypeVar("test"))]
      ; e := <try(solve-constraints)> [CEq(TypeVar("abc"), TypeVar("test")), // one dependency two elements
                         CEq(TypeVar("test"), []),
                         CEq(TypeVar("test2"), [])]
      ; f := <try(solve-constraints)> [CEq(TypeVar("cyclic"), TypeVar("failure")), // cyclic dependency
                         CEq(TypeVar("test2"), []),
                         CEq(TypeVar("failure"), TypeVar("cyclic"))]
      ; g := <try(solve-constraints)> [CEq(TypeVar("test"), TypeVar("abc")), // cyclic dependency solved with multi-ceq
                         CEq(TypeVar("test2"), []),
                         CEq(TypeVar("abc"), TypeVar("test")),
                         CEq(TypeVar("abc"), [])]
      ; h := <try(solve-constraints)> [CEq(TypeVar("failure"), Int()), // conflicting values for the same variable
                         CEq(TypeVar("failure"), [])]
      ; i := <try(solve-constraints)> [CEq([TypeVar("a"), TypeVar("b")], [Int(), Int()])]
      ; j := <try(solve-constraints)> [CEq(Array(TypeVar("a")), Array(Int()))]
      ; k := <try(solve-constraints)> [CEq(TypeVar("a"), Int()),
                         CEq(TypeVar("a"), TypeVar("b"))]
      ; l := <try(solve-constraints)> [CEq(TypeVar("a"), Int()),
                         CEq(TypeVar("b"), TypeVar("a"))]


  solve-sub-test-constraints :: ? -> List(?)
  solve-sub-test-constraints: _ -> [a, b, c, d, e, f]
    where a := <try(solve-constraints)> [CSub(TypeVar("a"), Int())]
      ; b := <try(solve-constraints)> [CSub(TypeVar("a"), Boolean())]
      ; c := <try(solve-constraints)> [CSub(Array(TypeVar("a")), Array(Int()))]
      ; d := <try(solve-constraints)> [CSub(TypeVar("a"), Reference(CRef("java/lang/Object"))),
                         CSub(TypeVar("a"), Reference(CRef("java/lang/String")))]
      ; e := <try(solve-constraints)> [CSub(TypeVar("a"), Reference(CRef("java/lang/String"))),
                         CEq(TypeVar("a"), TypeVar("b")),
                         CSub(TypeVar("b"), Reference(CRef("java/lang/Object")))]
      ; f := <try(solve-constraints)> [CSub(TypeVar("b"), Reference(CRef("java/lang/String"))),
                         CEq(TypeVar("a"), TypeVar("b")),
                         CSub(TypeVar("a"), Reference(CRef("java/lang/Object")))]

  solve-or-test-constraints :: ? -> List(?)
  solve-or-test-constraints: _ -> []
    where a := <try(solve-constraints)> [COr([[CEq(TypeVar("a"), [Int()])],
                         [CEq(TypeVar("a"), [Boolean()])]]),
                       CEq(TypeVar("a"), [Int()])]
      ; b := <try(solve-constraints)> [COr([[CEq(TypeVar("test"), [Int()]), CEq(TypeVar("test2"), []), CEq(TypeVar("abc"), TypeVar("test"))],
                          [CEq(TypeVar("test"), [Double()])]])]
      ; c := <try(solve-constraints)> [COr([[CEq(TypeVar("fail"), [Int()])],
                         [CEq(TypeVar("fail"), [Boolean()])]]),
                       CEq(TypeVar("fail"), [Byte()])]

  solve-not-test-constraints :: ? -> List(?)
  solve-not-test-constraints: _ -> [a, b, c, d, e]
    where a := <try(solve-constraints)> [CEq(TypeVar("a"), Int()),
                       CNEq(TypeVar("a"), Byte())]
      ; b := <try(solve-constraints)> [CEq(TypeVar("fail"), Int()),
                         CNEq(TypeVar("fail"), Int())]
      ; c := <try(solve-constraints)> [CEq(TypeVar("fail"), TypeVar("b")),
                         CNEq(TypeVar("fail"), Int()),
                         CEq(TypeVar("b"), Int())]
      ; d := <try(solve-constraints)> [CNEq(TypeVar("a"), TypeVar("b")),
                         CEq(TypeVar("a"), Int()),
                         CEq(TypeVar("b"), Int())]
      ; e := <try(solve-constraints)> [CEq(TypeVar("a"), Int()),
                         CNEq(TypeVar("a"), TypeVar("b")),
                         CEq(TypeVar("b"), Boolean())]

  solve-stack-test-constraints :: ? -> List(?)
  solve-stack-test-constraints: _ -> [a, b, c]
    where a := <try(solve-constraints)> [CEq(TypeVar("a"), [Int()]),
                       CEq(TypeVar("a"), ([Int()], TypeVar("b")))]
      ; b := <try(solve-constraints)> [CEq(TypeVar("a"), [Int(), Boolean(), Byte(), Int(), Boolean()]),
                         // CEq(TypeVar("b"), [Int(), Boolean()]),
                         CEq(TypeVar("a"), ([Int(), Boolean(), Byte()], TypeVar("b")))]
      ; c := <try(solve-constraints)> [CEq(TypeVar("a"), ([TypeVar("b")], TypeVar("c"))),
                         CEq(TypeVar("a"), ([Int()], TypeVar("d")))]

  solve-real-test-constraints :: ? -> List(?)
  solve-real-test-constraints: _ -> [a]
    where a := <try(solve-constraints)> [CEq(TypeVar("in0"), []),
                       CEq(TypeVar("out0"), TypeVar("in1")),
                       CEq(TypeVar("out1"), TypeVar("in2")),
                       CEq(TypeVar("out0"), ([TypeVar("n_26125")], TypeVar("p_26125"))),
                       CEq(TypeVar("in0"), TypeVar("p_26125")),
                       CEq(TypeVar("in0-locals"), ([TypeVar("n_26125")], TypeVar("o_26125"))),
                       CSub(TypeVar("n_26125"), Reference(CRef("java/lang/Object"))),
                       CEq(TypeVar("in0-locals"), TypeVar("out0-locals")),
                       CSub(TypeVar("in1"), ([Reference(CRef("java/lang/Object"))], TypeVar("q_26125"))),
                       CSub(TypeVar("out1"), TypeVar("q_26125")),
                       CEq(TypeVar("in1-locals"), TypeVar("out1-locals")),
                       CEq(TypeVar("out2"), []),
                       CEq(TypeVar("out2"), TypeVar("r_26125")),
                       CEq(TypeVar("in2"), ([], TypeVar("r_26125"))),
                       CEq(Void(), Void()),
                       CEq(TypeVar("in2-locals"), TypeVar("out2-locals")),
                       CEq(TypeVar("in0-locals"), ([Reference(CRef("examples/Count"))], TypeVar("s_26125"))),
                       CEq(TypeVar("out0-locals"), TypeVar("in1-locals")),
                       CEq(TypeVar("out1-locals"), TypeVar("in2-locals"))]


imports
  signatures/-
  runtime/nabl/-
  runtime/task/-
    runtime/types/-
    trans/analysis/types/-
    trans/analysis/names/-

// TODO document the strategies
strategies
  //the input of this strategy should be a list of constraints!
  solve-constraints :: List(Constraint) -> List(Type * Constraint) * List(Constraint)
  solve-constraints = !([], <id>);fixed-point(solve-constraints-step)

  solve-step(|List(Type * Constraint)) :: List(Constraint) -> List(Constraint)
  solve-step(|x*) =
    solve-constraints-sub-eliminate(|x*)
  ; solve-constraints-rename
  ; mapconcat(
       solve-constraints-stack(|x*)
    <+ ![<id>])
  ; mapconcat(
       solve-constraints-lookup(|x*)
    <+ solve-constraints-unify(|x*)
    <+ solve-constraints-simple-subtype(|x*)
    <+ solve-constraints-neq(|x*)
    <+ ![<id>])
  ; solve-constraints-sub-single(|x*)
  ; uniq

  fixed-point(a * b -> a * b) :: a * b -> a * b
  fixed-point(s) = !(<id>, <s> <id>); if(not(eq), Snd; fixed-point(s), Snd)

  is-simple-type :: ? -> BaseType
  is-simple-type = ?Int() <+ ?Double() <+ ?Float() <+ ?Boolean() <+ ?Char() <+ ?Byte() <+ ?Long() <+ ?Short()

rules // general rules
  solve-constraints-step :: List(Type * Constraint) * List(Constraint) -> List(Type * Constraint) * List(Constraint)
  solve-constraints-step: (x, []) -> (x, [])

  solve-constraints-step: (x*, c) -> (xnew*, constr)
    where mapconstr := <solve-step(|x*)> c
      ; (xn*, constr) := <partition(solve-constraints-simplify(|x*))> mapconstr
      ; xnew* := <uniq; unique-keys> [x*, xn*]

  unique-keys :: List(a * b) -> List(a * b)
  unique-keys: [] -> <id>
  unique-keys: ([x@(key, _) | tail]) ->  [x | <unique-keys> tail]
      where <not(lookup)> (key, tail)

  has-vars :: ? -> ? // Bug: Note the problem with looking for a constructor in the sort that the type variable was promoted to
  has-vars: TypeVar(_) -> <id>
  has-vars: _#(children*) -> <id>
    where <fetch(has-vars)> children*


rules // equality constraints
  solve-constraints-simplify(|List(Type * Constraint)) :: Constraint -> FieldType * ?
  solve-constraints-simplify(|x*): CEq(var@TypeVar(_), type) -> (var, type)
    where <not(has-vars)> type
      ; <not(?Alias(_))> type
      ; if t := <lookup> (var, x*)
          then <eq> (t, type)
        end

  solve-constraints-simplify(|x*): CEq(var@TypeVar(_), Alias(al)) -> (var, t)
    where t := <lookup> (TypeVar(al), x*)

  solve-constraints-unify(|List(Type * Constraint)) :: Constraint -> List(Constraint)
  solve-constraints-unify(|x*): n#([lt, rt]) -> result
    where <?"CEq" <+ ?"CSub"> n
      ; not(TypeVar(_) := lt)
      ; vars := <unify(?TypeVar(_))> [(lt, rt)]
      ; result := <map(\ (l,r) -> <mkterm> (n, [l,r]) \)> vars

  solve-constraints-lookup(|List(Type * Constraint)) :: Constraint -> List(Constraint)
  solve-constraints-lookup(|x*): CEq(var, type@TypeVar(_)) -> [CEq(var, t)]
    where t := <lookup> (type, x*)

  solve-constraints-lookup(|x*): CEq(var@TypeVar(_), type) -> [CEq(t, type)]
    where <not(?Alias(_))> type
      ; t := <lookup> (var, x*)

  solve-constraints-lookup(|x*): CSub(var@TypeVar(_), type) -> []
    where <not(?Alias(_))> type
      ; t := <lookup> (var, x*)
      ; super := <find-upper-bound> [t, type]
      ; <eq> (super, type)

  rename-equality :: List(Constraint) * Constraint * List(Constraint) -> List(Constraint) * List(Constraint)
  rename-equality: (l*, ceq@CEq(a@TypeVar(name_a), b@TypeVar(_)), r*) -> (nl*, [nr*, na*, alias])
    where <not(has-identity)> ceq
      ; concat := [l*, r*]
      ; nl* := <filter(not(has-subterm(|b)))> l*
      ; nr* := <filter(not(has-subterm(|b)))> r*
      ; na* := <filter(has-subterm(|b)); topdown(try(?b;!a)); filter(not(has-identity))> concat
      ; alias := CEq(b, Alias(name_a))
      ; temp := (nl*, [nr*, na*, alias])

  has-subterm(|?) :: a -> a
  has-subterm(|t): x -> x
    where <is-subterm> (t, x)

  has-identity :: Constraint -> Constraint
  has-identity = ?CEq(x, x)

  solve-constraints-rename :: List(Constraint) -> List(Constraint)
  solve-constraints-rename: [] -> []
  solve-constraints-rename: l -> <walk-values(rename-equality)> l

strategies
  walk-values(List(a) * a * List(a) -> List(a) * List(a)) :: List(a) -> List(a)
  walk-values(s) = !([], <id>); walk-value-tuple(s); ?(res, []); !res

  continue-value-tuple :: List(a) * a * b -> List(a) * b
  continue-value-tuple = ?(ln*, e, tailn); !([ln*, e], tailn)
  walk-value-tuple(List(a) * a * List(a) -> List(a) * List(a)) :: List(a) * List(a) -> List(a) * List(a)
  walk-value-tuple(s) = ?(_, [])
      < id
      + ?(l*, [e | tail]) ; !(l*, e, tail); (s <+ continue-value-tuple) ; walk-value-tuple(s)

rules // subtype constraints
  solve-constraints-simple-subtype(|List(Type * Constraint)) :: Constraint -> List(Constraint)
  solve-constraints-simple-subtype(|x*): CSub(var@TypeVar(_), type) -> [CEq(var, type)]
    where <is-simple-type <+ ?[]> type

  collect-csub-types :: List(Constraint) -> List(TypeVar * List(Constraint))
  collect-csub-types: [] -> []
  collect-csub-types: [CSub(TypeVar(x), t) | tail] -> [pair | ftail]
    where tailpairs := <collect-csub-types> tail
      ; l := <lookup <+ ![]> (x, tailpairs)
      ; pair := (x, [t | l])
      ; ftail := <filter(not(?(x, _)))> tailpairs
  inflate-csub-types :: List(TypeVar * List(FieldType)) -> List(Constraint)
  inflate-csub-types: [] -> []
  inflate-csub-types: [(x, l) | tail] -> result
    where csub* := <map(\ t -> CSub(TypeVar(x), t) \)> l
      ; tail* := <inflate-csub-types> tail
      ; result := [csub*, tail*]

  // TODO: make the upper bound finder
  find-upper-bound :: List(FieldType) -> FieldType
  find-upper-bound: [x] -> x
  find-upper-bound: [Reference(CRef("java/lang/Object")),Reference(CRef("java/lang/String"))] -> Reference(CRef("java/lang/String"))
  find-upper-bound: [Reference(CRef("java/lang/String")),Reference(CRef("java/lang/Object"))] -> Reference(CRef("java/lang/String"))
  find-upper-bound: [Reference(CRef("java/lang/Object")),Reference(CRef("examples/Count"))] -> Reference(CRef("examples/Count"))
  find-upper-bound: [Reference(CRef("examples/Count")),Reference(CRef("java/lang/Object"))] -> Reference(CRef("examples/Count"))

  solve-constraints-sub-eliminate(|List(Type * Constraint)) :: List(Constraint) -> List(Constraint)
  solve-constraints-sub-eliminate(|x*): c* -> cnew*
    where (csub*, cold*) := <partition(?CSub(TypeVar(_), _);id)> c*
      ; club* := <collect-csub-types;map(\ (a,b) -> CSub(TypeVar(a), <find-upper-bound> b) \)> csub*
      ; cnew* := [club*, cold*]

  is-sub-of-one-of(|List(TypeVar)) :: Constraint -> Constraint
  is-sub-of-one-of(|vars): CSub(TypeVar(x), _) -> <id>
    where <elem> (x, vars)

  solve-constraints-sub-single(|List(Type * Constraint)) :: List(Constraint) -> List(Constraint)
  solve-constraints-sub-single(|x*): c* -> cnew*
    where (csub*, cother*) := <partition(?CSub(TypeVar(_), _);id)> c*
      ; csubs := <collect-csub-types> csub*
      ; ceq* := <filter(?(x, [t]); !TypeVar(x); find-references(|cother*);?[]; !CEq(TypeVar(x), t))> csubs
      ; removed-vars := <map(?CEq(TypeVar(x), _); !x)> ceq*
      ; ckeep* := <filter(not(is-sub-of-one-of(|removed-vars)))> c*
      ; cnew* := [ckeep*, ceq*]

  find-references(|List(Constraint)) :: FieldType -> List(Constraint)
  find-references(|constraints): t@TypeVar(_) -> l
    where l := <filter(\ x -> x where <is-subterm> (t, x) \)> constraints

rules // or constraints
  // TODO

rules // not equals constraints
  solve-constraints-neq(|List(Type * Constraint)) :: Constraint -> List(Constraint)
  solve-constraints-neq(|x*): CNEq(var@TypeVar(_), type) -> []
    where <not(?TypeVar(_))> type
      ; t := <lookup> (var, x*)
      ; <not(eq)> (t, type)

  solve-constraints-neq(|x*) : CNEq(var@TypeVar(_), type@TypeVar(t)) -> [CNEq(var, b)]
    where b := <lookup> (type, x*)

rules // stack constraints CEq
  solve-constraints-stack(|List(Type * Constraint)) :: Constraint -> List(Constraint)
  solve-constraints-stack(|x*): CEq(var, ([], ts)) -> [CEq(var, ts)]

  solve-constraints-stack(|x*): CEq(var, ([headT|tailT], ts)) -> [CEq(headA, headT), CEq(varTail, tailA), CEq(varTail, (tailT, ts))]
    where [headA|tailA] := <lookup> (var, x*)
      ; varTail := <fresh-var>

  solve-constraints-stack(|x*): CEq(var@TypeVar(name), (head, tail)) -> [CEq(headVar, head), CEq(tailVar, tail), CEq(var, (headVar, tailVar))]
    where headVar := TypeVar($[[name]-head])
      ; tailVar := TypeVar($[[name]-tail])

rules // stack constraints CSub
  solve-constraints-stack(|x*): CSub(var@TypeVar(name), (head, tail)) -> [CSub(headVar, head), CSub(tailVar, tail), CEq(var, (headVar, tailVar))]
    where headVar := TypeVar($[[name]-head])
      ; tailVar := TypeVar($[[name]-tail])


imports
  signatures/-
  names/analysis/names/properties
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/match-Instruction

rules
  create-in-stack-task(|?) :: ? -> ?
  create-in-stack-task(|ctx):
    a -> <task-create-id(|ctx,[x848])> x848
    where
      <match-Instruction> a
    ; x848 := <type-is(|ctx)> <newname> "in"

  create-out-stack-task(|ctx):
    a -> <task-create-id(|ctx,[x848])> x848
    where
      <match-Instruction> a
    ; x848 := <type-is(|ctx)> <newname> "out"

  nabl-prop-site(|?, ?, ?, ?, ?) :: ? -> ?
  nabl-prop-site(|lang__, partition__, uris__, states__, implicits__):
    JBCLabel(l) -> <fail>
    where <store-in-stack(|partition__, <newname> "in")> l
        ; <store-out-stack(|partition__, <newname> "out")> l

imports
  analysis/names/project
  syntax/ASM
  trans/translator/-

rules

  generate-class:
    (selected, position, ast, path, project-path) -> None()
    where
        asm-ast@ASMClass(_, _, class-name, _, _, _, _, _) := <jasmin-file-to-asm-class> ast;
        path-init* := <string-tokenize(|['/','\']); init> path;
        path-end* := [class-name];
        path' := <separate-by(|"/");concat-strings> [path-init*, path-end*];
      filename := <guarantee-extension(|"class")> path'
    where
      <write-class-file(|filename)> asm-ast;
      result := None()

  translate-class:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"asm.aterm")> path
    where
      result := <jasmin-file-to-asm-class> ast

  execute-class:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"result.txt")> path
    with
      cname := <class-name ; is-string; string-replace(|"/",".")> ast;
      cpath := <concat-strings; prim("local_path")> [project-path, "/", <dirname> path];
      <execute-java(|cpath); process-output> cname => result

  generate-and-execute-class:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
        asm-ast@ASMClass(_, _, class-name, _, _, _, _, _) := <jasmin-file-to-asm-class> ast;
        path-init* := <string-tokenize(|['/','\']); init> path;
        path-end* := [class-name];
        path' := <separate-by(|"/");concat-strings> [path-init*, path-end*];
      class-filename := <guarantee-extension(|"class")> path';
      filename := <guarantee-extension(|"result.txt")> path
    with
      <write-class-file(|class-filename)> asm-ast;
      cname := <class-name ; is-string; string-replace(|"/",".")> ast;
      cpath := <concat-strings; prim("local_path")> [project-path, "/", <dirname> path];
      <execute-java(|cpath); process-output> cname => result



  process-output :: Term -> string
  process-output: Output(result, "") -> result

  process-output: Output(result, error) -> $[[result] Runtime error: [error]]
    where not (<?""> error)

signature constructors

  Output: string * string -> Term

strategies

  external execute-java(|path)
  external write-class-file(|fname)


imports

  signatures/-
  interpreter/state

rules

  step(|State) :: ?  -> State
  step(|state): IADD() -> <pop(|2) ; push(|r) ; next> state
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <addS> (v2, v1) => r

  step(|state): ISUB() -> <pop(|2) ; push(|r) ; next> state
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <subtS> (v2, v1) => r

  step(|state): IMUL() -> <pop(|2) ; push(|r) ; next> state
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <mulS> (v2, v1) => r



imports

  signatures/-
  interpreter/state

rules

  step(|state): IALOAD() -> <pop(|2) ; push(|Int(v)) ; next> state
    where
      <top(|2)> state => [Int(i), Ref(r)] ;
      <resolve(|r)> state => Array(Int(), vs) ;
      <index> (<string-to-int> i, vs) => Int(v)

  step(|state): IASTORE() -> <pop(|3) ; update(|r, Array(Int(), vs')) ; next> state
    where
      <top(|2)> state => [Int(v), Int(i), Ref(r)] ;
      <resolve(|r)> state => Array(Int(), vs) ;
      <at-index(!Int(v))> (<string-to-int ; inc> i, vs) => vs'

  step(|state): ARRAYLENGTH() -> <pop ; push(|Int(l)) ; next> state
    where
      <top> state => Ref(ar) ;
      <resolve(|<is-string> ar)> state => Array(_, vs) ;
      <length ; int-to-string> vs => l

  step(|state): NEWARRAY(IntName()) -> <alloc(|Array(Int(), [])) ; next> state

imports

  signatures/-
  interpreter/state

rules

  step(|state): ICONST_0() -> <push(|Int("0")) ; next> state
  step(|state): ICONST_1() -> <push(|Int("1")) ; next> state
  step(|state): LDC(Int(i)) -> <push(|Int(i)) ; next> state




imports

  signatures/-

rules

  desugar :: Instruction -> ?
  desugar: ALOAD_0() -> ALOAD("0")
  desugar: ALOAD_1() -> ALOAD("1")
  desugar: ALOAD_2() -> ALOAD("2")
  desugar: ALOAD_3() -> ALOAD("3")

  desugar: ILOAD_0() -> ILOAD("0")
  desugar: ILOAD_1() -> ILOAD("1")
  desugar: ILOAD_2() -> ILOAD("2")
  desugar: ILOAD_3() -> ILOAD("3")


imports

  signatures/-
  interpreter/state

rules

  step(|state): JBCLabel(_) -> <next> state

  step(|state): GOTO(LabelRef(l)) -> <goto(|l)> state

rules // comparison with 0

  step(|state): IFEQ(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <eq> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFNE(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <not(eq)> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFGE(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <geqS> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFGT(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <gtS> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFLE(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <leqS> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFLT(LabelRef(l)) -> state'
    where
      <top> state => Int(v) ;
      <ltS> (v, "0")
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

rules // comparison with null

  step(|state): IFNULL(LabelRef(l)) -> state'
    where
      <top> state => Ref(r) ;
      <eq> (r, NULL())
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

  step(|state): IFNONNULL(LabelRef(l)) -> state'
    where
      <top> state => Ref(r) ;
      <not(eq)> (r, NULL())
        < <pop ; goto(|l)> state => state'
        + <pop ; next> state => state'

rules // integer comparison

  step(|state): IF_ICMPEQ(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <eq> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ICMPNE(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <not(eq)> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ICMPGE(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <geqS> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ICMPGT(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <gtS> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ICMPLE(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <leqS> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ICMPLT(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Int(v1), Int(v2)] ;
      <ltS> (v2, v1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

rules // reference comparison

  step(|state): IF_ACMPEQ(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Ref(r1), Ref(r2)] ;
      <eq> (r2, r1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'

  step(|state): IF_ACMPNE(LabelRef(l)) -> state'
    where
      <top(|2)> state => [Ref(r1), Ref(r2)] ;
      <not(eq)> (r2, r1)
        < <pop(|2) ; goto(|l)> state => state'
        + <pop(|2) ; next> state => state'



imports

  signatures/-
  interpreter/state

rules

  step(|state): ALOAD(n) -> <push(|Ref(r)) ; next> state
    where
      <load(|n)> state => Ref(r)

  step(|state): ILOAD(n) -> <push(|Int(v)) ; next> state
    where
      <load(|n)> state => Int(v)

  step(|state): ISTORE(n) -> <pop ; store(|n, Int(v)) ; next> state
    where
      <top> state => Int(v)

  step(|state): ASTORE(n) -> <pop ; store(|n, Ref(r)) ; next> state
    where
      <top> state => Ref(r)



imports

  signatures/-
  interpreter/state

rules

  step(|state): RETURN() -> <drop-frame ; next> state

  step(|state): IRETURN() -> <pop ; drop-frame ; push(|Int(v)) ; next> state
    where
      <top> state => Int(v)

  step(|state): ARETURN() -> <pop ; drop-frame ; push(|Ref(r)) ; next> state
    where
      <top> state => Ref(r)

imports

  signatures/-
  interpreter/state

rules

  step(|state): NOP() -> <next> state

  step(|state): DUP() -> <push(|top) ; next> state
    where
      <top> state => top

  step(|state): SWAP() -> <pop(|2) ; push(|v1) ; push(|v2) ; next> state
    where
      <top(|2)> state => [v1, v2]

  step(|state): POP() -> <pop ; next> state


imports

  signatures/-
  interpreter/state

rules

  step(|state): NEW(cn) -> <alloc(|o) ; next> state
    where
      <init-object> cn => o

  step(|state): GETFIELD(JBCFieldRef(_, fn, _)) -> <pop; push(|v) ; next> state
    where
      <top> state => Ref(r) ;
      <resolve(|<is-string> r)> state => Object(_, fields) ;
      <lookup> (fn, fields :: List(?)) => v

  step(|state): PUTFIELD(JBCFieldRef(_, fn, _)) -> <pop(|2); update(|r, Object(cn, fields')) ; next> state
    where
      <top(|2)> state => [v, Ref(r)] ;
      <resolve(|r)> state => Object(cn, fields) ;
      <update-key-value(|r, v)> fields :: List(?) => fields' :: List(?)

rules

  load-class-file = fail

  init-object :: ClassName -> HeapElement
  init-object: "java/lang/Object" -> Object("java/lang/Object", [])
  init-object: cn -> Object(cn, slots)
    where
      <load-class-file> cn => JBCFile(JBCHeader(_, _, JBCClass(_, cn), JBCSuper(sn), _, _, _, _, _, _), fs, _) ;
      <init-object> sn => Object(_, iss) ;
      <map(init-slot)> fs => oss ;
      <conc> (iss, oss) => slots

  init-slot :: Field -> FieldName * Value
  init-slot: JBCField(_, fn, JBCFieldDesc(t), _, v) -> (fn, <init-value> (t, v))
  init-slot: JBCExtField(_, fn, JBCFieldDesc(t), _, v, _) -> (fn, <init-value> (t, v))

  init-value :: FieldType * InitialValue -> Value
  init-value: (Int(), None()) -> Int("0")
  init-value: (Int(), v) -> Int(<is-string> v)

  init-value: (Boolean(), None()) -> Int("0")
  init-value: (Boolean(), v) -> Int(<is-string> v)

  init-value: (Array(_), None()) -> Ref(NULL())
  init-value: (Reference(_), None()) -> Ref(NULL())


imports signatures/-

signature constructors

  JBCState  : List(Frame) * Heap -> State

  JBCFrame  : MethodRef * List(Instruction) * PC * Stack * Locals -> Frame
        : int -> PC

  JBCStack  : List(Value) -> Stack
  : string -> Value
  Int      : string -> Value
  Ref      : RefValue -> Value
  NULL    : RefValue
        : string -> RefValue

  JBCLocals  : List(Value) -> Locals

  JBCHeap    : List(HeapEntry) -> Heap
        : string * HeapElement -> HeapEntry

  Array    : ComponentType * List(Value) -> HeapElement
  Object    : ClassName * List(Slot) -> HeapElement
        : FieldName * Value -> Slot

strategies // manipulate PC in top-most frame

  next :: State -> State
  next = JBCState([JBCFrame(id, id, inc, id, id)|id], id)

  goto(|LabelName) :: State -> State
  goto(|l) = JBCState([JBCFrame(id, ?'is, <getfirst(?(<id>,l))> 'is, id, id)|id], id)

strategies // manipulate stack in top-most frame

  push(|Value) :: State -> State
  push(|v) = JBCState([JBCFrame(id, id, id, JBCStack(![v|<id>]), id)|id], id)

  pop(|int) :: State -> State
  pop(|n) = JBCState([JBCFrame(id, id, id, JBCStack(drop(|n)), id)|id], id)

  pop :: State -> State
  pop = pop(|1)

  top(|int) :: State -> List(Value)
  top(|n) = ?JBCState([JBCFrame(_, _, _, JBCStack(<take(|n)>), _)|_], _)

  top :: State -> Value
  top = top(|1); ?[<id>]

strategies // manipulate local variables in top-most frame

  load(|string) :: State -> Value
  load(|n) = ?JBCState([JBCFrame(_, _, _, _, JBCLocals(<at-index(?v|<string-to-int> n);!v>))|_], _)
  store(|string, Value) :: State -> State
  store(|n, v) = JBCState([JBCFrame(id, id, id, JBCStack(at-index(!v|<string-to-int> n)), id)|id], id)

strategies // manipulate heap

  resolve(|string) :: State -> HeapElement
  resolve(|r) = ?JBCState(_, JBCHeap(<id>)) ; <lookup> (r, <id> :: List(string * HeapElement))
  alloc(|HeapElement) :: State -> State
  alloc(|v) = where(<newname> "ref" => r) ; JBCState([JBCFrame(id, id, id, JBCStack(![Ref(r)|<id>]), id)|id], JBCHeap(![(r,v)|<id>]))
  update(|string, HeapElement) :: State -> State
  update(|r, v) = JBCState(id, JBCHeap(update-key-value(|r, v)))

  update-key-value(|a, b) :: List(a * b) -> List(a * b)
  update-key-value(|r, v) = fetch(?(r, _) ; !(r, v))

strategies // manipulate frames

  drop-frame :: State -> State
  drop-frame = not(top) ; JBCState(Tl, id)


imports
  libstratego-lib
  gpp
  libstratego-aterm

imports

  libspoofax/core/language

  runtime/analysis/-
  runtime/nabl/-
  runtime/task/-
  runtime/index/-
  runtime/properties/-
  runtime/types/-
  libspoofax/sdf/pp

  JasminXT-Extra-PP-Rules.pp
  pp/-
  pp
  outliner

imports

  signatures/-

  names/analysis/names/binding
  analysis/names/check
  analysis/names/project
  // analysis/names/-
  // analysis/types/-
  // analysis/types/next-instr/-
  // analysis/types/pop-types/-
  // analysis/types/push-types/-
  analysis/desugar
  editor/builders


rules // Analysis

  editor-analyze = analyze-all(desugar-all, id, id|<language>)

rules // Editor services

  // Resolves a reference when the user control-clicks or presses F3 in the editor.
  editor-resolve:
    (node, position, ast, path, project-path) -> definition
    where
      definition := <analysis-resolve(|<language>, project-path)> node

  // Returns "hover help" information for a particular node in the editor.
  // For references, this rule is invoked using the resolved term.
  editor-hover:
    (target, position, ast, path, project-path) -> <get-type> target

  // Completes an identifier when the user presses control-space
  // (the completion identifier in the AST provides additional context information)
  editor-complete:
    (node, position, ast, path, project-path) -> proposals
    where
      proposals := <analysis-propose-completions(|<language>, project-path)> ast

// rules // Constraints
//
//   debug-collect-file-constraints:
//     (selected, position, ast, path, project-path) -> (filename, result)
//     where
//       index-setup(|<language>, project-path);
//       task-setup(|project-path);
//       partition   := $[[project-path]/[path]];
//       filename := <guarantee-extension(|"generated.constraints")> path;
//       JBCFile(_, _, methods) := selected;
//       result   := <map(stack-constraints(|partition, <class-name> selected))> methods
//
//   debug-collect-solve-constraints:
//     (selected, position, ast, path, project-path) -> (filename, result)
//     where
//       index-setup(|<language>, project-path);
//       task-setup(|project-path);
//       partition   := $[[project-path]/[path]];
//       JBCFile(_, _, methods) := selected;
//       method_constraints   := <map(stack-constraints(|partition, <class-name> selected))> methods;
//       filename := <guarantee-extension(|"generated.solution")> path;
//       result := <map(try(solve-constraints))> method_constraints
//
//    debug-solve-test-constraints:
//     (selected, position, ast, path, project-path) -> (filename, result)
//     where
//       filename := <guarantee-extension(|"generated.test")> path;
//       result   := <solve-test-constraints>

rules // Debugging

  // Prints the abstract syntax ATerm of a selection.
  debug-show-aterm:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path;
      result   := selected

  // Prints the analyzed annotated abstract syntax ATerm of a selection.
  debug-show-analyzed-selection:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"analyzed.aterm")> path;
      result   := selected

  debug-show-analyzed:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"analyzed.aterm")> path;
      result   := ast

  debug-project =
    analysis-debug-project(|<language>)

  debug-partition =
    analysis-debug-partition(|<language>)

  debug-index-partition =
    analysis-debug-index-partition(|<language>)

  debug-index-project =
    analysis-debug-index-project(|<language>)

  debug-task-project =
    analysis-debug-task-project(|<language>)

  debug-task-partition =
    analysis-debug-task-partition(|<language>)

  debug-task-selection =
    analysis-debug-task-selection(|<language>)


// this file was semi-automatically generated from the syntax definition of the Instruction sort
rules
  match-Instruction :: ? -> Instruction
  match-Instruction: a#(_) -> <id> where <is-string;match-Instruction-constr> a

  match-Instruction-constr :: string -> string
  match-Instruction-constr: "IADD"                     -> <id>
  match-Instruction-constr: "IAND"                     -> <id>
  match-Instruction-constr: "IDIV"                     -> <id>
  match-Instruction-constr: "IMUL"                     -> <id>
  match-Instruction-constr: "INEG"                     -> <id>
  match-Instruction-constr: "IOR"                      -> <id>
  match-Instruction-constr: "IREM"                     -> <id>
  match-Instruction-constr: "ISHL"                     -> <id>
  match-Instruction-constr: "ISHR"                     -> <id>
  match-Instruction-constr: "ISUB"                     -> <id>
  match-Instruction-constr: "IUSHR"                    -> <id>
  match-Instruction-constr: "IXOR"                     -> <id>
  match-Instruction-constr: "LADD"                     -> <id>
  match-Instruction-constr: "LAND"                     -> <id>
  match-Instruction-constr: "LDIV"                     -> <id>
  match-Instruction-constr: "LMUL"                     -> <id>
  match-Instruction-constr: "LNEG"                     -> <id>
  match-Instruction-constr: "LOR"                      -> <id>
  match-Instruction-constr: "LREM"                     -> <id>
  match-Instruction-constr: "LSHL"                     -> <id>
  match-Instruction-constr: "LSHR"                     -> <id>
  match-Instruction-constr: "LSUB"                     -> <id>
  match-Instruction-constr: "LUSHR"                    -> <id>
  match-Instruction-constr: "LXOR"                     -> <id>
  match-Instruction-constr: "FADD"                     -> <id>
  match-Instruction-constr: "FDIV"                     -> <id>
  match-Instruction-constr: "FMUL"                     -> <id>
  match-Instruction-constr: "FNEG"                     -> <id>
  match-Instruction-constr: "FREM"                     -> <id>
  match-Instruction-constr: "FSUB"                     -> <id>
  match-Instruction-constr: "DADD"                     -> <id>
  match-Instruction-constr: "DDIV"                     -> <id>
  match-Instruction-constr: "DMUL"                     -> <id>
  match-Instruction-constr: "DNEG"                     -> <id>
  match-Instruction-constr: "DREM"                     -> <id>
  match-Instruction-constr: "DSUB"                     -> <id>
  match-Instruction-constr: "IINC"                     -> <id>
  match-Instruction-constr: "IINC_W"                   -> <id>
  match-Instruction-constr: "FCMPG"                    -> <id>
  match-Instruction-constr: "FCMPL"                    -> <id>
  match-Instruction-constr: "DCMPG"                    -> <id>
  match-Instruction-constr: "DCMPL"                    -> <id>
  match-Instruction-constr: "LCMP"                     -> <id>
  match-Instruction-constr: "IFEQ"                     -> <id>
  match-Instruction-constr: "IFLT"                     -> <id>
  match-Instruction-constr: "IFLE"                     -> <id>
  match-Instruction-constr: "IFNE"                     -> <id>
  match-Instruction-constr: "IFGT"                     -> <id>
  match-Instruction-constr: "IFGE"                     -> <id>
  match-Instruction-constr: "IFNULL"                   -> <id>
  match-Instruction-constr: "IFNONNULL"                -> <id>
  match-Instruction-constr: "IF_ICMPEQ"                -> <id>
  match-Instruction-constr: "IF_ICMPLT"                -> <id>
  match-Instruction-constr: "IF_ICMPLE"                -> <id>
  match-Instruction-constr: "IF_ICMPNE"                -> <id>
  match-Instruction-constr: "IF_ICMPGT"                -> <id>
  match-Instruction-constr: "IF_ICMPGE"                -> <id>
  match-Instruction-constr: "IF_ACMPEQ"                -> <id>
  match-Instruction-constr: "IF_ACMPNE"                -> <id>
  match-Instruction-constr: "Table"                    -> <id>
  match-Instruction-constr: "Lookup"                   -> <id>
  match-Instruction-constr: "GOTO"                     -> <id>
  match-Instruction-constr: "GOTO_W"                   -> <id>
  match-Instruction-constr: "JSR"                      -> <id>
  match-Instruction-constr: "JSR_W"                    -> <id>
  match-Instruction-constr: "I2L"                      -> <id>
  match-Instruction-constr: "I2F"                      -> <id>
  match-Instruction-constr: "I2D"                      -> <id>
  match-Instruction-constr: "L2F"                      -> <id>
  match-Instruction-constr: "L2D"                      -> <id>
  match-Instruction-constr: "F2D"                      -> <id>
  match-Instruction-constr: "I2B"                      -> <id>
  match-Instruction-constr: "I2S"                      -> <id>
  match-Instruction-constr: "I2C"                      -> <id>
  match-Instruction-constr: "L2I"                      -> <id>
  match-Instruction-constr: "F2I"                      -> <id>
  match-Instruction-constr: "F2L"                      -> <id>
  match-Instruction-constr: "D2I"                      -> <id>
  match-Instruction-constr: "D2L"                      -> <id>
  match-Instruction-constr: "D2F"                      -> <id>
  match-Instruction-constr: "ATHROW"                   -> <id>
  match-Instruction-constr: "NOP"                      -> <id>
  match-Instruction-constr: "BREAKPOINT"               -> <id>
  match-Instruction-constr: "PC"                       -> <id>
  match-Instruction-constr: "INVOKESPECIAL"            -> <id>
  match-Instruction-constr: "INVOKEVIRTUAL"            -> <id>
  match-Instruction-constr: "INVOKESTATIC"             -> <id>
  match-Instruction-constr: "INVOKEINTERFACE"          -> <id>
  match-Instruction-constr: "RETURN"                   -> <id>
  match-Instruction-constr: "IRETURN"                  -> <id>
  match-Instruction-constr: "LRETURN"                  -> <id>
  match-Instruction-constr: "FRETURN"                  -> <id>
  match-Instruction-constr: "DRETURN"                  -> <id>
  match-Instruction-constr: "ARETURN"                  -> <id>
  match-Instruction-constr: "RET"                      -> <id>
  match-Instruction-constr: "RET_W"                    -> <id>
  match-Instruction-constr: "BIPUSH"                   -> <id>
  match-Instruction-constr: "SIPUSH"                   -> <id>
  match-Instruction-constr: "ICONST_M1"                -> <id>
  match-Instruction-constr: "ICONST_0"                 -> <id>
  match-Instruction-constr: "ICONST_1"                 -> <id>
  match-Instruction-constr: "ICONST_2"                 -> <id>
  match-Instruction-constr: "ICONST_3"                 -> <id>
  match-Instruction-constr: "ICONST_4"                 -> <id>
  match-Instruction-constr: "ICONST_5"                 -> <id>
  match-Instruction-constr: "LCONST_0"                 -> <id>
  match-Instruction-constr: "LCONST_1"                 -> <id>
  match-Instruction-constr: "FCONST_0"                 -> <id>
  match-Instruction-constr: "FCONST_1"                 -> <id>
  match-Instruction-constr: "FCONST_2"                 -> <id>
  match-Instruction-constr: "DCONST_0"                 -> <id>
  match-Instruction-constr: "DCONST_1"                 -> <id>
  match-Instruction-constr: "ACONST_NULL"              -> <id>
  match-Instruction-constr: "LDC"                      -> <id>
  match-Instruction-constr: "LDC2_W"                   -> <id>
  match-Instruction-constr: "LDC_W"                    -> <id>
  match-Instruction-constr: "ILOAD"                    -> <id>
  match-Instruction-constr: "LLOAD"                    -> <id>
  match-Instruction-constr: "FLOAD"                    -> <id>
  match-Instruction-constr: "DLOAD"                    -> <id>
  match-Instruction-constr: "ALOAD"                    -> <id>
  match-Instruction-constr: "ILOAD_W"                  -> <id>
  match-Instruction-constr: "LLOAD_W"                  -> <id>
  match-Instruction-constr: "FLOAD_W"                  -> <id>
  match-Instruction-constr: "DLOAD_W"                  -> <id>
  match-Instruction-constr: "ALOAD_W"                  -> <id>
  match-Instruction-constr: "ILOAD_0"                  -> <id>
  match-Instruction-constr: "ILOAD_1"                  -> <id>
  match-Instruction-constr: "ILOAD_2"                  -> <id>
  match-Instruction-constr: "ILOAD_3"                  -> <id>
  match-Instruction-constr: "ALOAD_0"                  -> <id>
  match-Instruction-constr: "ALOAD_1"                  -> <id>
  match-Instruction-constr: "ALOAD_2"                  -> <id>
  match-Instruction-constr: "ALOAD_3"                  -> <id>
  match-Instruction-constr: "LLOAD_0"                  -> <id>
  match-Instruction-constr: "LLOAD_1"                  -> <id>
  match-Instruction-constr: "LLOAD_2"                  -> <id>
  match-Instruction-constr: "LLOAD_3"                  -> <id>
  match-Instruction-constr: "DLOAD_0"                  -> <id>
  match-Instruction-constr: "DLOAD_1"                  -> <id>
  match-Instruction-constr: "DLOAD_2"                  -> <id>
  match-Instruction-constr: "DLOAD_3"                  -> <id>
  match-Instruction-constr: "FLOAD_0"                  -> <id>
  match-Instruction-constr: "FLOAD_1"                  -> <id>
  match-Instruction-constr: "FLOAD_2"                  -> <id>
  match-Instruction-constr: "FLOAD_3"                  -> <id>
  match-Instruction-constr: "ISTORE"                   -> <id>
  match-Instruction-constr: "LSTORE"                   -> <id>
  match-Instruction-constr: "FSTORE"                   -> <id>
  match-Instruction-constr: "DSTORE"                   -> <id>
  match-Instruction-constr: "ASTORE"                   -> <id>
  match-Instruction-constr: "ISTORE_W"                 -> <id>
  match-Instruction-constr: "LSTORE_W"                 -> <id>
  match-Instruction-constr: "FSTORE_W"                 -> <id>
  match-Instruction-constr: "DSTORE_W"                 -> <id>
  match-Instruction-constr: "ASTORE_W"                 -> <id>
  match-Instruction-constr: "ISTORE_0"                 -> <id>
  match-Instruction-constr: "ISTORE_1"                 -> <id>
  match-Instruction-constr: "ISTORE_2"                 -> <id>
  match-Instruction-constr: "ISTORE_3"                 -> <id>
  match-Instruction-constr: "ASTORE_0"                 -> <id>
  match-Instruction-constr: "ASTORE_1"                 -> <id>
  match-Instruction-constr: "ASTORE_2"                 -> <id>
  match-Instruction-constr: "ASTORE_3"                 -> <id>
  match-Instruction-constr: "LSTORE_0"                 -> <id>
  match-Instruction-constr: "LSTORE_1"                 -> <id>
  match-Instruction-constr: "LSTORE_2"                 -> <id>
  match-Instruction-constr: "LSTORE_3"                 -> <id>
  match-Instruction-constr: "FSTORE_0"                 -> <id>
  match-Instruction-constr: "FSTORE_1"                 -> <id>
  match-Instruction-constr: "FSTORE_2"                 -> <id>
  match-Instruction-constr: "FSTORE_3"                 -> <id>
  match-Instruction-constr: "DSTORE_0"                 -> <id>
  match-Instruction-constr: "DSTORE_1"                 -> <id>
  match-Instruction-constr: "DSTORE_2"                 -> <id>
  match-Instruction-constr: "DSTORE_3"                 -> <id>
  match-Instruction-constr: "NEW"                      -> <id>
  match-Instruction-constr: "NEWARRAY"                 -> <id>
  match-Instruction-constr: "ANEWARRAY"                -> <id>
  match-Instruction-constr: "ANEWARRAY"                -> <id>
  match-Instruction-constr: "MULTIANEWARRAY"           -> <id>
  match-Instruction-constr: "GETFIELD"                 -> <id>
  match-Instruction-constr: "PUTFIELD"                 -> <id>
  match-Instruction-constr: "GETSTATIC"                -> <id>
  match-Instruction-constr: "PUTSTATIC"                -> <id>
  match-Instruction-constr: "IALOAD"                   -> <id>
  match-Instruction-constr: "LALOAD"                   -> <id>
  match-Instruction-constr: "BALOAD"                   -> <id>
  match-Instruction-constr: "CALOAD"                   -> <id>
  match-Instruction-constr: "SALOAD"                   -> <id>
  match-Instruction-constr: "FALOAD"                   -> <id>
  match-Instruction-constr: "DALOAD"                   -> <id>
  match-Instruction-constr: "AALOAD"                   -> <id>
  match-Instruction-constr: "IASTORE"                  -> <id>
  match-Instruction-constr: "LASTORE"                  -> <id>
  match-Instruction-constr: "BASTORE"                  -> <id>
  match-Instruction-constr: "CASTORE"                  -> <id>
  match-Instruction-constr: "SASTORE"                  -> <id>
  match-Instruction-constr: "FASTORE"                  -> <id>
  match-Instruction-constr: "DASTORE"                  -> <id>
  match-Instruction-constr: "AASTORE"                  -> <id>
  match-Instruction-constr: "ARRAYLENGTH"              -> <id>
  match-Instruction-constr: "CHECKCAST"                -> <id>
  match-Instruction-constr: "INSTANCEOF"               -> <id>
  match-Instruction-constr: "POP"                      -> <id>
  match-Instruction-constr: "POP2"                     -> <id>
  match-Instruction-constr: "DUP"                      -> <id>
  match-Instruction-constr: "DUP2"                     -> <id>
  match-Instruction-constr: "DUP_X1"                   -> <id>
  match-Instruction-constr: "DUP2_X1"                  -> <id>
  match-Instruction-constr: "DUP_X2"                   -> <id>
  match-Instruction-constr: "DUP2_X2"                  -> <id>
  match-Instruction-constr: "SWAP"                     -> <id>
  match-Instruction-constr: "MONITORENTER"             -> <id>
  match-Instruction-constr: "MONITOREXIT"              -> <id>


imports

  signatures/-
  libspoofax/editor/outline

rules

  outline-expand-to-level :: ? -> int
  outline-expand-to-level = !3


imports

  gpp
  libspoofax/sdf/pp
  libspoofax/editor/refactoring/-
  pp/-

rules

  editor-format:
    (node, _, ast, path, project-path) -> (filename, result)
    with
      ext      := <get-extension> path
    ; filename := <guarantee-extension(|$[pp.[ext]])> path
    ; result   := <pp-debug> node



imports
  signatures/-
  syntax/ASM
  trans/translator/-

signature
  constructors
    Label  :  LabelName -> Instruction
    TryCatch:  LabelName * LabelName * LabelName * ClassName -> Instruction
    LocalVar:  VarName * string * None * LabelName * LabelName * int -> Instruction
    Line    :   int -> Instruction
    : Maxs -> Instruction
    
    Maxs  :  int * int -> Maxs
    : Maxs -> Statement
    

rules
  jasmin-directive-to-asm :: Statement -> Instruction
  jasmin-directive-to-asm:
    Maxs(sl, ll) -> <id> //Maxs(<to-int> sl, <to-int> ll)
  jasmin-directive-to-asm:
    JBCCatch(CRef(t), LabelRef(from), LabelRef(to), LabelRef(handler)) -> TryCatch(from, to, handler, t)
  jasmin-directive-to-asm:
    JBCLabel(x)  -> Label(x)
  jasmin-directive-to-asm:
     JBCVarDecl(ind, name, JBCFieldDesc(fdesc), LabelRef(from), LabelRef(to)) -> LocalVar(name, desc, None(), from, to, index)
     where
       index := <to-int> ind
     ;  desc := <jasmin-fieldtype-to-descriptor> fdesc
  jasmin-directive-to-asm:
    JBCLine(l) -> Line(line)
    where
      line := <to-int> l

  collect-maxs :: List(Statement) -> List(Statement)
  collect-maxs:
    l      ->  result
    where
      result := <collect-maxs'> (Maxs(1,1), [], l)

  collect-maxs' :: Maxs * List(Statement) * List(Statement) -> List(Statement)
  collect-maxs':
    (m, l, []) -> [m | l]
  collect-maxs':
    (Maxs(sl, ll), tail, [h | t])  ->  result
    where
      JBCLimitStack(nsl) := h
    ;  result := <collect-maxs'> (Maxs(<to-int> nsl, ll), tail, t)
  collect-maxs':
    (Maxs(sl, ll), tail, [h | t])  ->  result
    where
      JBCLimitLocals(nll) := h
    ;  result := <collect-maxs'> (Maxs(sl, <to-int> nll), tail, t)
  collect-maxs':
    (Maxs(sl, ll), tail*, [h | t])  ->  result
    where
      not(JBCLimitLocals(_) := h)
    ;  not(JBCLimitStack(_) := h)
    ;  result := <collect-maxs'> (Maxs(sl, ll), [tail*, h], t)

imports
  signatures/-

rules
  bitwise-or :: int * int -> int
  bitwise-or:
    (0, 0) -> 0
  bitwise-or:
    (x, 0) -> x
  bitwise-or:
    (0, x) -> x
  bitwise-or:
    (1, 1) -> 1
  bitwise-or:
    (a, b) -> result
    where
      lsa := <mod> (a, 2)
    ;  lsb := <mod> (b, 2)
    ;  ls := <bitwise-or> (lsa, lsb)
    ;  resta := <divi> (a, 2)
    ;  restb := <divi> (b, 2)
    ;  restor := <bitwise-or> (resta, restb)
    ;  restors := <muli> (restor, 2)
    ;  result := <addi> (restors, ls)

  // jasmin-flags-to-int:
  //   [] -> 0
  // jasmin-flags-to-int:
  //   [f | t] -> result
  //   where
  //     i := <jasmin-flag-intvalue> f
  //   ;  it := <jasmin-flags-to-int> t
  //   ;  result := <bitwise-or> (i, it)
signature constructors
  : MethodAccess -> JasminFlag
  : ClassAccess -> JasminFlag
  : FieldAccess -> JasminFlag
rules

  jasmin-flag-intvalue :: JasminFlag -> int
  jasmin-flag-intvalue: PUBLIC() -> 1
  jasmin-flag-intvalue: PRIVATE() -> 2
  jasmin-flag-intvalue: PROTECTED() -> 4
  jasmin-flag-intvalue: STATIC() -> 8
  jasmin-flag-intvalue: FINAL() -> 16
  jasmin-flag-intvalue: SUPER() -> 32
  jasmin-flag-intvalue: SYNCHRONIZED() -> 32
  jasmin-flag-intvalue: VOLATILE() -> 64
  // jasmin-flag-intvalue: BRIDGE() -> 64
  // jasmin-flag-intvalue: VARARGS() -> 128
  jasmin-flag-intvalue: TRANSIENT() -> 128
  jasmin-flag-intvalue: NATIVE() -> 256
  jasmin-flag-intvalue: INTERFACE() -> 512
  jasmin-flag-intvalue: ABSTRACT() -> 1024
  jasmin-flag-intvalue: ABSTRACT() -> 1024
  // jasmin-flag-intvalue: STRICT() -> 2048
  // jasmin-flag-intvalue: SYNTHETIC() -> 4096
  // jasmin-flag-intvalue: ANNOTATION() -> 8192
  // jasmin-flag-intvalue: ENUM() -> 16384
  // jasmin-flag-intvalue: MANDATED() -> 32768
  // jasmin-flag-intvalue: DEPRECATED() -> 131072

strategies
  jasmin-flags-to-int :: List(JasminFlag) -> int
  jasmin-flags-to-int = map(jasmin-flag-intvalue); foldr(!0, bitwise-or)


signature
  constructors
    T_INSN        :  Optype
    T_INTINSN      :  Optype
    T_VARINSN      :  Optype
    T_TYPEINSN      :  Optype
    T_FIELDINSN      :  Optype
    T_METHODINSN    :  Optype
    T_JUMPINSN      :  Optype
    T_INVOKEDYNAMICINSN  :  Optype
    T_LDCINSN      :  Optype
    T_IINCINSN      :  Optype
    T_TABLESWITCH    :  Optype
    T_LOOKUPSWITCH    :  Optype
    T_MULTIANEWARRAY  :  Optype

    : int -> Opcode
    Insn        :  Opcode -> OpInstruction
    IntInsn        :  Opcode * int -> OpInstruction
    VarInsn        :  Opcode * int -> OpInstruction
    TypeInsn      :  Opcode * ClassName -> OpInstruction
    FieldInsn      :  Opcode * ClassName * FieldName * string -> OpInstruction
    MethodInsn      :  Opcode * ClassName * MethodName * string -> OpInstruction
    JumpInsn      :  Opcode * LabelName -> OpInstruction
    LdcInsn        :  Opcode * Constant -> OpInstruction
    IincInsn      :  int * int -> OpInstruction
    LookupSwitchInsn  :  LabelName * List(int) * List(LabelName) -> OpInstruction
    TableSwitchInsn    :  int * int * LabelName * List(LabelName) -> OpInstruction
    MultiANewArrayInsn  :  string * int -> OpInstruction

imports
  signatures/-
  syntax/ASM
  trans/translator/translator

rules
  // TODO: This should be in a desugar pass.
  simplify-insn :: Instruction -> ?
  simplify-insn:  ILOAD_0() -> ILOAD(0)
  simplify-insn:  ILOAD_1() -> ILOAD(1)
  simplify-insn:  ILOAD_2() -> ILOAD(2)
  simplify-insn:  ILOAD_3() -> ILOAD(3)
  simplify-insn:  ALOAD_0() -> ALOAD(0)
  simplify-insn:  ALOAD_1() -> ALOAD(1)
  simplify-insn:  ALOAD_2() -> ALOAD(2)
  simplify-insn:  ALOAD_3() -> ALOAD(3)
  simplify-insn:  ASTORE_0() -> ASTORE(0)
  simplify-insn:  ASTORE_1() -> ASTORE(1)
  simplify-insn:  ASTORE_2() -> ASTORE(2)
  simplify-insn:  ASTORE_3() -> ASTORE(3)
  simplify-insn:  ISTORE_0() -> ISTORE(0)
  simplify-insn:  ISTORE_1() -> ISTORE(1)
  simplify-insn:  ISTORE_2() -> ISTORE(2)
  simplify-insn:  ISTORE_3() -> ISTORE(3)

  simplify-insn:  NEWARRAY(n) -> NEWARRAY(<jasmin-arraytype-num> n)

  jasmin-arraytype-num :: BaseTypeName -> int
  jasmin-arraytype-num:  ByteName() -> 8
  jasmin-arraytype-num:  CharName() -> 5
  jasmin-arraytype-num:  DoubleName() -> 7
  jasmin-arraytype-num:  FloatName() -> 6
  jasmin-arraytype-num:  IntName() -> 10
  jasmin-arraytype-num:  LongName() -> 11
  jasmin-arraytype-num:  ShortName() -> 9
  jasmin-arraytype-num:  BooleanName() -> 4

  normalize-constant :: ? -> ?
  normalize-constant: Int(i) -> Int(<to-int> i)
  normalize-varnum  : VarNum(i) -> <try(to-int)> i

  jasmin-instruction-to-asm :: Instruction -> OpInstruction
  jasmin-instruction-to-asm:
    i -> res
    where
      (c, p) := <explode-term> <try(simplify-insn)> i
    ;  (iop, opt) := <jasmin-opcode> c
    ;  res := <jasmin-op-to-asm> (opt, iop, p)

  jasmin-op-to-asm :: Optype * Opcode * List(?) -> OpInstruction
  jasmin-op-to-asm:  (T_INSN(), opcode, [])    -> Insn(opcode)
  jasmin-op-to-asm:  (T_INTINSN(), opcode, ['is])  -> IntInsn(opcode, i)
    where
      i := <try(to-int)> 'is
  jasmin-op-to-asm:  (T_VARINSN(), opcode, [v])  -> VarInsn(opcode, <try(normalize-varnum)> v)
  jasmin-op-to-asm:  (T_TYPEINSN(), opcode, [CRef(tt)])  -> TypeInsn(opcode, tt)
  jasmin-op-to-asm:  (T_TYPEINSN(), opcode, [t])  -> TypeInsn(opcode, tt)
    where
      tt := <jasmin-fieldtype-to-descriptor> t
  jasmin-op-to-asm:  (T_FIELDINSN(), opcode, [fref])    -> FieldInsn(opcode, c, f, desc)
    where
      JBCFieldRef(CRef(c), FRef(f), JBCFieldDesc(ft)) := fref
    ;  desc := <jasmin-fieldtype-to-descriptor> ft
  jasmin-op-to-asm:  (T_METHODINSN(), opcode, [mref])  -> MethodInsn(opcode, c, mm, desc)
    where
      JBCMethodRef(CRef(c), MRef(m), JBCMethodDesc(paramdesc, returndesc)) := mref
    ;  desc := <jasmin-methodtype-to-descriptor> (paramdesc, returndesc)
    ;  mm := <jasmin-methodname-to-name> m
  jasmin-op-to-asm:  (T_METHODINSN(), opcode, [mref, i])  -> result
    where
      result := <jasmin-op-to-asm> (T_METHODINSN(), opcode, [mref])
  jasmin-op-to-asm:  (T_JUMPINSN(), opcode, [LabelRef(l)])  ->  JumpInsn(opcode, l)
  jasmin-op-to-asm:  (T_LDCINSN(), opcode, [c])        ->  LdcInsn(opcode, <try(normalize-constant)> c)
  jasmin-op-to-asm:  (T_IINCINSN(), opcode, [VarNum(var), inc])  ->  IincInsn(vari, inci)
    where
      vari := <try(to-int)> var
    ;  inci := <try(to-int)> inc
  jasmin-op-to-asm:  (T_LOOKUPSWITCH(), _, [pairs, LabelRef(default)]) -> LookupSwitchInsn(default, indices, labels)
    where
      (indices, labels) := <unzip(npair-to-tuple)> pairs
  jasmin-op-to-asm:  (T_TABLESWITCH(), _, [jmin, jlabels, LabelRef(default)]) -> TableSwitchInsn(min, max, default, labels)
    where
      min := <to-int> jmin
    ;  max := <dec> <addi> (min, <length> jlabels)
    ;  labels := <map(jumplabel-name)> jlabels
  jasmin-op-to-asm:  (T_MULTIANEWARRAY(), _, [ttype, tnum])  -> MultiANewArrayInsn(type, num)
    where
      type := <jasmin-fieldtype-to-descriptor> ttype
    ;  num := <to-int> tnum

  npair-to-tuple :: LookupEntry -> int * LabelName
  npair-to-tuple: NPAIR(i, LabelRef(l)) -> (<to-int> i, l)
  jumplabel-name :: LabelRef -> LabelName
  jumplabel-name: LabelRef(l) -> l

  // Zero-operand instructions
  jasmin-opcode :: string -> int * Optype
  jasmin-opcode:  "NOP"    ->  (0,  T_INSN())
  jasmin-opcode:  "ACONST_NULL"    ->  (1,  T_INSN())
  jasmin-opcode:  "ICONST_M1"    ->  (2,  T_INSN())
  jasmin-opcode:  "ICONST_0"    ->  (3,  T_INSN())
  jasmin-opcode:  "ICONST_1"    ->  (4,  T_INSN())
  jasmin-opcode:  "ICONST_2"    ->  (5,  T_INSN())
  jasmin-opcode:  "ICONST_3"    ->  (6,  T_INSN())
  jasmin-opcode:  "ICONST_4"    ->  (7,  T_INSN())
  jasmin-opcode:  "ICONST_5"    ->  (8,  T_INSN())
  jasmin-opcode:  "LCONST_0"    ->  (9,  T_INSN())
  jasmin-opcode:  "LCONST_1"    ->  (10,  T_INSN())
  jasmin-opcode:  "FCONST_0"    ->  (11,  T_INSN())
  jasmin-opcode:  "FCONST_1"    ->  (12,  T_INSN())
  jasmin-opcode:  "FCONST_2"    ->  (13,  T_INSN())
  jasmin-opcode:  "DCONST_0"    ->  (14,  T_INSN())
  jasmin-opcode:  "DCONST_1"    ->  (15,  T_INSN())
  jasmin-opcode:  "IALOAD"    ->  (46,  T_INSN())
  jasmin-opcode:  "LALOAD"    ->  (47,  T_INSN())
  jasmin-opcode:  "FALOAD"    ->  (48,  T_INSN())
  jasmin-opcode:  "DALOAD"    ->  (49,  T_INSN())
  jasmin-opcode:  "AALOAD"    ->  (50,  T_INSN())
  jasmin-opcode:  "BALOAD"    ->  (51,  T_INSN())
  jasmin-opcode:  "CALOAD"    ->  (52,  T_INSN())
  jasmin-opcode:  "SALOAD"    ->  (53,  T_INSN())
  jasmin-opcode:  "IASTORE"    ->  (79,  T_INSN())
  jasmin-opcode:  "LASTORE"    ->  (80,  T_INSN())
  jasmin-opcode:  "FASTORE"    ->  (81,  T_INSN())
  jasmin-opcode:  "DASTORE"    ->  (82,  T_INSN())
  jasmin-opcode:  "AASTORE"    ->  (83,  T_INSN())
  jasmin-opcode:  "BASTORE"    ->  (84,  T_INSN())
  jasmin-opcode:  "CASTORE"    ->  (85,  T_INSN())
  jasmin-opcode:  "SASTORE"    ->  (86,  T_INSN())
  jasmin-opcode:  "POP"    ->  (87,  T_INSN())
  jasmin-opcode:  "POP2"    ->  (88,  T_INSN())
  jasmin-opcode:  "DUP"    ->  (89,  T_INSN())
  jasmin-opcode:  "DUP_X1"    ->  (90,  T_INSN())
  jasmin-opcode:  "DUP_X2"    ->  (91,  T_INSN())
  jasmin-opcode:  "DUP2"    ->  (92,  T_INSN())
  jasmin-opcode:  "DUP2_X1"    ->  (93,  T_INSN())
  jasmin-opcode:  "DUP2_X2"    ->  (94,  T_INSN())
  jasmin-opcode:  "SWAP"    ->  (95,  T_INSN())
  jasmin-opcode:  "IADD"    ->  (96,  T_INSN())
  jasmin-opcode:  "LADD"    ->  (97,  T_INSN())
  jasmin-opcode:  "FADD"    ->  (98,  T_INSN())
  jasmin-opcode:  "DADD"    ->  (99,  T_INSN())
  jasmin-opcode:  "ISUB"    ->  (100,  T_INSN())
  jasmin-opcode:  "LSUB"    ->  (101,  T_INSN())
  jasmin-opcode:  "FSUB"    ->  (102,  T_INSN())
  jasmin-opcode:  "DSUB"    ->  (103,  T_INSN())
  jasmin-opcode:  "IMUL"    ->  (104,  T_INSN())
  jasmin-opcode:  "LMUL"    ->  (105,  T_INSN())
  jasmin-opcode:  "FMUL"    ->  (106,  T_INSN())
  jasmin-opcode:  "DMUL"    ->  (107,  T_INSN())
  jasmin-opcode:  "IDIV"    ->  (108,  T_INSN())
  jasmin-opcode:  "LDIV"    ->  (109,  T_INSN())
  jasmin-opcode:  "FDIV"    ->  (110,  T_INSN())
  jasmin-opcode:  "DDIV"    ->  (111,  T_INSN())
  jasmin-opcode:  "IREM"    ->  (112,  T_INSN())
  jasmin-opcode:  "LREM"    ->  (113,  T_INSN())
  jasmin-opcode:  "FREM"    ->  (114,  T_INSN())
  jasmin-opcode:  "DREM"    ->  (115,  T_INSN())
  jasmin-opcode:  "INEG"    ->  (116,  T_INSN())
  jasmin-opcode:  "LNEG"    ->  (117,  T_INSN())
  jasmin-opcode:  "FNEG"    ->  (118,  T_INSN())
  jasmin-opcode:  "DNEG"    ->  (119,  T_INSN())
  jasmin-opcode:  "ISHL"    ->  (120,  T_INSN())
  jasmin-opcode:  "LSHL"    ->  (121,  T_INSN())
  jasmin-opcode:  "ISHR"    ->  (122,  T_INSN())
  jasmin-opcode:  "LSHR"    ->  (123,  T_INSN())
  jasmin-opcode:  "IUSHR"    ->  (124,  T_INSN())
  jasmin-opcode:  "LUSHR"    ->  (125,  T_INSN())
  jasmin-opcode:  "IAND"    ->  (126,  T_INSN())
  jasmin-opcode:  "LAND"    ->  (127,  T_INSN())
  jasmin-opcode:  "IOR"    ->  (128,  T_INSN())
  jasmin-opcode:  "LOR"    ->  (129,  T_INSN())
  jasmin-opcode:  "IXOR"    ->  (130,  T_INSN())
  jasmin-opcode:  "LXOR"    ->  (131,  T_INSN())
  jasmin-opcode:  "I2L"    ->  (133,  T_INSN())
  jasmin-opcode:  "I2F"    ->  (134,  T_INSN())
  jasmin-opcode:  "I2D"    ->  (135,  T_INSN())
  jasmin-opcode:  "L2I"    ->  (136,  T_INSN())
  jasmin-opcode:  "L2F"    ->  (137,  T_INSN())
  jasmin-opcode:  "L2D"    ->  (138,  T_INSN())
  jasmin-opcode:  "F2I"    ->  (139,  T_INSN())
  jasmin-opcode:  "F2L"    ->  (140,  T_INSN())
  jasmin-opcode:  "F2D"    ->  (141,  T_INSN())
  jasmin-opcode:  "D2I"    ->  (142,  T_INSN())
  jasmin-opcode:  "D2L"    ->  (143,  T_INSN())
  jasmin-opcode:  "D2F"    ->  (144,  T_INSN())
  jasmin-opcode:  "I2B"    ->  (145,  T_INSN())
  jasmin-opcode:  "I2C"    ->  (146,  T_INSN())
  jasmin-opcode:  "I2S"    ->  (147,  T_INSN())
  jasmin-opcode:  "LCMP"    ->  (148,  T_INSN())
  jasmin-opcode:  "FCMPL"    ->  (149,  T_INSN())
  jasmin-opcode:  "FCMPG"    ->  (150,  T_INSN())
  jasmin-opcode:  "DCMPL"    ->  (151,  T_INSN())
  jasmin-opcode:  "DCMPG"    ->  (152,  T_INSN())
  jasmin-opcode:  "IRETURN"    ->  (172,  T_INSN())
  jasmin-opcode:  "LRETURN"    ->  (173,  T_INSN())
  jasmin-opcode:  "FRETURN"    ->  (174,  T_INSN())
  jasmin-opcode:  "DRETURN"    ->  (175,  T_INSN())
  jasmin-opcode:  "ARETURN"    ->  (176,  T_INSN())
  jasmin-opcode:  "RETURN"    ->  (177,  T_INSN())
  jasmin-opcode:  "ARRAYLENGTH"    ->  (190,  T_INSN())
  jasmin-opcode:  "ATHROW"    ->  (191,  T_INSN())
  jasmin-opcode:  "MONITORENTER"    ->  (194,  T_INSN())
  jasmin-opcode:  "MONITOREXIT"    ->  (195,  T_INSN())

  // Integer-operand instructions
  jasmin-opcode:  "BIPUSH"    ->  (16,  T_INTINSN())
  jasmin-opcode:  "SIPUSH"    ->  (17,  T_INTINSN())
  jasmin-opcode:  "NEWARRAY"    ->  (188,  T_INTINSN())

  // Variable-operand instructions
  jasmin-opcode:  "ILOAD"    ->  (21,  T_VARINSN())
  jasmin-opcode:  "LLOAD"    ->  (22,  T_VARINSN())
  jasmin-opcode:  "FLOAD"    ->  (23,  T_VARINSN())
  jasmin-opcode:  "DLOAD"    ->  (24,  T_VARINSN())
  jasmin-opcode:  "ALOAD"    ->  (25,  T_VARINSN())
  jasmin-opcode:  "ISTORE"    ->  (54,  T_VARINSN())
  jasmin-opcode:  "LSTORE"    ->  (55,  T_VARINSN())
  jasmin-opcode:  "FSTORE"    ->  (56,  T_VARINSN())
  jasmin-opcode:  "DSTORE"    ->  (57,  T_VARINSN())
  jasmin-opcode:  "ASTORE"    ->  (58,  T_VARINSN())
  jasmin-opcode:  "RET"    ->  (169,  T_VARINSN())

  // Type-operand instructions
  jasmin-opcode:  "NEW"    ->  (187,  T_TYPEINSN())
  jasmin-opcode:  "ANEWARRAY"    ->  (189,  T_TYPEINSN())
  jasmin-opcode:  "CHECKCAST"    ->  (192,  T_TYPEINSN())
  jasmin-opcode:  "INSTANCEOF"    ->  (193,  T_TYPEINSN())

  // Field-operand instructions
  jasmin-opcode:  "GETSTATIC"    ->  (178,  T_FIELDINSN())
  jasmin-opcode:  "PUTSTATIC"    ->  (179,  T_FIELDINSN())
  jasmin-opcode:  "GETFIELD"    ->  (180,  T_FIELDINSN())
  jasmin-opcode:  "PUTFIELD"    ->  (181,  T_FIELDINSN())

  // Method-operand instructions
  jasmin-opcode:  "INVOKEVIRTUAL"    ->  (182,  T_METHODINSN())
  jasmin-opcode:  "INVOKESPECIAL"    ->  (183,  T_METHODINSN())
  jasmin-opcode:  "INVOKESTATIC"    ->  (184,  T_METHODINSN())
  jasmin-opcode:  "INVOKEINTERFACE"    ->  (185,  T_METHODINSN())

  // Jump instructions
  jasmin-opcode:  "IFEQ"    ->  (153,  T_JUMPINSN())
  jasmin-opcode:  "IFNE"    ->  (154,  T_JUMPINSN())
  jasmin-opcode:  "IFLT"    ->  (155,  T_JUMPINSN())
  jasmin-opcode:  "IFGE"    ->  (156,  T_JUMPINSN())
  jasmin-opcode:  "IFGT"    ->  (157,  T_JUMPINSN())
  jasmin-opcode:  "IFLE"    ->  (158,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPEQ"    ->  (159,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPNE"    ->  (160,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPLT"    ->  (161,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPGE"    ->  (162,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPGT"    ->  (163,  T_JUMPINSN())
  jasmin-opcode:  "IF_ICMPLE"    ->  (164,  T_JUMPINSN())
  jasmin-opcode:  "IF_ACMPEQ"    ->  (165,  T_JUMPINSN())
  jasmin-opcode:  "IF_ACMPNE"    ->  (166,  T_JUMPINSN())
  jasmin-opcode:  "GOTO"      ->  (167,  T_JUMPINSN())
  jasmin-opcode:  "JSR"      ->  (168,  T_JUMPINSN())
  jasmin-opcode:  "IFNULL"    ->  (198,  T_JUMPINSN())
  jasmin-opcode:  "IFNONNULL"    ->  (199,  T_JUMPINSN())

  // Single type instructions
  jasmin-opcode:  "INVOKEDYNAMIC"    ->  (186,  T_INVOKEDYNAMICINSN())
  jasmin-opcode:  "LDC"        ->  (18,  T_LDCINSN())
  jasmin-opcode:  "IINC"        ->  (132,  T_IINCINSN())
  jasmin-opcode:  "Table"        ->  (170,  T_TABLESWITCH())
  jasmin-opcode:  "Lookup"      ->  (171,  T_LOOKUPSWITCH())
  jasmin-opcode:  "MULTIANEWARRAY"  ->  (197,  T_MULTIANEWARRAY())


strategies
  jasmin-instructions-to-asm :: List(Instruction) -> List(OpInstruction)
  jasmin-instructions-to-asm   =  map(jasmin-instruction-to-asm)

  // to-int = (?Neg('is); !'is; to-int; neg) <+ string-to-int
  to-int :: ? -> int
  to-int = (is-int; id) <+ (?Neg('is); !'is; to-int; ?i; !(0, i); subti) <+ (is-string; string-to-int)

imports
  signatures/-
  syntax/ASM
  trans/translator/directives
  trans/translator/flags
  trans/translator/instructions

rules
  jasmin-file-to-asm-class :: JasminFile -> ASMClass
  jasmin-file-to-asm-class:
    JBCFile(JBCHeader(_, _, cspec, sspec, _, _, _, _, _, _), jfields, jmethods) -> ASMClass(196653, iflags, name, None(), super, [], fields, methods)
    where
      name := <jasmin-classspec-get-name> cspec
    ;  super := <jasmin-superspec-to-asm> sspec
    ;  fields := <map(jasmin-field-to-asm-field)> jfields
    ;  methods := <map(jasmin-method-to-asm-method)> jmethods
    ;  iflags := <jasmin-flags-to-int> <jasmin-classspec-get-flags> cspec

  jasmin-classspec-get-name :: ClassSpec -> ClassName
  jasmin-classspec-get-name:
    JBCClass(_, name) -> name
  jasmin-classspec-get-name:
    JBCInterface(_, name) -> name
  jasmin-classspec-get-flags :: ClassSpec -> List(ClassAccess)
  jasmin-classspec-get-flags:
    JBCClass(flags, _) -> flags
  jasmin-classspec-get-flags:
    JBCInterface(flags, _) -> flags

  jasmin-superspec-to-asm :: ? -> ?
  jasmin-superspec-to-asm:
    None() -> None()
  jasmin-superspec-to-asm:
    JBCSuper(s) -> s

  jasmin-field-to-asm-field :: Field -> ASMField
  jasmin-field-to-asm-field:
    JBCField(jflags, name, JBCFieldDesc(jdesc), jsignature, jinit) -> ASMField(iflags, name, desc, None(), None())
    where
      desc := <jasmin-fieldtype-to-descriptor> jdesc
    ;  iflags := <jasmin-flags-to-int> jflags

  jasmin-fieldtype-to-descriptor :: FieldType -> string
  jasmin-fieldtype-to-descriptor:
    Byte() -> "B"
  jasmin-fieldtype-to-descriptor:
    Char() -> "C"
  jasmin-fieldtype-to-descriptor:
    Double() -> "D"
  jasmin-fieldtype-to-descriptor:
    Float() -> "F"
  jasmin-fieldtype-to-descriptor:
    Int() -> "I"
  jasmin-fieldtype-to-descriptor:
    Long() -> "J"
  jasmin-fieldtype-to-descriptor:
    Short() -> "S"
  jasmin-fieldtype-to-descriptor:
    Boolean() -> "Z"
  jasmin-fieldtype-to-descriptor:
    Reference(CRef(c)) -> $[L[c];]
  jasmin-fieldtype-to-descriptor:
    Array(t) -> $[[lb][dt]]
    where
      lb := "["
    ;  dt := <jasmin-fieldtype-to-descriptor> t

  jasmin-method-to-asm-method :: Method -> ASMMethod
  jasmin-method-to-asm-method:
    JBCMethod(jflags, jname, JBCMethodDesc(paramdesc, returndesc), jinstructions) -> ASMMethod(iflags, name, desc, None(), [], instr)
    where
      name := <jasmin-methodname-to-name> jname
    ;  desc := <jasmin-methodtype-to-descriptor> (paramdesc, returndesc)
    ;  iflags := <jasmin-flags-to-int> jflags
    ;  instr := <jasmin-instructions-directives-to-asm> jinstructions

  jasmin-methodname-to-name :: MethodName -> string
  jasmin-methodname-to-name:
    Init() -> "<init>"
  jasmin-methodname-to-name:
    str -> <is-string> str

  jasmin-methodtype-to-descriptor :: List(ParameterDescriptor) * ReturnDescriptor -> string
  jasmin-methodtype-to-descriptor:
    (paramdesc, returndesc) -> result
    where
      paramstr := <concat-strings> <map(jasmin-fieldtype-to-descriptor)> paramdesc
    ;  retstr := <jasmin-returntype-to-descriptor> returndesc
    ;  result := $[([paramstr])[retstr]]

  jasmin-returntype-to-descriptor :: ReturnDescriptor -> string
  jasmin-returntype-to-descriptor:
    Void() -> "V"
  jasmin-returntype-to-descriptor:
    type -> <is(FieldType);jasmin-fieldtype-to-descriptor> type

strategies
  jasmin-instructions-directives-to-asm :: List(Statement) -> List(OpInstruction)
  jasmin-instructions-directives-to-asm  =  collect-maxs; map(jasmin-instruction-to-asm <+ jasmin-directive-to-asm)
