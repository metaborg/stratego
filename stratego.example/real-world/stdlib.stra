module stdlib

// collection/hash-table/common
signature
  constructors

    /**
     * Represents a reference to a hashtable.
     */
    Hashtable : ImplDep -> Hashtable

/**
 * Hashtable construction and deconstruction
 */
strategies

  /**
   * Create a new hashtable with default size and load.
   *
   * @type _ -> HashTable(K, V)
   */ 
  new-hashtable =
    new-hashtable(|117,75)

  /**
   * Create a new hashtable with specified size and load.
   *
   * @param initial_size - the initial capacity of the hashtable
   * @param max_load - the load percentage at which the hashtable is expanded
   * @type _ -> HashTable(K, V)
   */
  new-hashtable(|initial_size, max_load) =
    prim("SSL_hashtable_create", initial_size, max_load); !Hashtable(<id>)

  /**
   * Destroys and deallocates memory consumed by an existing hashtable.
   *
   * @type HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-destroy =
    ?Hashtable(tbl); prim("SSL_hashtable_destroy", tbl); !Hashtable(<id>)

  /**
   * Clears the contents of an existing hashtable.
   *
   * @type HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-clear =
    ?Hashtable(tbl); prim("SSL_hashtable_reset", tbl); !Hashtable(<id>)

/**
 * Hashtable operations
 */
strategies

  /**
   * Puts a new key, value pair into the hash table. If the key is
   * already bound to a value, the old value will be replaced.
   *
   * @param key - any term can be used as a key
   * @param value - any term can be used as a value
   * @type HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-put(|key, value) =
    ?Hashtable(tbl); prim("SSL_hashtable_put", tbl, key, value); !Hashtable(<id>)

  /**
   * Gets the value for a key. If the key does not exist, this strategy
   * fails.
   *
   * @param key
   * @type HashTable(K, V) -> V
   */
  hashtable-get(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_get", tbl, key)

  /**
   * Removes a key (with its associated value) from the hashtable. This
   * strategy will succeed even if the key does not exist.
   *
   * @type HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-remove(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_remove", tbl, key); !Hashtable(<id>)

  /**
   * Get a list containing all keys of a hashtable.
   *
   * @type HashTable(K, V) -> List(K)
   */
  hashtable-keys =
    ?Hashtable(tbl); prim("SSL_hashtable_keys", tbl)

  /**
   * Get a list containing all values of a hashtable
   *
   * @type HashTable(K, V) -> List(V)
   */
  hashtable-values =
    ?htbl
    ; hashtable-keys
    ; map({k: ?k; <hashtable-get(|k)> htbl})

  /**
   * Apply an iterative fold left (starting with first element) over
   * the keys of a hash table; useful for applying an operation to each
   * key without constructing a list of keys.
   *
   * @param (k, v) * a -> a
   * @param a
   * @type HashTable(k, v) -> a
   */
  hashtable-fold(s : k * v * a -> a | t) =
    ?Hashtable(tbl)
    ; prim("SSL_table_fold", s | t, tbl)

  /**
   * Apply an iterative fold left (starting with first element) over
   * the keys of a hash table; useful for applying an operation to each
   * key without constructing a list of keys.
   *
   * @param k * a -> a
   * @param a
   * @type HashTable(k, v) -> a
   */
  hashtable-fold-keys(s : k * a -> a | t) =
    ?Hashtable(tbl)
    ; prim("SSL_table_keys_fold", s | t, tbl)

  /**
   * Apply an iterative fold left (starting with first element) over
   * the values of a hash table; useful for applying an operation to each
   * value without constructing a list of values.
   *
   * @param v * a -> a
   * @param a
   * @type (v * a -> a) * a * HashTable(k, v) -> a
   */
  hashtable-fold-values(s : v * a -> a | t) =
    ?Hashtable(tbl)
    ; prim("SSL_table_values_fold", s | t, tbl)

/**
 * Hashtable bulk operations
 */
strategies

  /**
   * Get the contents of a hashtable as a list of key-value tuples.
   *
   * @type HashTable(k,v) -> List((k,v), ...)
   */
  hashtable-getlist =
    ?htbl
    ; let insert(|k, v) = ![(k, v) | <id>]
       in hashtable-fold(insert | [])
      end

  /**
   * Put a list of key,value tuples into a hashtable.
   *
   * @param kv         List(Tuple(K, V), ...)
   * @type HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-putlist(|kv*) =
    ?htbl
    ; where(<map(\ (key, value) -> <hashtable-put(|key, value)> htbl \)> kv*)

  hashtable-putlist(f : ATerm * ATerm * Hashtable -> Hashtable|kv*) =
    ?htbl
    ; where(<map(\ (key, value) -> <f(|key, value)> htbl \)> kv*)

  /**
   * Create a new hashtable and initialize it from a key-value pair list.
   *
   * @type List(Tuple(K, V), ...) -> HashTable(K, V)
   */
  hashtable-init =
    ?kv*
  ; new-hashtable(|<length>, 75)
  ; hashtable-putlist(|kv*)

  /**
   * Create a new hashtable and copies the entire contents of the current
   * table into the new one.
   *
   * @type HashTable(K, V) -> HashTable(K,V)
   */
  hashtable-copy =
    hashtable-getlist
  ; hashtable-init

/**
 * Stack operations (when stored values in hashtables are list-based stacks)
 */
strategies

  /**
   * Pushes value on top of the stack for key.
   * Current term is the hashtable and remains untouched.
   *
   * @param key        t - the key used for lookup
   * @param value      a - the value to insert
   * @type  HashTable(K, V) -> HashTable(K, V)
   */
  hashtable-push(|key, value) =
    hashtable-put(|key, [value | <hashtable-get(|key) <+ ![]>])

  /**
   * Pushes values on top of the stack for key.
   * Current term is the hashtable and remains untouched.
   *
   * @param key        t       - the key used for lookup
   * @param value      List(a) - the values to insert
   * @type  HashTable(K, V) -> HashTable(K, V')
   */
  hashtable-pushlist(|key, value) =
    hashtable-put(|key, <conc>(value, <hashtable-get(|key) <+ ![]>))

  /**
   * Pushes union of values and already present values
   * Current term is the hashtable.
   *
   * @param key        t       - the key used for lookup
   * @param value      List(a) - the values to insert
   * @type  HashTable(K, V) -> HashTable(K, V')
   */
  hashtable-pushunion(|key, value) =
    hashtable-put(|key, <union>(value, <hashtable-get(|key) <+ ![]>))

  /**
   * Pops off the top element of the stack for key.
   * Current term is the hashtable and remains untouched.
   *
   * @param key        t       - the key used for lookup
   * @type  HashTable(K, (V, ...)) -> V
   */
  hashtable-pop(|key) =
    hashtable-put(|key, <hashtable-get(|key); Tl>)

  /**
   * Gets the top value from the stack for key (the stack remains untouched)
   * Current term is the hashtable, output is the top value.
   *
   * @param key        t       - the key used for lookup
   * @type  HashTable(K, (V, ...)) -> V
   */
  hashtable-peek(|key) =
    hashtable-get(|key); Hd

  /**
   * Gets the top value from the stack for key and pops it off the stack.
   * Current term is the hashtable, output is the top value.
   *
   * @param key        t       - the key used for lookup
   * @type  HashTable(K, (V, ...)) -> V
   */
  hashtable-peekpop(|key) =
    where(hashtable-peek(|key) => val)
  ; hashtable-pop(|key)
  ; !val

/**
 * Mnemonic parameter strategies for hashtable-merge.
 */

strategies

  symmetric-yes = id
  symmetric-no  = fail
  iterate1-yes  = id
  iterate1-no   = fail
  iterate2-yes  = id
  iterate2-no   = fail
  remove-yes    = id
  remove-no     = fail
  default-no    = fail
  change1-yes   = id
  change1-no    = fail
  change2-yes   = id
  change2-no    = fail

strategies

  /**
   * Merge two hashtables changing one or both.
   *
   * This a highly generic strategy for merging two hashtables. The algorithm
   * is parameterized with a number of knobs that determine its behaviour.
   *
   * (A little language for table merging!-)
   *
   * @param symm     : apply changes to both tables, if not apply to tbl1.
   * @param iterate1 : iterate over keys of tbl1
   * @param iterate2 : iterate over keys of tbl2
   * @param remove   : remove table entry if undefined in other table
   * @param merge    : operation on pair of values
   * @param default  : default value in case lookup in other table fails
   * @param lookup1  : given a key produce value for left table
   * @param lookup2  : given a key produce value for right table
   *
   * @todo : with a proper partial evaluator for Stratego this strategy can be
   *         used to create appropriately specialized algorithms.
   */
  hashtable-merge(symm, iterate1, iterate2, remove, merge
                 , default, change1, change2, lookup1, lookup2) :
    (tbl1, tbl2) -> tbl1
    where if iterate1 then
            <hashtable-keys> tbl1
            ; filter({key, val1, val2, val3:
                ?key
                ; if <lookup2> key => val2 then
                    <hashtable-get(|key)> tbl1 => val1
                    ; <merge>(val1, val2) => val3
                    ; ior(
                        if <?val1> val3 then
                          fail // no change to tbl1
                        else
                          <hashtable-put(|key, val3)> tbl1; change1
                        end
                      , if symm; <?val2> val3 then
                          fail // no change to tbl2
                         else
                          <hashtable-put(|key, val3)> tbl2; change2
                        end
                      )
                  else if <default> key => val2 then
                    <hashtable-get(|key)> tbl1 => val1
                    ; <merge>(val1, val2) => val3
                    ; ior(
                        if <?val1> val3 then
                          fail // no change to tbl1
                        else
                          <hashtable-put(|key, val3)> tbl1; change1
                        end
                      , if symm then
                          <hashtable-put(|key, val3)> tbl2; change2
                        end
                      )
                  else // lookup2 failed, no default
                    if remove then
                      <hashtable-remove(|key)> tbl1;
                      if symm then
                        <hashtable-remove(|key)> tbl2; change2
                      end
                    else
                      fail // no change to either table
                    end
                  end end
              })
          else ![] end => changes1

        ; if iterate2 then

            <hashtable-keys> tbl2
            ; filter({key, val1, val2, val3:
                ?key
                ; if iterate1 then not(<hashtable-get(|key)>tbl1) end
                ; if <lookup1> key => val1 then
                    <hashtable-get(|key)> tbl2 => val2
                    ; <merge>(val1, val2) => val3
                    ; ior(if <?val1> val3 then
                            fail // no change to tbl1
                          else
                            <hashtable-put(|key, val3)> tbl1; change1
                          end
                        ,if symm; <?val2> val3 then
                           fail // no change to tbl2
                         else
                           <hashtable-put(|key, val3)> tbl2; change2
                         end
                        )
                  else if <default> key => val1 then
                    <hashtable-get(|key)> tbl2 => val2
                    ; <merge>(val1, val2) => val3
                    ; <hashtable-put(|key, val3)> tbl1
                    ; if symm; <not(?val2)> val3 then
                        <hashtable-put(|key, val3)> tbl2
                      end
                  else // lookup1 failed and no default
                    if remove then
                      <hashtable-remove(|key)> tbl1;
                      if symm then
                        <hashtable-remove(|key)> tbl2; change2
                      end
                    else
                      fail // no change to either table
                    end
                  end end
              })

          else ![] end => changes2
          ; (<not([])> changes1 <+ <not([])> changes2)


  /**
   * Version without change arguments for backward compatibility
   */
  hashtable-merge(symm, iterate1, iterate2, remove, merge, default,
                  lookup1, lookup2) =
  hashtable-merge(symm, iterate1, iterate2, remove, merge, default,
                  change1-yes, change2-yes, lookup1, lookup2)

  /**
   * Merge hashtables creating a new one.
   */
  hashtable-merge-func(iterate1, iterate2, remove, merge, default, lookup1, lookup2) :
    (tbl1, tbl2) -> tbl3
    where <hashtable-copy> tbl1 => tbl3
        ; <hashtable-merge(symmetric-no, iterate1, iterate2, remove, merge, default, lookup1, lookup2)> (tbl3, tbl2)

strategies // intersection merges

  /**
   * Intersect hashtables.
   *
   * Changes tbl1; fails if no changes are made
   * Assumes that both hashtables contains lists as values, and intersects
   * the two listvalues for each key.
   * This is a 'pure' intersection: only keys that appear in both tables
   * remain in the input table, rest is removed.
   */
  hashtable-intersect(|tbl2) =
    ?tbl1
    ; !(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-no,
        iterate1-yes,
        iterate2-no,
        remove-yes,
        isect,
        default-no,
        \ key -> <hashtable-get(|key)> tbl1 \,
        \ key -> <hashtable-get(|key)> tbl2 \
     )

  /**
   * Intersect hashtables with default element.
   *
   * Changes tbl1; fails if no changes are made
   * Assumes that both hashtables contains lists as values, and intersects
   * the two listvalues for each key.
   * Places a dummy value if key does not exist in one of the tables.
   */
  hashtable-intersect-wempty(|tbl2, emptyElt) =
    ?tbl1
    ; !(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-no,
        iterate1-yes,
        iterate2-yes,
        remove-no,
        isect,
        !emptyElt,
        \ key -> <hashtable-get(|key)> tbl1 \,
        \ key -> <hashtable-get(|key)> tbl2 \
     )

  /**
   * Intersect hashtables symmetrically with default element.
   *
   * Changes tbl1 and tbl2; fails if no changes are made in tbl1
   * Assumes that both hashtables contains lists as values, and intersects
   * the two listvalues for each key.
   * Places a dummy value if key does not exist in one of the tables.
   */

  hashtable-intersect-symm-wempty(|emptyElt) =
    ?(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-yes,
        iterate1-yes,
        iterate2-yes,
        remove-no,
        isect,
        !emptyElt,
        \ key -> <hashtable-get(|key)> tbl1 \,
        \ key -> <hashtable-get(|key)> tbl2 \
     )

  /**
   * Intersect hashtables symmetrically with default element.
   *
   * Changes tbl1 and tbl2; fails if no changes are made in tbl1
   * Assumes that both hashtables contains lists as values, and intersects
   * the two listvalues for each key.
   * Places a dummy value if key does not exist in one of the tables.
   */

  hashtable-intersect-symm-wempty-ignore-left(|emptyElt) =
    ?(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-yes,
        iterate1-yes,
        iterate2-yes,
        remove-no,
        isect,
        !emptyElt,
        change1-no,
        change2-yes,
        \ key -> <hashtable-get(|key)> tbl1 \,
        \ key -> <hashtable-get(|key)> tbl2 \
     )

strategies // union merges

  /**
   * Union of hashtables
   *
   * Changes tbl1; fails if no changes are made
   */

  hashtable-union(|tbl2) =
    ?tbl1
    ; !(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-no,
        iterate1-no,
        iterate2-yes,
        remove-no,
        union,
        ![],
        \ key -> <hashtable-get(|key)> tbl1 \,
        fail
     )

  hashtable-union-wempty(|tbl2, emptyElt) =
    ?tbl1
    ; !(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-no,
        iterate1-no,
        iterate2-yes,
        remove-no,
        union,
        !emptyElt,
        \ key -> <hashtable-get(|key)> tbl1 \,
        fail
     )

  hashtable-union-symm-wempty(|emptyElt) =
    ?(tbl1, tbl2)
    ; hashtable-merge(
        symmetric-yes,
        iterate1-yes,
        iterate2-yes,
        remove-no,
        union,
        !emptyElt,
        \ key -> <hashtable-get(|key)> tbl1 \,
        \ key -> <hashtable-get(|key)> tbl2 \
     )

strategies

  /**
   * Checks whether two hashtables have equal contents.
   * This strategy uses the basic `eq` to compare the elements.
   *
   * @type Tuple(HashTable(K, V), HashTable(K,V)) -> _
   */
  hashtable-eq =
    hashtable-eq(eq)

  /**
   * Checks whether two tables have the same keys, and for each key whether
   * the associated values are the same (order of keys thus doesn't matter)
   *
   * @param test strategy that will compare two elements upon their equality.
   * @inc hashtable-eq
   *
   * @type Tuple(HashTable(K, V), HashTable(K,V)) -> _
   */
  hashtable-eq(eq) = ?(tbl1, tbl2);
    where((hashtable-keys => k*, hashtable-keys); set-eq)
  ; where(<map( \ key -> <eq> (<hashtable-get(|key)> tbl1, <hashtable-get(|key)> tbl2) \ )> k*)

/**
 * Legacy table strategies
 */
strategies

  /**
   * Retrieves the primitive table-table as a Hashtable
   *
   */
  table-hashtable =
    prim("SSL_table_hashtable"); !Hashtable(<id>)

  /**
   * Retrieves a named table by looking it up in the table-table.
   */
  lookup-table(|name) =
    table-hashtable
  ; (  hashtable-get(|name)
    <+ where(<table-create> name); hashtable-get(|name))

 /**
  * Creates a table with a given name, which can be any term.
  */
  table-create =
    ?name
  ; where(new-hashtable => htbl)
  ; where(table-hashtable; hashtable-put(|name, htbl))

  /**
   * Destroy a table with a given name, which can be any term.
   */
  table-destroy =
    ?name
  ; where(table-hashtable
    ; where(lookup-table(|name)
          ; hashtable-destroy)
    ; hashtable-remove(|name)
    )

 /**
  * Associate a value with a key in a table.
  *
  * E.g. <table-put> (t1, key, value) associates value with key in the t1 table.
  */
  table-put =
  where(
    ?(name,key,value)
  ; lookup-table(|name)
  ; hashtable-put(|key, value)
  )

 /**
  * Get the value associated with a key from a table.
  *
  * E.g. <table-get> (t1, key) yields the value associated to key or fails in the t1 table.
  */
  table-get =
    ?(name,key)
  ; lookup-table(|name)
  ; hashtable-get(|key)

 /**
  * Remove association of a key in a table.
  *
  * E.g. <table-remove> (t1, key) removes the entry for key from table t1.
  */
  table-remove =
  where(
    ?(name,key)
  ; lookup-table(|name)
  ; hashtable-remove(|key)
  )

 /**
  * Produce a list of keys of a table.
  *
  * E.g. <table-keys>t1 produces the list of keys of table t1.
  */
  table-keys =
    ?name
  ; lookup-table(|name)
  ; hashtable-keys

 /**
  * Renames a table, i.e. only the entry in the table-table is renamed,
  * the table contents remain untouched.
  */
  table-rename =
    ?(from-name, to-name)
  ; where(lookup-table(|from-name) => htbl)
  ; table-hashtable
  ; hashtable-put(|to-name, htbl)
  ; hashtable-remove(|from-name)
  ; !to-name


strategies

 /**
  * Get a list of key-value pairs.
  *
  * E.g. <table-getlist>t1 produces the list of (key,value) pairs in the table t1.
  */
  table-getlist = ?name;
    table-keys; map(\ x -> (x, <table-get> (name, x))\ )

 /**
  * Put a list of key-value pairs in a table.
  *
  * E.g. <table-putlist>(name, list) puts the (key,value) pairs in list into table t1.
  */
  table-putlist = ?(name, list);
    <map({x,y: ?(x, y); <table-put> (name, x, y)})> list

  table-putlist(s) = ?(name, list);
    <map({x,y: ?(x, y); <s> (name, x, y)})> list

  table-copy = ?(name1, name2);
    where(<table-putlist>(name2, <table-getlist> name1))


/*
        Symbol tables that deal with scoped bindings need to be able
        to store multiple bindings for the same symbol. The following
        table operations can be used to maintain a stack (list)
        of values for each key.
*/

strategies

  table-push = ?(dis, key, val);
    where(<table-put>(dis, key, [val | <table-get <+ ![]>(dis, key)]))

  table-pop = ?(dis, key);
    where(<table-put>(dis, key, <table-get; Tl <+ ![]>(dis, key)))

  table-pop-rm = ?(dis, key);
    where(
      <table-get>(dis, key) => [_|xs]
      < <table-put>(dis, key, xs)
      + <table-remove>(dis, key)
    )

  table-pop-get = ?(dis, key);
    where( <table-get>(dis, key) => [val | vals]
         ; <table-put>(dis, key, vals)
         ); !val

  table-lookup = ?(dis, key);
    <table-get>(dis, key); Hd

  table-replace = ?(dis, key, value);
    where(<table-get>(dis, key) => [_|values]
         ; <table-put>(dis, key, [value|values])
         )

  table-union = ?(table, key, val);
    where(<table-put> (table, key, <union> (val, <table-get <+ ![]> (table, key))))

  table-diff = ?(table, key, val);
    where(<table-put> (table, key, <diff> (<table-get <+ ![]> (table, key), val)))

  table-append = ?(table, key, val);
    where(<table-put> (table, key, <union> (<table-get <+ ![]> (table, key), val)))

// collection/hash-table/nested
signature
  constructors
    NestedTable : Hashtable -> TableValue
    Tables      : TableKey
    NewTable    : TableKey
strategies

  nestedtable-put(|keys, value) =
    let forward = try(?NewTable(); !NestedTable(<new-hashtable>); !(<id>,<id>))
     in nestedtable-put(forward, id | keys, value)
    end

  nestedtable-put(forward | keys, value) =
    nestedtable-put(forward, id | keys, value)

  nestedtable-put(forward, changed | keys, value) =
    debug(!"nestedtable-put: ");
    forward
    ; debug(!"nestedtable-put: ")
    ; ?NestedTable(tbl)
    ; <nestedtable-put-aux(forward, changed | tbl, value)> keys

  nestedtable-get(|keys) =
    nestedtable-get(id | keys)

  nestedtable-get(forward | keys) =
    forward
    ; ?NestedTable(tbl)
    ; <nestedtable-get-aux(forward | tbl)> keys

//  nestedtable-remove(|keys) =

//  nestedtable-keys =

//  nestedtable-getlist =

//  nestedtable-putlist(|kv*) =

strategies // hidden

  nestedtable-get-aux(forward | tbl) :
    [] -> tbl

  nestedtable-get-aux(forward | tbl) :
    [key] -> value
    where <hashtable-get(|key)> tbl => value

  nestedtable-get-aux(forward | tbl1) :
    [key1, key2 | keys] -> value
    where <hashtable-get(|key1); forward> tbl1 => NestedTable(tbl2)
  ; <nestedtable-get-aux(forward | tbl2)> [key2 | keys] => value

strategies // hidden

  nestedtable-put-aux(forward, changed | tbl, value) :
    [] -> tbl
    where debug(!"nestedtable-put-aux: "); fail

  nestedtable-put-aux(forward, changed | tbl, value) :
    [key] -> tbl
    where debug(!"nestedtable-put-aux: ");
  <hashtable-put(|key, value)> tbl
  ; <changed> NestedTable(tbl)

  nestedtable-put-aux(forward, changed | tbl1, value) :
    [key1, key2 | keys] -> value
    where debug(!"nestedtable-put-aux: ");
  (<hashtable-get(|key1); forward> tbl1 => NestedTable(tbl2)
           <+ <forward> NewTable() => (x, NestedTable(tbl2))
              ; <hashtable-put(|key1, x)> tbl1
        ; <hashtable-push(|Tables(), key1)
        ; <changed> NestedTable(tbl1)> tbl1)
  ; <nestedtable-put-aux(forward, changed | tbl2, value)> [key2 | keys]

// collection/hash-table/scoepd-finite-map
signature
  constructors
    Scopes : Key

strategies

  init-name-space(ns) =
    where(ns; table-create)

  exit-name-space(ns) =
    where(ns; table-destroy)

  begin-scope(ns) = //debug(!"begin-scope: ");
  where(ns => ns
  ; <table-put>(ns, Scopes(), [[] | <table-get <+ ![]>(ns, Scopes())])
  )

  end-scope(ns) = //debug(!"end-scope: ");
  where(ns => ns
  ; (<table-get; not(?[])>(ns, Scopes()) <+ ![[]]) => [scope | scopes]
  ; <table-put> (ns, Scopes(), scopes)
  ; <map( \ key -> <table-pop-rm>(ns, key) \ )> scope
  )

//  scope(ns, s) =
//    begin-scope(ns); (s; end-scope(ns) <+ end-scope(ns); fail)

  scope(ns, s) =
    begin-scope(ns); restore-always(s, end-scope(ns))

  assert(ns) = ?(key, val); //debug(!"assert: ");
  where(ns => ns
  ; <table-push>(ns, key, val)
  ; (<table-get; not(?[])>(ns, Scopes()) <+ ![[]]) => [scope | scopes]
  ; <table-put>(ns, Scopes(), [[key | scope] | scopes])
  //; debug(!"asserted: ")
  )

  override-key(ns) = ?(key, val); //debug(!"override-key: ");
  where(ns => ns
  ; <table-replace>(ns, key, val)
  //; debug(!"overriden: ")
  )

  rewrite(ns) = //debug(!"rewrite: ");
    \ key -> <table-lookup>(<ns>(), key) \
  //; debug(!"rewriten: ")


// for extend [overide] rules

  extend-assert(ns) = ?(key, val); //debug(!"assert: ");
  where(ns => ns
  ; (<table-get; not(?[])>(ns, Scopes()) <+ ![[]]) => [scope | scopes]
  ; (<elem>(key, scope)
     ; <table-get>(ns, key) => [prevvals | morevals]
     ; <table-put>(ns, key, [[val | prevvals] | morevals])
    <+ <table-push>(ns, key, [val])
       ; <table-put>(ns, Scopes(), [[key | scope] | scopes])
     )
  //; debug(!"asserted: ")
  )

  extend-override-key(ns) = ?(key, val); //debug(!"override-key: ");
  where(ns => ns
    ; <table-get>(ns, key) => [prevvals | morevals]
    ; <table-put>(ns, key, [[val | prevvals] | morevals])
  //; debug(!"overriden: ")
  )

  extend-assert-undefined(ns) = ?key; //debug(!"assert: ");
  where(ns => ns
  ; (<table-get; not(?[])>(ns, Scopes()) <+ ![[]]) => [scope | scopes]
  ; (<elem>(key, scope)
     ; <table-get>(ns, key) => [prevvals | morevals]
     ; <table-put>(ns, key, [[] | morevals])
    <+ <table-push>(ns, key, [])
       ; <table-put>(ns, Scopes(), [[key | scope] | scopes])
     )
  //; debug(!"asserted: ")
  )

  extend-override-key-undefined(ns) = ?key; //debug(!"override-key: ");
  where(ns => ns
    ; <table-get>(ns, key) => [prevvals | morevals]
    ; <table-put>(ns, key, [[] | morevals])
  //; debug(!"overriden: ")
  )

   extend-rewrite(ns) = rewrite(ns)

/*

\paragraph{Usage}

\begin{itemize}

\item \verb|init-name-space(!"fun")| initializes a name space for
function symbols, say.

\item \verb|exit-name-space(!"fun")| destroys the name space.

\item \verb|begin-scope(!"fun")| starts a new scope

\item \verb|end-scope(!"fun")| ends a scope

\item \verb|scope(!"fun", inline)| applies inline to the subject term
in a new scope, which is exited after inline returns, even if inline
fails.

\item \verb|<assert(!"fun")>("foldr", Fdec("foldr", xs, e))| binds a
value (e.g., a function declaration), to a key (e.g., the name of the
function)

\item \verb|<rewrite(!"fun")> "foldr"| retrieves the declaration

\end{itemize}

\paragraph{Example}

For an example see module \verb|scoped-finite-map-test|.

\paragraph{Backtracking}

Be aware that, in general, side-effects are not undone after a
failure.  The \verb|scope| strategy deals with this by catching a
possible failure of the scoped strategy, exiting the scope and then
failing again.

*/

// collection/immutable/map
signature
  constructors
    /**
     * Represents a reference to a Set
     */
    ImmutableMap : ImplDep -> ImmutableMap

/**
 * Immutable map construction and deconstruction
 */
strategies

/**
 * Create an empty immutable map.
 *
 * @type _ -> ImmutableMap
 */
immap-new = prim("SSL_immutable_map"); !ImmutableMap(<id>)

/**
 * Create an immutable map from a list of pairs.
 * If multiple keys map to the same value, the first value in the list is kept.
 *
 * @type List -> ImmutableMap
 */
immap-from-list = immap-from-list(Fst)

/**
 * Create an immutable map from a list of pairs.
 * If multiple keys map to the same value, the given strategy merges the values of the intersecting
 * keys.
 *
 * @param merge: Term * Term -> Term
 * @type List -> ImmutableMap
 */
immap-from-list(merge) = prim("SSL_immutable_map_from_list", merge|); !ImmutableMap(<id>)

/**
 * Turn the immutable map into a list of pairs.
 *
 * @type ImmutableMap -> List
 */
immap-to-list = ?ImmutableMap(<id>); prim("SSL_immutable_map_to_list")

/**
 * Turn the immutable map into an immutable relation.
 *
 * @type ImmutableMap -> ImmutableRelation
 */
immap-to-imrel = ?ImmutableMap(<id>); prim("SSL_immutable_map_to_relation"); !ImmutableRelation(<id>)

/**
 * Get all keys of the immutable map.
 *
 * @type ImmutableMap -> List
 */
immap-keys = ?ImmutableMap(<id>); prim("SSL_immutable_map_keys")

/**
 * Get all keys of the immutable map as an immutable set.
 *
 * @type ImmutableMap -> List
 */
immap-keys-imset = ?ImmutableMap(<id>); prim("SSL_immutable_map_keys_to_set"); !ImmutableSet(<id>)

/**
 * Get all values of the immutable map.
 *
 * @type ImmutableMap -> List
 */
immap-values = ?ImmutableMap(<id>); prim("SSL_immutable_map_values")

/**
 * Get all values of the immutable map.
 *
 * @type ImmutableMap -> ImmutableSet
 */
immap-values-imset = ?ImmutableMap(<id>); prim("SSL_immutable_map_values"); imset-from-list

/**
 * Elemental operations
 */
strategies

/**
 * Succeeds if the given immutable map is empty.
 *
 * @type ImmutableMap -?> ImmutableMap
 */
immap-empty = equal(|<immap-new>)

/**
 * Succeeds if the key is in the immutable map.
 *
 * @param k - the key
 * @type ImmutableMap -?> ImmutableMap
 */
immap-contains-key(|k) = where(immap-get(|k))

/**
 * Succeeds if the key is in the immutable map.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param k - the key
 * @type ImmutableMap -?> ImmutableMap
 */
immap-contains-key(eq|k) = where(immap-get(eq|k))

/**
 * Returns the associated value of the key in the immutable map,
 * or fails if the key is not in the immutable map.
 *
 * @param e - the key used to look up the value
 * @type ImmutableMap -?> Term
 */
immap-get(|k) = ?ImmutableMap(<id>); prim("SSL_immutable_map_get", k)

/**
 * Returns the associated value of the key in the immutable map,
 * or fails if the key is not in the immutable map.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the key used to look up the value
 * @type ImmutableMap -?> Term
 */
immap-get(eq|k) = ?ImmutableMap(<id>); prim("SSL_immutable_map_get_eq", eq | k)

/**
 * Inserts an element in the immutable map. Returns a new map with the added element.
 *
 * @param e - the element that is inserted
 * @type ImmutableMap -> ImmutableMap
 */
immap-put(|k, v) = ImmutableMap(prim("SSL_immutable_map_put", k, v))

/**
 * Inserts an element in the immutable map. Returns a new map with the added element.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the element that is inserted
 * @type ImmutableMap -> ImmutableMap
 */
immap-put(eq|k, v) = ImmutableMap(prim("SSL_immutable_map_put_eq", eq | k, v))

/**
 * Removes an element in the immutable map. Returns a new map without the removed element.
 *
 * @param e - the element that is removed
 * @type ImmutableMap -> ImmutableMap
 */
immap-remove(|k) = ImmutableMap(prim("SSL_immutable_map_remove", k))

/**
 * Removes an element in the immutable map. Returns a new map without the removed element.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the element that is removed
 * @type ImmutableMap -> ImmutableMap
 */
immap-remove(eq|k) = ImmutableMap(prim("SSL_immutable_map_remove_eq", eq | k))

/**
 * Higher-order operations
 */
strategies

/**
 * Remove all pairs from the immutable map for which the filter strategy fails.
 * Returns a new immutable map without the removed pairs.
 * For pairs mapped to the same key the values are merged with the second parameter.
 * This version gives the merge function the key as well as the pair of values to merge.
 *
 * @param s: Term * Term -?> Term * Term
 * @param merge: Term * (Term * Term) -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-filter'(s, merge) = ImmutableMap(prim("SSL_immutable_map_filter", s, merge|))

/**
 * Remove all pairs from the immutable map for which the filter strategy fails.
 * Returns a new immutable map without the removed pairs.
 * For pairs mapped to the same key the values are merged with the second parameter.
 *
 * @param s: Term * Term -?> Term * Term
 * @param merge: Term * Term -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-filter(s, merge) = immap-filter'(s, Snd;merge)

/**
 * Remove all pairs from the immutable map for which the filter strategy fails.
 * Returns a new immutable map without the removed pairs.
 * Pairs mapped to the same key keep one of the values (chosen arbitrarily).
 *
 * @param s: Term * Term -?> Term * Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-filter(s) = immap-filter(s, Fst)

/**
 * Remove all pairs from the immutable map for which the filter strategy fails on the key.
 * Returns a new immutable map without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-filter-keys(s) = immap-filter((s, id))

/**
 * Remove all pairs from the immutable map for which the filter strategy fails on the value.
 * Returns a new immutable map without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-filter-values(s) = immap-filter((id, s))

/**
 * Map all pairs from the immutable map.
 * Returns a new immutable map with the mapped pairs.
 * For pairs mapped to the same key the values are merged with the second parameter.
 * This version gives the merge function the key as well as the pair of values to merge.
 *
 * @param s: Term * Term -?> Term * Term
 * @param merge: Term * (Term * Term) -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-map'(s, merge) = ImmutableMap(prim("SSL_immutable_map_map", s, merge|))

/**
 * Map all pairs from the immutable map.
 * Returns a new immutable map with the mapped pairs.
 * For pairs mapped to the same key the values are merged with the second parameter.
 *
 * @param s: Term * Term -?> Term * Term
 * @param merge: Term * Term -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-map(s, merge) = immap-map'(s, Snd;merge)

/**
 * Map all pairs from the immutable map.
 * Returns a new immutable map with the mapped pairs.
 * Pairs mapped to the same key keep one of the values (chosen arbitrarily).
 *
 * @param s: Term -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-map(s) = immap-map(s, Fst)

/**
 * Map all keys from the immutable map.
 * Returns a new immutable map with the mapped keys.
 * For pairs mapped to the same key the values are merged with the second parameter.
 *
 * @param s: Term -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-map-keys(s, merge) = immap-map((s, id), merge)

/**
 * Map all values from the immutable map.
 * Returns a new immutable map with the mapped values.
 *
 * @param s: Term -> Term
 * @type ImmutableMap -> ImmutableMap
 */
immap-map-values(s) = immap-map((id, s))

/**
 * Combining operations
 */
strategies

/**
 * Intersect with another immutable map.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @param m: Term * Term -> Term
 * @param other: ImmutableMap
 * @type ImmutableMap -> ImmutableMap
 */
immap-intersect(m|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_intersect", m | other))

/**
 * Intersect two immutable maps.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @param m: Term * Term -> Term
 * @type ImmutableMap * ImmutableMap -> ImmutableMap
 */
immap-intersect(m) =
  ?(l, r); <immap-intersect(m|r)> l

/**
 * Intersect with an immutable set.
 * Returns a new immutable map with the pairs where the key was in the immutable set.
 *
 * @param other: ImmutableSet
 * @type ImmutableMap -> ImmutableMap
 */
immap-intersect-set(|r) = where(ImmutableSet(other) := r);
  ImmutableMap(prim("SSL_immutable_map_intersect_set", other))

/**
 * Intersect the left immutable map with the right immutable set.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-intersect-set =
  ?(l, r); <immap-intersect-set(|r)> l

/**
 * Subtract another immutable map from the given one.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @param other: ImmutableMap - the map to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-subtract(|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_subtract", other))

/**
 * Subtract the right immutable map from the left.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @type ImmutableMap * ImmutableMap -> ImmutableMap
 */
immap-subtract =
  ?(l, r); <immap-subtract(|r)> l

/**
 * Subtract an immutable set from the immutable map.
 * Returns a new immutable map without the pairs where the key was in the immutable set.
 *
 * @param other: ImmutableSet - the set to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-subtract-set(|r) = where(ImmutableSet(other) := r);
  ImmutableMap(prim("SSL_immutable_map_subtract_set", other))

/**
 * Subtract the right immutable set from the left immutable map.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-subtract-set =
  ?(l, r); <immap-subtract(|r)> l

/**
 * Union with another immutable map.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new set with the union.
 *
 * @param m: Term * Term -> Term
 * @param other: ImmutableMap - the map to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-union(m|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_union", m | other))

/**
 * Union two immutable maps.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new map with the union.
 *
 * @param m: Term * Term -> Term
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-union(m) =
  ?(l, r); <immap-union(m|r)> l

/**
 * Combining operations with custom equality operator (prefers the current/left elements)
 */
strategies

/**
 * Intersect with another immutable map.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @param m: Term * Term -> Term
 * @param eq: Term * Term -?>
 * @param other: ImmutableMap
 * @type ImmutableMap -> ImmutableMap
 */
immap-intersect(m, eq|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_intersect_eq", m, eq | other))

/**
 * Intersect two immutable maps.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @param m: Term * Term -> Term
 * @param eq: Term * Term -?>
 * @type ImmutableMap * ImmutableMap -> ImmutableMap
 */
immap-intersect(m, eq) =
  ?(l, r); <immap-intersect(m, eq|r)> l

/**
 * Intersect with an immutable set.
 * Returns a new immutable map with the pairs where the key was in the immutable set.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet
 * @type ImmutableMap -> ImmutableMap
 */
immap-intersect-set(eq|r) = where(ImmutableSet(other) := r);
  ImmutableMap(prim("SSL_immutable_map_intersect_set_eq", eq | other))

/**
 * Intersect the left immutable map with the right immutable set.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable map with the intersection.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-intersect-set(eq) =
  ?(l, r); <immap-intersect-set(eq|r)> l

/**
 * Subtract another immutable map from the given one.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableMap - the map to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-subtract(eq|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_subtract_eq", eq | other))

/**
 * Subtract the right immutable map from the left.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableMap * ImmutableMap -> ImmutableMap
 */
immap-subtract(eq) =
  ?(l, r); <immap-subtract(eq|r)> l

/**
 * Subtract an immutable set from the immutable map.
 * Returns a new immutable map without the pairs where the key was in the immutable set.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet - the set to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-subtract-set(eq|r) = where(ImmutableSet(other) := r);
  ImmutableMap(prim("SSL_immutable_map_subtract_set_eq", eq | other))

/**
 * Subtract the right immutable set from the left immutable map.
 * Returns a new immutable map without the pairs where the key was a key in the immutable map.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-subtract-set(eq) =
  ?(l, r); <immap-subtract(eq|r)> l

/**
 * Union with another immutable map.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new map with the union.
 *
 * @param m: Term * Term -> Term
 * @param eq: Term * Term -?>
 * @param other: ImmutableMap - the map to remove from the current term immutable map
 * @type ImmutableMap -> ImmutableMap
 */
immap-union(m, eq|r) = where(ImmutableMap(other) := r);
  ImmutableMap(prim("SSL_immutable_map_union_eq", m, eq | other))

/**
 * Union two immutable maps.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new map with the union.
 *
 * @param m: Term * Term -> Term
 * @param eq: Term * Term -?>
 * @type ImmutableMap * ImmutableSet -> ImmutableMap
 */
immap-union(m, eq) =
  ?(l, r); <immap-union(m, eq|r)> l

// collection/immutable/rel
signature
  constructors
    /**
     * Represents a reference to a Set
     */
    ImmutableRelation : ImplDep -> ImmutableRelation

/**
 * Immutable relation construction and deconstruction
 */
strategies

/**
 * Create an empty immutable relation.
 *
 * @type _ -> ImmutableRelation
 */
imrel-new = prim("SSL_immutable_relation"); !ImmutableRelation(<id>)

/**
 * Create an immutable relation from a list of pairs.
 *
 * @type List -> ImmutableRelation
 */
imrel-from-list = prim("SSL_immutable_relation_from_list"); !ImmutableRelation(<id>)

/**
 * Turn the immutable relation into a list of pairs.
 *
 * @type ImmutableRelation -> List
 */
imrel-to-list = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_list")

/**
 * Turn the immutable relation into a map.
 * For pairs with the same key, the values are merged with the second parameter.
 *
 * @type ImmutableRelation -> ImmutableMap
 */
imrel-to-map(merge) = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_map", merge|); !ImmutableMap(<id>)

/**
 * Turn the immutable relation into a list of pairs.
 *
 * @type ImmutableRelation -> List
 */
imrel-pairs = imrel-to-list

/**
 * Turn the immutable relation into a set of pairs.
 *
 * @type ImmutableRelation -> ImmutableSet
 */
imrel-pairs-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_to_set"); !ImmutableSet(<id>)

/**
 * Get all keys of the immutable relation.
 *
 * @type ImmutableRelation -> List
 */
imrel-keys = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_keys")

/**
 * Get all keys of the immutable relation as an immutable set.
 *
 * @type ImmutableRelation -> List
 */
imrel-keys-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_keys_set"); !ImmutableSet(<id>)

/**
 * Get all values of the immutable relation.
 *
 * @type ImmutableRelation -> List
 */
imrel-values = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_values")

/**
 * Get all values of the immutable relation.
 *
 * @type ImmutableRelation -> ImmutableSet
 */
imrel-values-imset = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_values_set"); !ImmutableSet(<id>)

/**
 * Take the transitive closure of the relation.
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-transitive-closure = ImmutableRelation(prim("SSL_immutable_relation_transitive_closure"))

/**
 * Take the reflexive transitive closure of the relation.
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-reflexive-transitive-closure =
  ImmutableRelation(prim("SSL_immutable_relation_reflexive_transitive_closure"))

/**
 * Invert the relation (swap all the pairs).
 *
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-invert =
  ImmutableRelation(prim("SSL_immutable_relation_inverse"))

/**
 * Elemental operations
 */
strategies

/**
 * Succeeds if the given immutable relation is empty.
 *
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-empty = equal(|<imrel-new>)

/**
 * Succeeds if the key is in the immutable relation.
 *
 * @param k - the key
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-contains-key(|k) = where(imrel-get(|k); not(imset-empty))

/**
 * Succeeds if the key is in the immutable relation.
 *
 * @param k - the key
 * @type ImmutableRelation -?> ImmutableRelation
 */
imrel-contains(|k, v) = ImmutableRelation(prim("SSL_immutable_relation_contains", k, v))

/**
 * Returns the associated value of the key in the immutable relation,
 * or fails if the key is not in the immutable relation.
 *
 * @param e - the key used to look up the value
 * @type ImmutableRelation -?> ImmutableSet
 */
imrel-get(|k) = ?ImmutableRelation(<id>); prim("SSL_immutable_relation_get", k); !ImmutableSet(<id>)

/**
 * Inserts an element in the immutable relation. Returns a new relation with the added element.
 *
 * @param e - the element that is inserted
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-insert(|k, v) = ImmutableRelation(prim("SSL_immutable_relation_insert", k, v))

/**
 * Removes an element in the immutable relation. Returns a new relation without the removed element.
 *
 * @param e - the element that is removed
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-remove(|k) = ImmutableRelation(prim("SSL_immutable_relation_remove", k))

/**
 * Higher-order operations
 */
strategies

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term * Term -?> Term * Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter(s) = ImmutableRelation(prim("SSL_immutable_relation_filter", s|))

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails on the key.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter-keys(s) = imrel-filter((s, id))

/**
 * Remove all pairs from the immutable relation for which the filter strategy fails on the value.
 * Returns a new immutable relation without the removed pairs.
 *
 * @param s: Term -?> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-filter-values(s) = imrel-filter((id, s))

/**
 * Map all pairs from the immutable relation.
 * Returns a new immutable relation with the mapped pairs.
 *
 * @param s: Term * Term -?> Term * Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map(s) = ImmutableRelation(prim("SSL_immutable_relation_map", s|))

/**
 * Map all keys from the immutable relation.
 * Returns a new immutable relation with the mapped keys.
 *
 * @param s: Term -> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map-keys(s) = imrel-map((s, id))

/**
 * Map all values from the immutable relation.
 * Returns a new immutable relation with the mapped values.
 *
 * @param s: Term -> Term
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-map-values(s) = imrel-map((id, s))

/**
 * Combining operations
 */
strategies

/**
 * Compose with another immutable relation.
 * Returns a new immutable relation with all pairs (x,z) where there is a y such that (x,y) in this
 * and (y,z) in other.
 *
 * @param other: ImmutableRelation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-compose(|r) =  where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_compose", other))

/**
 * Intersect with another immutable relation.
 * Returns a new immutable relation with the pairs that are in both relations.
 *
 * @param other: ImmutableRelation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-intersect(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_intersect", other))

/**
 * Intersect two immutable relations.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new immutable relation with the intersection.
 *
 * @param m: Term * Term -> Term
 * @type ImmutableRelation * ImmutableRelation -> ImmutableRelation
 */
imrel-intersect =
  ?(l, r); <imrel-intersect(|r)> l

/**
 * Subtract another immutable relation from the given one.
 * Returns a new immutable relation without the pairs in the other immutable relation.
 *
 * @param other: ImmutableRelation - the relation to remove from the current term immutable relation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-subtract(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_subtract", other))

/**
 * Subtract the right immutable relation from the left.
 * Returns a new immutable relation without the pairs in the other immutable relation.
 *
 * @type ImmutableRelation * ImmutableRelation -> ImmutableRelation
 */
imrel-subtract =
  ?(l, r); <imrel-subtract(|r)> l

/**
 * Union with another immutable relation.
 * Returns a new relation with the union of the pairs in the two relation.
 *
 * @param other: ImmutableRelation - the relation to remove from the current term immutable relation
 * @type ImmutableRelation -> ImmutableRelation
 */
imrel-union(|r) = where(ImmutableRelation(other) := r);
  ImmutableRelation(prim("SSL_immutable_relation_union", other))

/**
 * Union two immutable relations.
 * The given strategy merges the values of the intersecting keys.
 * Returns a new relation with the union.
 *
 * @param m: Term * Term -> Term
 * @type ImmutableRelation * ImmutableSet -> ImmutableRelation
 */
imrel-union =
  ?(l, r); <imrel-union(|r)> l

// collection/immutable/set
signature
  constructors
    /**
     * Represents a reference to a Set
     */
    ImmutableSet : ImplDep -> ImmutableSet

/**
 * Immutable set construction and deconstruction
 */
strategies

/**
 * Create an empty immutable set.
 *
 * @type _ -> ImmutableSet
 */
imset-new = prim("SSL_immutable_set"); !ImmutableSet(<id>)

/**
 * Create an immutable set from a list.
 *
 * @type List -> ImmutableSet
 */
imset-from-list = prim("SSL_immutable_set_from_list"); !ImmutableSet(<id>)

/**
 * Turn the immutable set into a list.
 *
 * @type ImmutableSet -> List
 */
imset-to-list = imset-elements

/**
 * Get all elements of the immutable set.
 *
 * @type ImmutableSet -> List
 */
imset-elements = ?ImmutableSet(<id>); prim("SSL_immutable_set_elements")

/**
 * Elemental operations
 */
strategies

/**
 * Succeeds if the given immutable set is empty.
 *
 * @type ImmutableSet -?> ImmutableSet
 */
imset-empty = equal(|<imset-new>)

/**
 * Succeeds if element is in the immutable set.
 *
 * @param e - the element that containment is tested for
 * @type ImmutableSet -?> ImmutableSet
 */
imset-contains(|e) = ImmutableSet(prim("SSL_immutable_set_contains", e))

/**
 * Succeeds is element is in the immutable set.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the element that containment is tested for
 * @type ImmutableSet -?> ImmutableSet
 */
imset-contains(eq|e) = ImmutableSet(prim("SSL_immutable_set_contains_eq", eq | e))

/**
 * Inserts an element in the immutable set. Returns a new set with the added element.
 *
 * @param e - the element that is inserted
 * @type ImmutableSet -> ImmutableSet
 */
imset-insert(|e) = ImmutableSet(prim("SSL_immutable_set_insert", e))

/**
 * Inserts an element in the immutable set. Returns a new set with the added element.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the element that is inserted
 * @type ImmutableSet -> ImmutableSet
 */
imset-insert(eq|e) = ImmutableSet(prim("SSL_immutable_set_insert_eq", eq | e))

/**
 * Removes an element in the immutable set. Returns a new set without the removed element.
 *
 * @param e - the element that is removed
 * @type ImmutableSet -> ImmutableSet
 */
imset-remove(|e) = ImmutableSet(prim("SSL_immutable_set_remove", e))

/**
 * Removes an element in the immutable set. Returns a new set without the removed element.
 * With a custom equality operator.
 *
 * @param eq: Term * Term -?>
 * @param e - the element that is removed
 * @type ImmutableSet -> ImmutableSet
 */
imset-remove(eq|e) = ImmutableSet(prim("SSL_immutable_set_remove_eq", eq | e))

/**
 * Higher-order operations
 */
strategies

/**
 * Remove all elements from the immutable set for which the filter strategy fails.
 * Returns a new set without the removed elements.
 *
 * @param s: Term -?> Term
 * @type ImmutableSet -> ImmutableSet
 */
imset-filter(s) = ImmutableSet(prim("SSL_immutable_set_filter", s|))

/**
 * Map all elements from the immutable set.
 * Returns a new set with the mapped elements.
 *
 * @param s: Term -> Term
 * @type ImmutableSet -> ImmutableSet
 */
imset-map(s) = ImmutableSet(prim("SSL_immutable_set_map", s, id|))

/**
 * Map all elements from the immutable set.
 * Extra parameter m is called on a mapped element that was previously mapped to.
 * This can be used to observe duplicate mapped elements or to change them into
 * something unique so they still end up in the result set.
 * Returns a new set with the mapped elements.
 *
 * @param s: Term -> Term
 * @param m: Term -> Term
 * @type ImmutableSet -> ImmutableSet
 */
imset-map(s, m) = ImmutableSet(prim("SSL_immutable_set_map", s, m|))

/**
 * Combining operations
 */
strategies

/**
 * Intersect with another immutable set.
 * Returns a new set with the intersection.
 *
 * @param other: ImmutableSet
 * @type ImmutableSet -> ImmutableSet
 */
imset-intersect(|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_intersect", other))

/**
 * Intersect two immutable sets.
 * Returns a new set with the intersection.
 *
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-intersect =
  ?(l, r); <imset-intersect(|r)> l

/**
 * Subtract another immutable set from the given one.
 * Returns a new set without the elements from the immutable set in the term argument.
 *
 * @param other: ImmutableSet - the set to remove from the current term immutable set
 * @type ImmutableSet -> ImmutableSet
 */
imset-subtract(|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_subtract", other))

/**
 * Subtract the right immutable set from the left.
 * Returns a new set without the elements from the immutable set in the term argument.
 *
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-subtract =
  ?(l, r); <imset-subtract(|r)> l

/**
 * Union with another immutable set.
 * Returns a new set with the union.
 *
 * @param other: ImmutableSet - the set to remove from the current term immutable set
 * @type ImmutableSet -> ImmutableSet
 */
imset-union(|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_union", other))

/**
 * Union two immutable sets.
 * Returns a new set with the union.
 *
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-union =
  ?(l, r); <imset-union(|r)> l

/**
 * Combining operations with custom equality operator (prefers the current/left elements)
 */
strategies

/**
 * Intersect with another immutable set.
 * Returns a new set with the intersection.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet
 * @type ImmutableSet -> ImmutableSet
 */
imset-intersect(eq|r) = where(ImmutableSet(other) := r);
  ?ImmutableSet(_); prim("SSL_immutable_set_intersect_eq", eq | other)

/**
 * Intersect two immutable sets.
 * Returns a new set with the intersection.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-intersect(eq) =
  ?(l, r); <imset-intersect(eq|r)> l

/**
 * Subtract another immutable set from the given one.
 * Returns a new set without the elements from the immutable set in the term argument.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet - the set to remove from the current term immutable set
 * @type ImmutableSet -> ImmutableSet
 */
imset-subtract(eq|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_subtract_eq", eq | other))

/**
 * Subtract the right immutable set from the left.
 * Returns a new set without the elements from the immutable set in the term argument.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-subtract(eq) =
  ?(l, r); <imset-subtract(eq|r)> l

/**
 * Union with another immutable set.
 * Returns a new set with the union.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet - the set to remove from the current term immutable set
 * @type ImmutableSet -> ImmutableSet
 */
imset-union(eq|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_union_eq", eq | other))

/**
 * Union two immutable sets.
 * Returns a new set with the union.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableSet * ImmutableSet -> ImmutableSet
 */
imset-union(eq) =
  ?(l, r); <imset-union(eq|r)> l

/**
 * Comparison operations
 */
strategies

/**
 * Strict subset comparison with another immutable set.
 * Fails if not a strict subset of the given other set.
 *
 * @param other: ImmutableSet - the set to test if superset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-subset(|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_strict_subset", other))

/**
 * Strict subset comparison between left and right immutable set.
 * Fails if left set is not a strict subset of the right set.
 *
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-subset =
  ?(l, r); where(<imset-subset(|r)> l)

/**
 * Strict superset comparison with another immutable set.
 * Fails if not a strict superset of the given other set.
 *
 * @param other: ImmutableSet - the set to test if subset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-superset(|r): l -> <imset-subset(|l);!l> r

/**
 * Strict superset comparison between left and right immutable set.
 * Fails if left set is not a strict superset of the right set.
 *
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-superset =
  ?(l, r); where(<imset-superset(|r)> l)

/**
 * Strict subset comparison with another immutable set.
 * Fails if not a strict subset of the given other set.
 *
 * @param other: ImmutableSet - the set to test if superset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-subset-eq(|r) = where(ImmutableSet(other) := r);
  ( ImmutableSet(prim("SSL_immutable_set_strict_subset", other))
  <+ ?ImmutableSet(r))

/**
 * Strict subset comparison between left and right immutable set.
 * Fails if left set is not a strict subset of the right set.
 *
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-subset-eq =
  ?(l, r); where(<imset-subset-eq(|r)> l)

/**
 * Strict superset comparison with another immutable set.
 * Fails if not a strict superset of the given other set.
 *
 * @param other: ImmutableSet - the set to test if subset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-superset-eq(|r): l -> <imset-subset-eq(|l);!l> r

/**
 * Strict superset comparison between left and right immutable set.
 * Fails if left set is not a strict superset of the right set.
 *
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-superset-eq =
  ?(l, r); where(<imset-superset-eq(|r)> l)

/**
 * Comparison operations with custom equality operator (prefers the current/left elements)
 */
strategies

/**
 * Strict subset comparison with another immutable set.
 * Fails if not a strict subset of the given other set.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet - the set to test if superset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-subset(eq|r) = where(ImmutableSet(other) := r);
  ImmutableSet(prim("SSL_immutable_set_strict_subset_eq", eq | other))

/**
 * Strict subset comparison between left and right immutable set.
 * Fails if left set is not a strict subset of the right set.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-subset(eq) =
  ?(l, r); where(<imset-subset(eq|r)> l)

/**
 * Strict superset comparison with another immutable set.
 * Fails if not a strict superset of the given other set.
 *
 * @param eq: Term * Term -?>
 * @param other: ImmutableSet - the set to test if subset of current set
 * @type ImmutableSet -?> ImmutableSet
 */
imset-superset(eq|r): l -> <imset-subset(eq|l);!l> r

/**
 * Strict superset comparison between left and right immutable set.
 * Fails if left set is not a strict superset of the right set.
 *
 * @param eq: Term * Term -?>
 * @type ImmutableSet * ImmutableSet -?> ImmutableSet * ImmutableSet
 */
imset-superset(eq) =
  ?(l, r); where(<imset-superset(eq|r)> l)

// collection/list/bag
rules

  /**
   * Inserts a new element into a bag. The element must be on the form
   * a (element, occurrence) tuple, where occurrence is an integer. The
   * bag may be empty.
   *
   * Example: <bag-insert> (('a', 1), []) => [('a',1)]
   *
   * @type (elem, occur) * List(a) -> List(a)
   */
  bag-insert :
    ((x,j), l) ->
    <fetch(\ (y,i) -> (y, <add>(i,j)) where <eq>(y,x) \ ) <+ ![(x,j)|l]> l

  /**
   * Takes the union of two bags.
   *
   * Example: <bag-union> ([('a',2), ('b',1)], [('a',1)]) => [('b',1),('a',3)]
   *
   * @type List(a) * List(a) -> List(a)
   */
  bag-union :
    (l1, l2) -> <foldr(!l2, bag-insert)> l1


  /**
   * Inserts a new element into a bag. The element must be on the form
   * a (element, occurrence) tuple, where occurrence is an integer. The
   * bag may be empty.  The strategy parameter is used to check elements
   * for equality.
   *
   * @param  Used to test equality on elements.
   * @type   (elem, occurrence) * List(a) -> List(a)
   */
  bag-insert(equ) :
    ((x,j), l) ->
    <fetch(\ (y,i) -> (<equ>(x,y), <add>(i,j)) \ ) <+ ![(x,j)|l]> l

  /**
   * Takes the union of two bags. The strategy parameter is used
   * to check elements for equality.
   *
   * @param  Used to test equality on elements.
   * @type   List(a) * List(a) -> List(a)
   */
  bag-union(equ) :
    (l1, l2) -> <foldr(!l2, bag-insert(equ))> l1

// collection/list/common
strategies

  /**
   * Iterative loop over a list applying s to each element.
   *
   * @param Strategy to apply to every element (a -> _)
   * @type List(a) -> List(a)
   */
  list-loop(s) =
    ?xs; prim("SSL_list_loop", s | xs)

  /**
   * Iterative fold over a list applying s to each element and
   * accumulator acc from left to right.
   *
   * @param Strategy applied for folding. The current
   *        intermediate result is a term argument. The next element
   *        of the list is the current term.
   * @param Initial value for folding (type: c)
   * @type List(a) -> c
   */
  list-fold(s : c * a -> c | acc) =
    ?xs; prim("SSL_list_fold", s | acc, xs)

strategies

  /** @internal */
  Hd   : [x | _] -> x

  /** @internal */
  Tl   : [_ | l] -> l

  /** @internal */
  Last : [x]     -> x

  /**
   * @internal
   * @type a -> List(a)
   */
  MkSingleton =
    ![<id>]

  /**
   * Splits a Cons into a tuple with head and tail.
   *
   * @type List(a) -> (a, List(a))
   */
  split-Cons :
    [x | xs] -> (x, xs)

  /**
   * Makes a Cons out of a tuple with head and tail. The
   * tail must be a list, but may be the empty list.
   *
   * @type (a, List(a)) -> List(a)
   */
  MkCons :
    (x, xs) -> [x | xs]

strategies

  /**
   * Succeeds if the input term is a list.
   *
   * @type List(a) -> _
   */
  is-list = ?[] + ?[_ | _]

  /**
   * Apply a strategy to each element of a list.
   *
   * @param s is applied to all elements: a -> b
   * @type  List(a) -> List(b)
   * @inc   map-test
   */
  map(s) =
    rec x([] + [s | x])

  /** @internal */
  map1(s) =
    [s | id]; [id | try(map1(s))] <+ [id | map1(s)]

  /**
   * In reverse order, apply a strategy to each element of a list.
   *
   * @param s is applied to all elements: a -> b
   * @type  List(a) -> List(b)
   */
  reverse-map(s) =
    [id | reverse-map(s)]; [s | id] <+ []

  /**
   * @inc map
   *
   * @note list(s) is an alias for map
   */
  list(s) =
    map(s)

  /**
   * Apply a strategy to some elements in a list. The elements
   * of the original list will be kept unchanged when the
   * strategy s fails.
   *
   * @param s       a -> b
   * @type    List(a) -> List(b)
   */
  list-some(s) =
    rec x([s| id] < [id| list(try(s))] + [id| x])

 /**
  * Returns the length of a list.
  *
  * @type List(a) -> Int
  * @inc length-test
  */
  length =
    ?t; prim("SSL_get_list_length", t)

  /**
   * Succeeds if the term is in the list.
   *
   * @type  (a, List(a)) ->? List(a)
   */
  elem =
    ?(x, <id>); fetch(?x)

  /**
   * Succeeds if the term is in the list, using the given
   * strategy for determining equality.
   *
   * @param (a, a) ->? b
   * @type  (a, List(a)) ->? List(a or b)
   */
  elem(eq) =
    ?(x, <id>); fetch(<eq> (x, <id>))

  /**
   * Find first list element for which s succeeds.
   *
   * @param a -> b
   * @type  List(a) -> List(a or b)
   * @inc   fetch-test
   */
  fetch(s) =
    rec x([s | id] <+ [id | x])

  /**
   * Return first list element for which s succeeds.
   * The result is the application of s to this element.
   *
   * @param a -> b
   * @type  List(a) -> b
   * @inc   fetch-elem-test
   */
  fetch-elem(s) =
    fetch(s; ?x); !x

  /**
   * Splits a list in two parts at the first point where s succeeds.
   *
   * The element to which s was applied is not part of the result. split-fetch
   * fails if s cannot be applied to any of the elements.
   *
   * Examples:
   *   <split-fetch(\ 3 -> 6 \)> [1, 2, 3] => ([1,2], [])
   *   <split-fetch(\ 3 -> 6 \)> [2, 3, 4] => ([2], [4])
   *   <split-fetch(\ 3 -> 6 \)> [3, 4, 5] => ([], [4,5])
   *   not(<split-fetch(\ 3 -> 6 \)> [8, 7, 6])
   *
   * @param a ->? _
   * @type  List(a) -> (List(a), List(a))
   * @inc   split-fetch-test
   */
  split-fetch(s) =
    at-suffix([s|id];[id|?tl];![]); !(<id>, tl)

  /**
   * Splits a list in two parts at the point where s succeeds, keeping the
   * element at which s succeeded.
   *
   * Unlike split-fetch, this strategy keeps the dividing element as part of
   * the result as the second element in the triple: (before, split, after)
   *
   * split-fetch-keep fails if s cannot be applied to any of the elements.
   *
   * @param a -> b
   * @type  List(a) -> (List(a), b, List(a))
   */
  split-fetch-keep(s) =
    at-suffix([s|id];[?el|?tl];![]); !(<id>, el, tl)

  /**
   * Breaks a list into multiple parts (tokens).
   *
   * The term argument sep is a list of delimiters (elements that separate
   * tokens from one another), which is used to split the list
   * into multiple tokens. The result is a list of lists, i.e. a list
   * of tokens.
   *
   * @param List of separator elements.
   * @type  List(a) -> List(List(a))
   */
  list-tokenize(|sep) =
    list-tokenize({c: ?c; <fetch(?c)> sep})

  /**
   * Breaks a list into multiple parts (tokens).
   *
   * The strategy argument sep is used to split the list. Wherever it
   * succeeds, the original list is split, and the parts are returned
   * as a list of lists, i.e. a list of tokens.
   *
   * @param s  a -> fail?
   * @type     List(a) -> List(List(a))
   */
  list-tokenize(sep) =
      (split-fetch(sep) <+ !(<id>, []))
    ; ( \ (  []     , [])        -> []   \
      + \ (l@[_ | _], [])        -> [l]  \
      + \ (  []     , l@[_ | _]) -> <list-tokenize(sep)> l \
      + \ (t@[_ | _], l@[_ | _]) -> [t | <list-tokenize(sep)> l] \
      )

strategies

  /**
   * Apply a strategy to the tail of a list.
   *
   * @param is applied to the tail: List(a) -> List(b)
   * @type  List(a) -> List(a or b)
   */
  at-tail(s) =
    [id | s]

  /**
   * Apply s to the Nil of a list.
   *
   * @param is applied to Nil ([]) and must return a list: List(a) -> List(a)
   * @type  List(a) -> List(a)
   */
  at-end(s) =
    rec x([id | x] + []; s)

  /**
   * Apply a strategy to some suffix of a list.
   *
   * The longest suffix (that is, the first application in a list)
   * is preferred.
   *
   * @param is applied to the suffix : List(a) -> b
   * @type  List(a) -> List(a or b)
   */
  at-suffix(s) =
    rec x(s <+ [id | x])

  /**
   * Apply a strategy to some suffix of a list.
   *
   * The shortest suffix (that is, the last application in a list)
   * is preferred.
   *
   * @param is applied to the suffix : List(a) -> b
   * @type  List(a) -> List(a or b)
   */
  at-suffix-rev(s) =
    rec x([id | x] <+ s)

  /**
   * Apply s to the last Cons ([_]) of a list.
   *
   * @param Is applied to the [x] and must return a list: List(a) -> List(a)
   * @type  List(a) -> List(a)
   */
  at-last(s) =
    rec x([id]; s <+ [id | x])

  /**
   * Splits a list into a tuple of its init list and last element.
   *
   * Example:
   *   <split-init-last> [1, 2, 3, 4] => ([1, 2, 3], 4)
   *   <split-init-last> [1]          => ([], 1)
   *
   * @type   List(a) -> (List(a), a)
   * @inc    split-init-last
   * @since  0.9.4
   */
  split-init-last =
    at-last(?[x]; ![]); !(<id>, x)

  /**
   * Applies s1 to all elements in a list, except the last, where
   * s2 is applied.
   *
   * @param s1 a -> b
   * @param s2 a -> b
   * @type List(a) -> List(b)
   */
  at-init(s1, s2) =
    rec x([s2] <+ [s1 | x])

  /**
   * Applies a strategy to a list in bottom up order. That is to say,
   * the strategy s will be applied to successively longer excerpts
   * of the list, starting from the end.
   *
   * At the first invocation, s will be applied to the tail of the list,
   * and is expected to return a new list. The last element of the list
   * will then be added in front of this result, and s is applied to
   * this. The recursion continues through all elements from last to
   * first, each time on a longer list, hence "bottom up".
   *
   * Example: <listbu(![9 | <id>])> [1,2,3,4] => [9,1,9,2,9,3,9,4,9]
   *
   * @param s  List(a) -> List(b)
   * @type     List(a) -> List(b)
   */
  listbu(s) =
    rec x(([] + [id| x]); s)

  /**
   * @inc listbu
   */
  listbu1(s) =
    [id| listbu1(s)]; try(s) <+ s

  /**
   * Applies a strategy to a list in top down order. That is to say,
   * the strategy s will first be applied to the whole list, then
   * successively shorter excerpts, all the way chopping of elements from
   * the start of the list.
   *
   * At the first invocation, s will be applied to the whole list, and
   * is expected to return a new list. The first element is chopped off
   * this result, and s is applied again, until s has been applied to
   * the empty list. The recursion continues through successively
   * shorter list, hence "top down".
   *
   * @note The strategy s cannot result in a list which is longer than
   * it is given, because that will result in non-termination.
   *
   * Example: <listtd(not(?[]) ; ![<sum>] <+ ![])> [1,2,3,4] => [10]
   *
   * @param s  List(a) -> List(b)
   * @type     List(a) -> List(b)
   */
  listtd(s) =
    rec x(s; ([] + [id| x]))

  /**
   * Applies s in a top down then bottom up, i.e. down up, order. See
   * listtd and listbu for a detailed description of each phase.
   *
   * @note As with listtd, the strategy s can never result in a list
   * which is longer than given to it.
   *
   * @param s List(a) -> List(b)
   * @type    List(a) -> List(b)
   */
  listdu(s) =
    rec x(s; ([] + [id| x]); s)

  /**
   * Applies s1 in a top down order then s2 in a bottom up order. See
   * listd and listbu for a detailed description of each phase.
   *
   * @note As with listtd, the strategy s2 can never result in a list
   * which is longer than given to it.
   *
   * @param s1 List(a) -> List(b)
   * @param s2 List(a) -> List(b)
   * @type     List(a) -> List(b)
   */
  listdu2(s1, s2) =
    rec x(s1; ([] + [id| x]); s2)

  /** @internal */
  RevInit : xs -> (xs, [])

  /** @internal */
  Rev     : ([x| xs], ys) -> (xs, [x| ys])

  /** @internal */
  RevExit : ([], ys) -> ys

  /**
   * Reverses a list.
   *
   * @inc reverse-test
   * @type List(a) -> List(a)
   */
  reverse =
    reverse-acc(id, ![])

  /**
   * Reverses a list and applies s to all the elements.
   *
   * @param a -> b
   * @type  List(a) -> List(b)
   */
  reverse(s) =
    reverse-acc(s, ![])

  /** @internal */
  reverse-acc(s, acc) :
    [] -> <acc>()

  /** @internal */
  reverse-acc(s, acc) :
    [x | xs] -> <{ys:where(![<s>x | <acc>] => ys); reverse-acc(s, !ys)}> xs

rules

  /** @internal */
  UptoInit : i -> (i, [])

  /** @internal */
  UptoExit : (i, xs) -> xs where <lt> (i, 0)

  /** @internal */
  UptoStep : (i, xs) -> (<subt> (i, 1), [i| xs])

strategies

  /**
   * Generates a sequence of numbers from 0 up to the given input
   * integer, inclusive.
   *
   * See also range.
   *
   * @type Int -> List(Int)
   *
   * @inc upto-test
   */
  upto =
    UptoInit; rec x(UptoExit <+ UptoStep; x)

strategies

  /**
   * Concatenates all lists of a tuple.
   *
   * @type (List(a), List(a), ...) -> List(a)
   * @inc  conc-test
   */
  conc =
    \ (l1, l2) -> <at-end(!l2)> l1 \
    <+ \ "" # (xs) -> <concat> xs \

  /**
   * Concatenates a list of lists into one list.
   *
   * Example: <concat> [[1,2],[3,4],[5,6]] => [1,2,3,4,5,6]
   *
   * @type List(List(a)) -> List(a)
   * @inc  concat-test
   */
  concat =
    rec x([] + \ [l | ls] -> <at-end(<x> ls)> l\ )

  /**
   * Concats two elements if both elements are lists. Otherwise, constructs
   * a Conc term.
   *
   * Generic term construction is used to avoid infinite recursion: makeConc
   * is used in the compilation of Conc itself.
   *
   * @type List(a) * List(b) -> List(a|b)
   * @type a * b -> Conc(a,b)
   */
  makeConc =
    ?(xs, ys)
    ; if <is-list> xs; <is-list> ys then conc else !"Conc"#([xs, ys]) end

strategies

  /**
   * Separates the elements of the list by the specified separator.
   * The separate-by variant that uses a term argument is prefered.
   *
   * @type (sep, List(a)) -> List(a or sep)
   */
  separate-by =
    ?(sep, <id>)
    ; separate-by(|sep)

  /**
   * Separates the elements of the list by the specified separator.
   * The separate-by variant that uses a term argument is prefered.
   *
   * @param Strategy that results in a separator.
   * @type  List(a) -> List(a or sep)
   */
  separate-by(sep) =
    separate-by(|<sep> ())

  /**
   * Separates the elements of the list by the specified separator.
   *
   * @param Separator term
   * @type  List(a) -> List(a or sep)
   */
  separate-by(|sep) =
    []
    + [id |
        rec x(
          []
        + [id | x]
          ; ![sep | <id>]
        )]

strategies

  /**
   * Transposes an n by m matrix. The matrix must be represented as
   * a list of n elements, where each element is a list of length m.
   * The element of the inner lists may be of any type.
   *
   * Example: <matrix-transpose> [[1,2],[3,4]] => [[1,3],[2,4]]
   *
   * @type List(List(a)) -> List(List(a))
   */
  matrix-transpose =
      map(?[]); ![]
    +   map(split-Cons)
      ; unzip
      ; (id, matrix-transpose)
      ; MkCons

  /**
   * <for-each-pair(s)> (xs, ys) produces the list of pairs <s> (x,y).
   * for each pair of x from xs and y from ys.
   *
   * @inc for-each-pair-test
   *
   * @type List(a) * List(b) -> List((a,b), ...)
   */
  for-each-pair(s) =
    ?(xs, ys); <map(\ x -> <map(<s>(x,<id>))> ys \ )> xs

strategies

  /**
   * Succeeds if the first input term is a member of the second.
   *
   * @type a * List(a) -> a
   */
  member = (?x, fetch(?x))

rules

  /** @internal */
  FoldR1   : [x, y] -> (x, y)

  /** @internal */
  FoldR    : [x | xs] -> (x, xs)

  /** @internal */
  FoldL(s) : ([x | xs], y) -> (xs, <s> (x, y))

  /** @internal */
  lsplit(f, g) : x -> [<f> x, <g> x]

strategies

  /**
   * foldr, requires a list of length > 1.
   *
   * @param  List(a) -> b
   * @param  (a, b) -> b
   * @type   List(a) -> b
   * @internal
   */
  foldr1(s1, s2) =
    rec x([id]; s1 <+ FoldR; (id, x); s2)

  /**
   * foldr, requires a list of length > 1.
   * The additional parameter strategy f is applied to each element just
   * before each folding step.
   *
   * @param List(c) -> b
   * @param (c, b) -> b
   * @param a -> c
   * @type  List(a) -> b
   * @internal
   */
  foldr1(s1, s2, f) =
    rec x([f]; s1 <+ FoldR; (f, x); s2)

  /**
   * foldr, requires a list of length > 1.
   * Note that s maps (a, a) to a, only one type is involved.
   *
   * @param (a, a) -> a
   * @type  List(a) -> a
   * @internal
   */
  foldr1(s) =
    rec x((FoldR1 <+ FoldR; (id, x)); s)

  /**
   * Right folds a list. That is, the strategy s2 is applied as a
   * binary operator between all adjacent elements in the list.
   * foldr starts by applying s2 to the last element in the list
   * and the result of s1. s1 is therefore the starting point of
   * the folding.
   *
   * Example: <foldr(!0, add)> [1,2,3,4] => 10
   *
   * @param [] -> b
   * @param (a, b) -> b
   * @type  List(a) -> b
   */
  foldr(s1, s2) =
    []; s1
    + \ [y|ys] -> <s2>(y, <foldr(s1, s2)> ys) \

  /**
   * Right folds a list. That is, the strategy s2 is applied as a
   * binary operator between all adjacent elements in the list.
   * foldr starts by applying s2 to the last element in the list
   * and the result of s1. s1 is therefore the starting point of
   * the folding.
   *
   * The additional parameter strategy f is applied to each element just
   * before each folding step.
   *
   * Example: <foldr(!0, add, inc)> [1,2,3,4] => 14
   *
   * @param [] -> b
   * @param (c, b) -> b
   * @param a -> c
   * @type  List(a) -> b
   */
  foldr(s1, s2, f)  =
    []; s1 +
    \ [y|ys] -> <s2> (<f> y, <foldr(s1, s2, f)> ys) \

  /**
   * Left folds a list. That is, the strategy s is applied as a
   * binary operator between all adjacent elements in the list.
   * foldl starts by applying s to b and the first element in
   * the list. b is therefore the starting point of the folding.
   *
   * Example: <foldl(add)> ([1,2,3,4], 0)
   *
   * @param (a, b) -> b
   * @type  (List(a), b) -> b
   */
  foldl(s) =
    rec x( \ ([], y) -> y \ + FoldL(s); x)

  /** @internal */
  mapfoldr1(s1, s2, s3) =
    rec x([id]; s1 <+ [s2|x]; \ [a|b]->(a,b)\; s3)

  /**
   * Transform the elements of a list into lists (map)
   * and concatenate into a single list (concat).
   *
   * Note: equivalent to map(s); concat
   *
   * @param a -> List(b)
   * @type  List(a) -> List(b)
   */
  mapconcat(s) =
    foldr([], conc, s)

  /**
   * Returns the last element of a list.
   *
   * Fails if applied to the empty list.
   *
   * @type List(a) -> a
   */
  last =
    rec x(Last <+ Tl; x)


  /**
   * Returns a list with the first and the last element of
   * the input list. For the empty list and the singleton
   * list, this is equivalent to id.
   *
   * @type List(a) -> List(a)
   */
  first-last =
    [id | try(last; MkSingleton)] <+ []

 /**
  * Returns a list of all elements of a list, except the last.
  *
  * Fails if applied to the empty list.
  *
  * @inc init
  * @inc empty init
  *
  * @type List(a) -> List(a)
  */
  init =
    at-last(Tl)

  /**
   * @inc split-init-last
   * @note Alias for split-init-last.
   */
  split-last =
    split-init-last

  /**
   * Makes n copies of a term into a list of duplicates. The
   * first input term is the integer n, the second is the term
   * to duplicate.
   *
   * @inc copy-test
   *
   * Example: <copy> (3, "foo") => ["foo", "foo", "foo"]
   *
   * @type Int * a -> List(a)
   */
  copy =
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [t|ts]) where <geq>(n,1) \ )

  /**
   * Makes n copies of a term into a list of duplicates, applying
   * the strategy s to every copy. The first input term is the
   * integer n, the second is the term to duplicate.
   *
   * Example: <copy(\ "foo" -> "bar" \)> (3, "foo") => ["bar","bar,"bar"]
   *
   * @param s       a -> b
   * @type    Int * a -> List(n)
   */
  copy(s) =
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [<s> t|ts]) where <geq>(n,1) \ )

  /** @internal */
  thread-map(s) :
    ([], t) -> ([], t)

  /**
   * Applies s to each element in the list, keeping along a separate
   * context term.
   *
   * For each element in the list, a tuple (a, b) is constructed and
   * given to s. From the result, (a', b'), a' goes to the final list
   * returned by this strategy, and b' becomes the new b as s is
   * applied to the next element.
   *
   * Example: <thread-map(add ; !(<id>, <id>))> ([1,2,3,4], 1) => ([2,4,7,11],11)
   *
   * @param s a * b -> a' * b'
   * @type List(a) * b -> List(a') * b'
   */
  thread-map(s) :
    ([x | xs], t) -> ([y | ys], t'')
    where <s> (x, t) => (y, t')
  ; <thread-map(s)> (xs, t') => (ys, t'')

  /**
   * Numbers each element in a list successively with an
   * integer, starting at 0. The result is a list of pairs,
   * (elem, num) where elem is the original element and num
   * is its associated number. s is applied to each pair
   * before inserting it into the list
   *
   * Example: <number(id)> ["a","b","c"] => [("a",0),("b",1),("c",2)]
   *
   * @inc number-test
   *
   * @param s a * Int -> a' * Int
   * @type List(a) -> List((a,n),...)
   */
  number(s) =
    !(<id>, 0); thread-map(!(<s>,<Snd;inc>)); ?(<id>,_)

  /**
   * Take elements from the start of a list while s succeeds.
   * Each element of the list is tested against s, starting at
   * the head of the list. For as long as s succeeds, the elements
   * are accumulated in a list, which is returned as s fails, or
   * the end of the list is reached. The actual term returned by
   * s is ignored.
   *
   * Example: <take-while(?2 ; !3)> [2,2,3] => [2,2]
   *
   * @param s       a -> _
   * @type    List(a) -> List(a)
   */
  take-while(s) =
    at-suffix([] + ([not(s)|id];![]))

  /**
   * Take elements from the start of a list until s succeeds.
   * Each element of the list is tested against s, starting at
   * the head of the list. For as long as s does not succeed, the
   * elements are accumulated in a list, which is returned at
   * the instant s fails. The actual term returned by s is
   * ignored. If s never succeeds, the entire list is returned.
   *
   * Example: <take-until(?2; !3)> [3,3,2,4] => [3,3]
   *
   * @param s       a -> _
   * @type    List(a) -> List(a)
   */
  take-until(s) =
    at-suffix([] + ([s|id];![]))

  /**
   * Take the first n elements of a list, given by isn. The
   * strategy argument isn must produce an integer, which
   * gives the length of the sublist to return. If there are
   * not enough elements, this strategy fails.
   *
   * @param isn _ -> Int
   * @type List(a) -> List(a)
   */
  take(isn) =
    take(|<isn>)

  /**
   * Returns the first n elements of a list, fails
   * if list has fewer than n elements.
   *
   * @param n The number of elements to take.
   * @type List(a) -> List(a)
   */
  take(|n) =
    if <eq>(n,0) then
      ![]
    else
      ![<Hd> | <Tl; take(|<subt>(n,1))>]
    end

  /**
   * Returns the n first elements after s has been applied to them.
   * With the exception of side effects, takemap(s|n) is equal to
   * take(|n); map(s). The difference when considering side-effects
   * is that s is applied while taking elements, so if s has a
   * side-effect these will be performed, even if take fails.
   *
   * @param n - The number of elements to retrieve
   * @param s a -> b
   * @type List(a) -> List(b)
   */
  takemap(s|n) =
    if <eq>(n,0) then
      ![]
    else
      ![<Hd; s> | <Tl; takemap(s|<subt>(n,1))>]
    end

  /**
   * Drops elements from the start of a list while s succeeds. The
   * first element at which s fails and all following it will be
   * returned.
   *
   * Example: <drop-while(?2)> [2,2,3,4] => [3,4]
   *
   * @param s       a -> _
   * @type    List(a) -> List(a)
   */
  drop-while(s) =
    at-suffix(([] + [not(s)|id]);?xs); !xs

  /**
   * Drops elements from the start of a list until s succeeds. The
   * first element at which s succeeds and all following it will be
   * returned.
   *
   * Example: <drop-until(?3)> [2,2,3,4] => [3,4]
   *
   * @param s       a -> _
   * @type    List(a) -> List(a)
   */
  drop-until(s) =
    at-suffix(([] + [s|id]);?xs); !xs

  /**
   * Drops the first n elements from a list. If the list has
   * fewer than n elements, the strategy fails.
   *
   * @param n - the number of elements to drop
   * @type  List(a) -> List(a)
   */
  drop(|n) =
    if <eq>(n,0) then
      id
    else
      Tl; drop(|<subt>(n,1))
    end

  /**
   * Splits a list after n elements and applies strategy s to the
   * first sublist. The second sublist is left untouched.
   * Disregarding side-effects, splitmap is equal to
   * !(<take(|n); map(s)>, <drop(|n)>). If side-effects are
   * considered, note that application of s happens while
   * traversing and splitting.
   *
   * @param s a -> b
   * @param n - the number of elements to apply s to, from the start
   * @type List(a) -> (List(b), List(a))
   */
  splitmap(s|n) =
    if <eq>(n,0) then
      !([], <id>)
    else
      where(Hd; s => x)
      ; where(Tl; splitmap(s|<subt>(n,1)) => (xs, ys))
      ; !([x | xs], ys)
    end

  /**
   * @inc split-fetch
   * @note Alias for split-fetch/1
   */
  split-at(s) =
    split-fetch(s)

  /**
   * Splits a list in two, with the second part containing the last
   * n elements and and first part containing all elements except the
   * last n.
   *
   * @type List(a) -> (List(a), List(a))
   * @param n - the number of elements to split at (counting from the back)
   */
  back-split-at(|n) =
    foldr(!(([], []), 0)
          , {x, l, r, m :
             ?(x, ((l, r), m))
             ; if <lt>(m, n)
               then
                 !((l, [x | r]), <inc>m)
               else
                 !(([x | l], r), m)
               end})
    ; ?(<id>, _)

  /**
   * Drops a number of terms from the front of a list.
   *
   * The number is specified by the strategy argument, which should
   * produce an integer.
   *
   * @type  List(a) -> List(a)
   * @param _ -> Int
   */
  drop(isn) =
    where(isn => n)
    ; nzip0(id)
    ; drop-until(?(n,_))
    ; map(Snd)

  /**
   * Splits the list in two sublists, containing elements from 0 to
   * n and from n onwards.
   *
   * Example: <split-at(|4)>[1,2,3,4,5,6,7,8,9] => ([1,2,3,4], [5,6,7,8,9])
   *
   * @type List(a) -> (List(a), List(a))
   */
  split-at(|n) =
    at-index-tail(?t; ![] | n)
    ; !(<id>, t)

strategies

  /**
   * Trim elements from the end of a list
   *
   * Removes the longest sublist from the end of a list, for which
   * all elements satisfy the strategy s.
   *
   * @type  List(a) -> List(a)
   * @param should succeed for all elements that have to be trimmed.
   * @since 0.9.5
   * @inc   trim-test
   */
  rtrim(s) =
    ![()|<id>] // Add dummy element, or at-suffix-rev will fail at empty lists
  ; at-suffix-rev(
      where( not(?[])     // This only succeeds if we're not at list-end
           ; not([s|id])) // and s fails at the head of the current suffix
    ; ![<Hd>]) // s failed, no further trimming.
  ; Tl // Strip off dummy head element.

  /**
   * Trim elements from the start of a list.
   *
   * Removes the longest sublist from the start of a list, for which
   * all elements satisfy the strategy s.
   *
   * @type  List(a) -> List(a)
   * @param should succeed for all elements that have to be trimmed.
   * @since 0.9.5
   * @inc   trim-test
   * @note Alias for drop-while
   */
  ltrim(s) = drop-while(s)

  /**
   * Trim elements from both start and end of a list.
   *
   * Removest the longest sublist from both start and end of a
   * list for which all elements satisfy s.
   *
   * @type List(a) -> List(a)
   * @param s a -> -
   * @since 0.9.5
   * @inc trim-test
   */
  trim(s) = ltrim(s); rtrim(s)

strategies

  /**
   * Completely flattens a list and its sublists to a single list.
   *
   * See list-misc-test for examples.
   *
   * @type List(rec x(a or List(x))) -> List(a)
   * @inc flatten-test
   */
  flatten-list =
    foldr(![], (is-list, id) < conc + MkCons, is-list < flatten-list + id)


  /**
   * Eliminates all elements at the end of the two lists that are equal.
   * Only works correctly on lists of equal length!
   *
   * Example: <eliminate-common-suffix>([1,3,4], [1,2,4]) => ([1,3], [1,2])
   *
   * @type (List(a), List(a)) -> (List(a), List(a))
   */
  eliminate-common-suffix =
    ?([x | xs], [y | ys])
    ; <eliminate-common-suffix>(xs, ys)
    ; if ?([], []); <eq>(x, y)
      then !([], [])
      else (![x | <id>], ![y | <id>])
      end
    <+ !([], [])

  /**
   * Returns the common prefix of two lists.
   *
   * Examples:
   *  <common-prefix>([1,2,3], [1,2,4,5]) => [1,2]
   *  <common-prefix>([1,2,3], [2,3,4]) => []
   *
   * @type (List(a), List(a)) -> List(a)
   */
  common-prefix =
    ?([x | xs], [x | ys])
    ; ![x | <common-prefix>(xs, ys)]
    <+ ![]


strategies

strategies

  /**
   * Returns a list of combinations by choosing one element from every
   * list, in every possible combination.
   *
   * Examples:
   *
   *   $ <list-combinations> [[1, 2]]
   *   [[1],[2]]
   *
   *   $ <list-combinations> [[1, 2], []]
   *   []
   *
   *   $ <list-combinations> [[1, 2], ["a", "b"]]
   *   [[1,"a"],[2,"a"],[1,"b"],[2,"b"]]
   *
   *   $ <list-combinations> []
   *   [[]]
   *
   * @type List(List(a)) -> List(List(a))
   */
  list-combinations =
    let step = fail
          <+ \ [] -> [[]] \

          <+ \ [[] | _] -> [] \

          <+ {xs :
               ?[xs | <step>]
               ; map-intermediate(|xs)
             }

        map-intermediate(|xs) = fail
          <+ \ [] -> [] \

          <+ {intermediate, t, t' :
               ?[intermediate | t]
               ; t' :=  <map-intermediate(|xs)> t
               ; <map-xs(|intermediate, t')> xs
             }

        /**
         * This is just a foldr, but Stratego does not support
         * specialization of map-xs to an intermediate without
         * introducing tuples, which means that we cannot
         * use a generic fold.
         */
        map-xs(|intermediate, t) = fail
          <+ \ [] -> t \

          <+ {x:
               ?[x | <id>]
               ; map-xs(|intermediate, t)
               ; ![[x | intermediate] | <id>]
             }
    in step
   end

// collection/list/cons
signature
  sorts List(a)
  constructors

    /**
     * Empty list.
     */
    Nil  : List(a)

    /**
     * Element of a list.
     */
    Cons : a * List(a) -> List(a)

    /**
     * Concatenation of two lists.
     */
    Conc : List(a) * List(a) -> List(a)

// collection/list/filter
strategies

  /**
   * Returns all elements in a list that satisfy s, as a list.
   *
   * @param s  a -> b
   * @type     List(a) -> List(b)
   *
   * @inc test1
   */
  filter(s) =
    [] + [s | filter(s)] <+ ?[_ | <filter(s)> ]


  filter(s, t) =
    ?[]; t
    <+ [s | filter(s, t)]
    <+ ?[_ | <filter(s, t)> ]

strategies

  /**
   * Returns all elements in a list that satisfy s, as a list.
   *
   * @param s  a -> b
   * @type     List(a) -> List(b)
   */
  retain-all(s) =
    filter(s)

  /**
   * Removes all elements from a list that satisfy s
   *
   * @param s  a -> b
   * @type     List(a) -> List(a)
   */
  remove-all(s) =
    filter(not(s))

strategies

  /**
   * Returns all elements in a list that satisfy s, as a list.
   * Traverses the list in reverse order.
   *
   * @param s a -> b
   * @type  List(a) -> List(b)
   */
  reverse-filter(s) =
    [] + [id | reverse-filter(s)]; ([s | id] <+ ?[_  | <id>])

  reverse-filter(s, t) =
    ?[]; t
    + ?[x | xs]
      ; <reverse-filter(s, t)> xs
      ; try(![<s> x | <id>])

  /** @internal */
  filter-gen(pred, cont : (term -> term) * term -> term) =
    rec x([] + (pred; cont(x)) <+ Tl; x)

  /** @internal */
  filter-option-args(flag) =
  let skip(s) = at-tail(s)
   in filter-gen([flag | id]; Tl, skip)
  end

  /** @internal */
  filter-options(flag) =
  let skip(s) = at-tail(at-tail(s))
     in filter-gen([flag | id], skip)
    end

  /** @internal */
  list-some-filter(s) =
    rec x([s| id]; [id| filter(s)] <+ [id| x]; Tl)

 /**
  * Partitions a list into a tuple of two lists.
  *
  * The argument s is applied to all elements of the list. The
  * results of the succesful applications are returned in the first
  * list. The terms to which s cannot be applied are returned in the
  * second list.
  *
  * @param s   a -> b
  * @type      List(a) -> (List(b), List(a))
  *
  * @inc test2
  */
  partition(s) =
    partition(s, id)

 /**
  * Partitions a list into a tuple of two lists.
  *
  * @param s1   a -> b
  * @param s2   a -> c
  * @type      List(a) -> (List(b), List(c))
  */
  partition(s1, s2) = rec part(
    \ [] -> ([],[]) \
    + ({[s1 => x | id]; ?[_|<part>]; !([x | <Fst>], <Snd>)} <+
       {[s2 => x | id]; ?[_|<part>]; !(<Fst>, [x | <Snd>])})
  )

  /** @internal */
  partition'(s) = rec part(
    \ [] -> ([],[]) \
    + \ [z | zs] -> <!([<s> z | xs], ys) <+ !(xs, [z | ys])>
        where <part> zs => (xs, ys) \
  )

// collection/list/index
strategies

 /**
  * Get the n-th element of a list.
  * The first element has index 1.
  *
  * @type (Int, List(a)) -> a
  * @inc test-index
  */
  index =
    ?(i, <id>); index(|i)

strategies

  /**
   * Get the i-th element of a list.
   * The first element has index 1.
   *
   * @type List(a) -> a
   */
  index(|i) =
    at-index(?t | <dec> i); !t

strategies

  /**
   * Get index of element in list.
   *
   * @type (a, List(a)) -> Int
   */
  get-index =
    Gind0 ; rec x(Gind1 <+ Gind2 ; x)


  /** @internal */
  Gind0  : (x, ys) -> (1, x, ys)

  /** @internal */
  Gind1  : (n, x, [x | xs]) -> n

  /** @internal */
  Gind2  : (n, y, [x | xs]) -> (<add> (n, 1), y, xs)

  get-index0(s) = at-suffix([s | id]; ![]); length

strategies

  /**
   * Change element in list.
   * The first element has index 0.
   *
   * @type (Int, a, List(a)) -> List(a)
   * @inc  test-set-index
   */
  set-index =
    ?(i, x, xs)
    ; <at-index(!x)> (i, xs)

  /**
   * Apply s at the specified index
   * The first element has index 0.
   *
   * @type (Int, List(a)) -> List(a)
   */
  at-index(s) =
    ?(i, <id>)
    ; at-index(s | i)

  /**
   * Apply s at the specified index i.
   * The first element has index 0.
   *
   * @type List(a)) -> List(a)
   */
  at-index(s | i) =
    let next(|j) =
          if !j => i then
            [s | id]
          else
            [id | next(|<inc> j)]
          end
     in next(|0)
    end

  /**
   * Apply s to the list containing the elements
   * from index i onwards from the original list.
   * The first element has index 0.
   *
   * @type List(a) -> List(a)
   */
  at-index-tail(s|i) =
    let next(|j) =
      if !j => i then
        s
      else
        [id | next(|<inc> j)]
      end
    in next(|0)
    end

strategies

  /**
   * Insert element in list.
   *
   * @type (Int, a, List(a)) -> List(a)
   * @inc test-insert
   */
  insert =
    Ins0; rec x(Ins1 <+ Ins2(x))

  /** @internal */
  Ins0:    (i, x, ys) -> (0, i, x, ys)

  /** @internal */
  Ins1:    (i, i, x, xs) -> [x | xs]

  /** @internal */
  Ins2(r): (n, i, x, [y | ys]) -> [y | <r>(<add> (n, 1), i, x, ys)]


strategies

  /**
   * Map a strategy over a list where the strategy takes the index as a term argument.
   *
   * @param Strategy to apply to all the elements of the list.
   * @param The first index (e.g. 0 or 1)
   * @type  List(a) -> List(b)
   */
  nmap(s : Int * a -> b | i) =
    [] + [s(|i) | nmap(s | <inc> i)]

  /**
   * Apply strategies that require some knowledge of the index of an element
   * to the elements of the list.
   *
   * The index of the first element is 1.
   *
   * @param Int * a -> b
   * @type  List(a) -> List(b)
   * @inc  test4a
   * @inc  test4b
   */
  map-with-index(s) =
    let apply(|i) = <s> (i, <id>)
     in nmap(apply | 1)
    end

  /**
   * Adds indices to the elements of a list.
   * The index of the first element is 1.
   *
   * Example: <add-indices> [1,2,3] => [(1,1),(2,2),(3,3)]
   *
   * @type List(a) -> List((Int, a))
   * @inc test5
   */
  add-indices =
    map-with-index(id)

// collection/list/integer
strategies

  /**
   * Returns the sum of all integers in a list of integers
   *
   * @type List(Int) -> Int
   */
  sum = foldr(!0, add)

  /**
   * Returns the average of all integers in a list of
   * integers. The result is an integer, which is
   * truncated (rounded down).
   *
   * @type List(Int) -> Int
   */
  average = split(sum, length); div

  /**
   * Returns the lowest integer in a list of integers.
   *
   * @type List(Int) -> Int
   */
  list-min = list-accum(min)

  /**
   * Returns the highest integer in a list of integers.
   *
   * @type List(Int) -> Int
   */
  list-max = list-accum(max)

  /**
   * Reduces a list, applying s successively between
   * the head and tail of the list. This strategy is
   * related to foldl.
   *
   * Example: <list-accum(id)> [1,2,3] => (3,(2,1))
   *
   * @param (a,b)   -> c
   * @type  List(a) -> d
   */
  list-accum(s) = !(<Tl>, <Hd>); foldl(s)

  /**
   * Adds together multiple lists of numbers. The input
   * is a list of integer (or real) lists, which all must
   * be of the same length. The result is one list of
   * the same length, i.e. a sum of vectors.
   *
   * Example: <add-lists> [[1.0,2.0],[3,4],[6,7]] => [1.000000000000000e+01,1.300000000000000e+01]
   *
   * @type List(List(Number)) -> List(Number)
   */
  add-lists = list-accum(zip(add <+ !""))

 /**
  * Sort a list of integers in ascending order.
  *
  * @inc sort-test
  *
  * @type List(Int) -> List(Int)
  */
  int-sort = sort-list(SortL(gt))

 /**
  * Succeeds if the integer list is an ascending number
  * sequence, increasing by one, starting at a given
  * number. The range strategy can be used to
  *
  * Example: <is-interval-from> (3, [4,5,6,7]) => 7
  *
  * @inc is-interval-test
  *
  * @type List(Int) -> _
  */
  is-interval-from =
  rec r(
    \ (low,[]) -> low \
    <+ {l: \ (low,[x|xs]) -> <r>(x,xs)
           where <add>(low,1) => l
               ; <eq>(x,l)\ }
  )

strategies

  /**
   * Generates range of numbers in the form of an integer list. This
   * version of range accepts only one integer as input. The generated
   * sequence of integers is generated, starts at 0 and increases by one
   * until the specified end point is reached.  The end point is never
   * part of the generated list.
   *
   * Example: <range> 10 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   *
   * @type  Int       -> List(Int)
   * @type  Int * Int -> List(Int)
   * @since 0.9.3
   */
  range = is-int; <range> (0, <id>)

  /**
   * Generates a range of numbers in the form of an integer list. This version
   * of range accepts two integers as input. The first is the lower bound, of
   * the sequence, the second is the upper bound. The upper bound is never
   * part of the generated list.
   *
   * Example: <range> (5, 10)     => [5, 6, 7, 8, 9]
   *
   * @type  Int * Int -> List(Int)
   * @since 0.9.3
   */
  range = (is-int, is-int); range(|1)

strategies

  /**
   * Generates a sequence of integers, using a specified step size. This version
   * of range starts at zero and adds one integer to the sequence for every
   * step specified by the term argument. The input term gives the upper bound
   * of the sequence, and is never included. The step size is allowed
   * to be negative.
   *
   * Example: <range(|3)>   10          => [0, 3, 6, 9]
   * Example: <range(|-30)> (-10, -100) => [-10, -40, -70]
   *
   * @type step Int
   * @type      Int       -> List(Int)
   * @type      Int * Int -> List(Int)
   * @since     0.9.3
   */
  range(|step) = is-int; <range(|step)> (0, <id>)

  /**
   * Generates a sequence of integers, using a specified step size. This version
   * of range starts at zero and adds one integer to the sequence for every
   * step specified by the term argument. The input terms give the lower and
   * upper bound of the sequence, respectively. The upper bound is never
   * included. The step size is allowed to be negative.
   *
   * Example: <range(|3)>   (0, 10)     => [0, 3, 6, 9]
   *
   * @type step Int
   * @type      Int       -> List(Int)
   * @type      Int * Int -> List(Int)
   * @since     0.9.3
   */
  range(|step) = (is-int, is-int); range(<add> (<id>, step))

strategies

  /**
   * Generates a sequence of numbers using a generator strategy. The
   * input integer is the upper bound. The strategy argument is a
   * generator which specifies how to go from the current number in
   * the sequence to the next. The sequence starts at 0.
   *
   * Example: <range(inc)> 5 => [0,1,2,3,4]
   *
   * @type next Int -> Int
   * @type      Int       -> List(Int)
   */
  range(next) = is-int; <range(next)> (0, <id>)

  /**
   * Generates a sequence of numbers using a generator strategy. The
   * input integers are the lower and upper bounds, respectively. The
   * strategy argument is a generator which specifies how to go from
   * the current number in the sequence to the next.
   *
   *
   * Example: <range(inc)> (2,5) => [2,3,4]
   *
   * @type      Int * Int -> List(Int)
   * @since 0.9.3
   */
  range(next) = (is-int, is-int); range-next(next) <+ ![]

  /** @internal */
  range-next(inc) :
      (start, e) -> [start | t]
        where <inc> start => next
            ; ( (<lt-lt>  (start, next, e) + <lt-lt>  (e, next, start))
              ; <range(inc)> (next, e)
             <+ (<lt-leq> (start, e, next) + <leq-lt> (next, e, start))
              ; ![]
              ) => t

rules

  /**
   * Succeeds if the input term is a list of monotonously increasing
   * integers and the difference between two adjacent integers is
   * always one.
   *
   * Example: <is-interval> [1,2,3,4,5] => (1,5)
   *
   * @type List(Int) -> _
   */
  is-interval:
    [x|xs] -> (x,<is-interval-from>(x,xs))

// collection/list/lookup
strategies

  /**
   * Lookup the first value associated with a key in an associative
   * list. An associative list is a list of key-value pairs.
   *
   * Note: If multiple identical keys exist, only the value for the
   * first will be retrieved.
   *
   * Example:
   *   <lookup> (2, [(1, "a"), (2, "b"), (3, "c")]) => "b"
   *
   * @type  k * List(k * v) -> v
   */
  lookup = rec x(Look1 <+ Look2 ; x)

  /**
   * Find first element of a list to which s applies.
   * The result is the application of s to this element.
   *
   * @type s    a  -> b
   * @type     List(a) -> b
   */
  getfirst(s) = rec x(Hd; s <+ Tl; x)

  /**
   * Faster version of lookup.
   *
   * The advantage over lookup is that lookup' does not construct
   * intermediate pairs.
   *
   * @type  k * List(k * v) -> v
   * @internal
   */
  lookup' = {x, xs: ?(x, xs) ; <getfirst({y: ?(x, y); !y})> xs}

  /**
   * Looks up the first value associated with a particular key
   * in an associative list, using keyeq to do key comparisons.
   *
   * @type k * List(k * v) -> v
   */
  lookup(keyeq) = rec x((Look1'(keyeq) <+ Look2; x))

rules

  /** @internal */
  Look1 : (x, [(x, y)|_]) -> y

  /** @internal */
  Look2 : (x, [_|xs]) -> (x, xs)

  /** @internal */
  Look1'(keyeq) : (x, [y|_]) -> y where <keyeq> (x, y)

// collection/list/set
rules

  /** @internal */
  HdMember(mklst) :
    [x | xs] -> xs where mklst; fetch(?x)

  /** @internal */
  HdMember'(eq, mklst) :
     [x | xs] -> xs
     where mklst; fetch(\y -> <eq> (x, y)\)

strategies

  /**
   * Removes duplicate elements from a list. This effectively
   * converts a list to a set.
   *
   * @type  List(a) -> List(a)
   */
  make-set =
    foldr(![], union, ![<id>])

  /**
   * Removes duplicate elements from a list. This effectively
   * converts a list to a set.
   *
   * @type   List(a) -> List(a)
   * @note   nub is an alias of make-set.
   * @since  0.9.4
   */
  nub = make-set

strategies

  /**
   * Union: Concatenation of two lists, only those elements in the
   * first list are added that are not already in the second list.
   *
   * @type List(a) * List(a) -> List(a)
   * @inc  test1a
   * @inc  test1b
   * @inc  test1c
   * @inc  test1d
   * @inc  test1e
   */
  union = union(eq)

  // a * a -> fail? :: List(a) * List(a) -> List(a)
  /**
   * Takes the union of two sets. The result is a set
   * where all elements found in both sets are present,
   * but each element occurs only once. The strategy
   * parameter is the equality operator to be used on the
   * elements.
   *
   * @param Equality operator to be used on the elements
   * @type List(a) * List(a) -> List(a)
   */
  union(eq) :
    (l1, l2) -> <rec x(
                   ([]; !l2)
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

strategies

  /**
   * Takes the union of a list of sets. All the sets are
   * sets are flattened into one list, and all duplicates
   * are removed, to obtain a new set.
   *
   * Example: <unions> [[1,2,3],[3,4,5],[5,6,7]] => [1,2,3,4,5,6,7]
   *
   * @type  List(List(a)) -> List(a)
   */
  unions = unions(eq)

  // a * a -> fail? :: List(List(a)) -> List(a)
  /**
   * Takes the union of a list of sets. The result is a set
   * where all elements found in either of the sets are present,
   * i.e. where each element occurs only once. The strategy
   * parameter is the equality operator to be used on the
   * elements.
   *
   * @param Equality operator used on the elements.
   * @type List(List(a)) -> List(a)
   */
  unions(eq) = foldr(![], union(eq))

rules

  /**
   * Computes the difference between two sets. That is, it
   * returns the elements found in the first set, but not in
   * the second.
   *
   * @type  (List(a), List(a)) -> List(a)
   * @inc  test3a
   * @inc  test3b
   * @inc  test3c
   * @inc  test3d
   * @inc  test3e
   */
  diff = diff(eq)

  /**
   * Computes the difference between two sets. That is, the elements
   * found in the first set, but not in the second. The strategy
   * argument is used to compare elements of the sets.
   *
   * Example: <diff(eq)> ([1,2,3], [5,1,2]) => [3]
   *
   * @param  Used to compare the elements. If an application succeeds, then two elements are equal.
   * @type   (List(a), List(a)) -> List(a)
   */
  diff(eq) :
    (l1, l2) -> <rec x(
                   []
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

  /**
   * Takes the symmetric difference of two sets. That is, it returns
   * all elements not found in both sets.
   *
   * Example: <sym-diff> ([1,2,3],[5,1,2,6]) => [3,5,6]
   *
   * @type  (List(a), List(a)) -> List(a)
   * @inc  test4a
   * @inc  test4b
   * @inc  test4c
   * @inc  test4d
   * @inc  test4e
   */
  sym-diff = sym-diff(eq)

  /**
   * Takes the symmetric difference of two sets. That is, it returns
   * all elements not found in both sets. the strategy argument is
   * used to compare elements of the sets.
   *
   * Example: <sym-diff(eq)> ([1,2,3],[5,1,2,6]) => [3,5,6]
   *
   * @param  Equality operator to use on the elements. If it succeeds, the elements are equal.
   * @type   (List(a), List(a)) -> List(a)
   */
  sym-diff(eq) =
    <union> (<diff(eq)>, <Swap; diff(eq)>)

strategies

  /**
   * Take the intersection of two sets. That is, it returns
   * all elements found in both sets.
   *
   * Example: <isect> ([1,2,3],[5,1,2,6]) => [1,2]
   *
   * @type List(a) * List(a) -> List(a)
   * @inc  test2a
   * @inc  test2b
   * @inc  test2c
   * @inc  test2d
   * @inc  test2e
   */
  isect = isect(eq)


  /**
   * Take the intersection of two sets.
   *
   * The result is the first list, without the elements
   * that are not in the second list. If the first list is not
   * a set (it has duplicates), the result will
   * have duplicates. Note that because of this <isect> (l1, l2) is
   * not always equal to <isect> (l2, l1).
   *
   * @type eq  a * a ->? _
   * @type     [a] * [a] -> [a]
   */
  isect(eq) :
    (l1, l2) -> <rec x(
                   []
                <+ ( where(HdMember'(eq, !l2)); [id | x] )
                <+ ?[_ | <x>]
                )> l1

strategies


  /**
   * Check equality of two list sets.
   *
   * This strategy uses the basic `eq` to compare the elements.
   */
  set-eq = set-eq(eq)

  /**
   * Check equality of two list sets.
   *
   * The input remains untouched, set-eq just succeeds or fails.
   *
   * @param test strategy that will compare two elements upon their equality.
   * @inc set-eq-test1
   * @inc set-eq-test2
   * @inc set-eq-test3
   * @inc set-eq-test4
   * @inc set-eq-test5
   */
  set-eq(eq)   = subset-gen(eq, ?[])

  /**
   * Succeeds if the first set is a strict subset of the second.
   *
   * Example: <subset> ([1,2],[1,2,3])
   *
   * @type List(a) * List(a) -> _
   */
  subset       = subset(eq)

  /**
   * Succeeds if the first set is a strict subset of the second. The
   * strategy parameter is the equality operator that will be used
   * to check if two elements are equal.
   *
   * @param Equality operator to be used on elements on the set.
   * @type List(a) -> List(a) -> _
   */
  subset(eq)   = subset-gen(eq, ?[_|_])

  /**
   * Succeeds if the first set is a (non-strict) subset of the second.
   *
   * Example: <subseteq> ([1,2],[1,2])
   *
   * @type List(a) * List(a) -> _
   */
  subseteq     = subseteq(eq)

  /**
   * Succeeds if the first set is a (non-strict) subset of the second.
   * The strategy parameter is the equality operator that will be used
   * to check if two elements are equal.
   *
   * Example: <subseteq> ([1,2],[1,2])
   *
   * @type List(a) * List(a) -> _
   */
  subseteq(eq) = subset-gen(eq, ?[] + ?[_|_])

  /**
   * General strategy for comparing two list sets.
   *
   * Other strategies call this one to check for equality, subset or subseteq.
   *
   * @param Equality operator to be used on elements in the set.
   * @param Matching strategy that tests the remainder of the right (2nd)
   *        set after comparing all elements from the first list.
   */
  subset-gen(eq, rest) =
    where(
      rec r ( {x, xs, y, ys, y*:
        ([],rest)
      + ?([x|xs], y* )
      ; <split-fetch(\ y -> <eq> (x, y)\); conc> y* => ys
      ; <r> (xs, ys)
      })
    )

// collection/list/sort
rules

  /**
   * Swaps the two first elements in a list if s succeeds on this pair.
   * As the swapping occurs if the predicate succeeds, lt and gt will
   * seem to have inverse semantics.
   *
   * This rule is designed to plug into sort-list and isort-list. See
   * these strategies for examples.
   *
   * Example: <SortL(gt)> [3,1,2,4] => [1,3,2,4]
   *
   * @param s   a * b -> _
   * @type    List(a) -> List(a)
   */
  SortL(s) :
    [x, y | l] -> [y, x | l]
    where <s> (x, y)

  /**
   * Moves a particular element of a list to the front, determined by
   * the strategy argument s. Given the first element of the list x,
   * each succeeding element y will be compared to x using <s> (x,y).
   * The first y that makes s succeed, is moved to the front.
   *
   * Example: <LSort(gt)> [3,5,6,1] => [1,3,5,6]
   *
   * Here, 3 is compared with 5, 6, using gt, and will fail in both
   * cases. <gt> (3,1) will succeed, and 1 will be moved to the
   * front of the list.
   *
   * @param s  a * b -> _
   * @type     List(a) -> List(a)
   */
  LSort(s) :
    [x | l] -> [y, x | l']
    where <at-suffix({ys: ?[y | ys]; where(<s> (x, y)); !ys})> l => l'

  /**
   * Merges the first and a particular element of the list, determined
   * by the strategy argument s. Let x be the first element of the list,
   * and y be selected in succession from the tail. s will be applied
   * to (x,y) in turn, and when it succeeds, the result will be placed
   * at the head of the list, replacing x.
   *
   * Example: LMerge(gt ; add)> [3,5,6,1] => [4,5,6]
   *
   * @param s   a * b -> c
   * @type    List(a) -> List(c | a)
   */
  LMerge(s) :
    [x | l] -> [z | l']
    where <at-suffix(\ [y | ys] -> ys where <s> (x, y) => z\ )> l => l'

strategies

  /**
   * Sorts a list when given a suitable comparsion strategy s. The
   * strategy s should be selected from LSort, SortL and LMerge.
   *
   * Example: <sort-list(LSort(gt))> [3,5,6,1] => [1,3,5,6]
   * Example: <sort-list(LMerge(add))> [3,6,5,1] => [15]
   *
   * @param s List(a) -> List(a)
   * @type    List(a) -> List(a)
   */
  sort-list(s) =
    try(rec x((s <+ [id | x]); try(x)))

  /**
   * Sorts a list when given a suitable comparsion strategy s. The
   * strategy s should be selected from LSort, SortL and LMerge.
   *
   * Example: <isort-list(LSort(gt))> [3,5,6,1] => [1,3,5,6]
   * Example: <isort-list(LMerge(add))> [3,6,5,1] => [15]
   *
   * @param s List(a) -> List(a)
   * @type    List(a) -> List(a)
   */
  isort-list(s) =
    try(rec x(([id | x] <+ s); try(x)))

  /** @internal */
  jsort-list(s) =
    try(rec x([id | x] <+ s; try(x)))

 /**
  * Removes duplicates from a list, returning a list of mutually unique terms.
  *
  * @type List(a) -> List(a)
  *
  * @inc tuple-uniq-test
  */
  uniq =
    let Uniq = \ [x | xs] -> [x | <filter(not(?x))> xs] \
     in listtd(try(Uniq))
    end

strategies

  /**
   * Sort a list using the quick-sort algorithm.
   *
   * qsort(lt) sorts a list of integers in ascending order.
   *
   * @param  swap  (a, a)  -> _
   * @type         List(a) -> List(a)
   */
  qsort(swap) =
    let swapper(|a2) = <swap> (<id>, a2)
     in quick-sort(swapper)
    end

/**
 * Quick-sort without tuples and concats.
 */
strategies

  quick-sort(swap : a * a -> b) =
    quick-sort(swap | [])

  quick-sort(swap : a * a -> b | t) :
    [] -> t

  quick-sort(swap: a * a -> b | t) :
    [x | xs] -> <quick-sort(swap | [x | t'])> smaller
    where
        smaller := <retain-all(where(swap(|x)))> xs => a
      ; bigger := <remove-all(where(swap(|x)))> xs
      ; t' := <quick-sort(swap | t)> bigger

// collection/list/zip
strategies

  /**
   * Create the cartesian product of two lists, i.e., combine
   * each element of the first list which each element from the second
   * list. The strategy s is used to combine the pairs of elements
   * <s>(x,y).
   *
   * Example: <cart(id)> ([1,2],[5,6]) => [(1,5),(1,6),(2,5),(2,6)]
   *
   * @param s              a * b -> c
   * @type     List(a) * List(b) -> List(c)
   */
  cart(s) :
    (xs, ys) ->
    <foldr(![], conc, \ x -> <map(\y -> <s>(x, y)\ )> ys\ )> xs

  /**
   * Creates the cartesian product of two lists and select only
   * those combined elements <s>(x, y) that succeed.
   *
   * @param s              a * b -> c
   * @type     List(a) * List(b) -> List(c)
   */
  join(s) :
    (xs, ys) ->
    <foldr(![], union, \x -> <filter(\y -> <s>(x, y)\ )> ys\ )> xs

  /** @internal */
  Skip(s) : ([x|xs], ys) -> (x, (xs, ys))

strategies

  /** @internal */
  genzip(a, b, c, s) =
    rec x(a + b; (s, x); c)

  /**
   * Combines two lists into one by pairing up the elements from both lists.
   * Both lists must be of equal length.
   *
   * Example: <zip> ([1,2], [3,4]) => [(1,3),(2,4)]
   *
   * @inc zip-test1
   *
   * @type List(a) * List(b) -> List(a * b)
   */
  zip  = zip(id)

  /**
   * Combines two lists into one by pairing up the elements from both lists,
   * applying s to the pair. Starts at the beginning of the lists. Both lists
   * must be of equal length.
   *
   * Example: <zip(add)> ([1,2], [3,4]) => [4,6]
   *
   * @param s              a * b -> c
   * @type     List(a) * List(b) -> List(c)
   */
  zip(s)  =
    genzip(Zip1,   Zip2,   Zip3,   s)

  zip'(s) =
    genzip(Zip1a' <+ Zip1b',   Zip2,   Zip3,   s)

  zipl(s) =
    genzip(Zip1a',   Zip2,   Zip3,   s)

  zipr(s) =
    genzip(Zip1b',   Zip2,   Zip3,   s)

  rest-zip(s) =
    genzip((?([],_) + ?(_,[])); ?(tla, tlb); ![], Zip2, Zip3, s);
    \ pairs -> (tla, tlb, pairs) \

  /**
   * Combines two lists into one by pairing up the elements from both lists.
   * Both lists must be of equal length.
   *
   * @param Strategy s(|y : b) : a -> c
   * @param Second list : List(b)
   * @type List(a) -> List(c)
   */
  zip(s : t * t -> t | ys) =
    if ?[x | xt] then
      where(!ys => [y | yt])
      ; ![<s(|y)> x | <zip(s|yt)> xt]
    else
      ?[]
    end


strategies

  // :: [a * b] -> [a] * [b]
  /**
   * Splits a list of pairs into two separate lists. This strategy
   * is the inverse of zip.
   *
   * Example: <unzip> [(1,2),(3,4)] => ([1,3],[2,4])
   *
   * @type     List(a * b) -> List(a) * List(b)
   */
  unzip = unzip(id)

  /**
   * Splits a list of pairs into two separate lists, applying s to
   * the pair before splitting. This strategy
   * is the inverse of zip.
   *
   * Example: <unzip((inc, inc))> [(1,2),(3,4)] => ([2,4],[3,5])
   *
   * @type     List(a * b) -> List(a) * List(b)
   */
  unzip(s) =
    genzip(UnZip1, UnZip3, UnZip2, s)

 /**
  * @inc nzip0-test
  */
  nzip0(s) =
    NZip00 ; genzip(NZip1,  NZip2,  NZip3,  s)
  nzip(s) =
    NZip01 ; genzip(NZip1,  NZip2,  NZip3,  s)

  lzip(s) =
    genzip(Zip1a', LZip2, Zip3, s)
  rzip(s) =
    genzip(Zip1b', RZip2, Zip3, s)

  zipFetch(s) =
    rec x(Zip2; ((s, id) <+ (id, x)))
  lzipFetch(s) =
    rec x(LZip2; ((s, id) <+ (id, x)))
  rzipFetch(s) =
    rec x(RZip2; ((s, id) <+ (id, x)))

  /**
   * Combines two lists, which may have different lengths, into one by pairing
   * up the elements from both lists, applying s to the pair. Starts at the
   * beginning of the lists. The shorter list will be padded with the result
   * the padding strategy.
   *
   * Example: <zipPad(id, !0)> ([1,2], [3,4,5]) => [(1,3),(2,4),(0,5)]
   *
   * @param s              a * b -> c
   * @param padding            _ -> d
   * @type     List(a) * List(b) -> List(c)
   */
  zipPad(s, padding) =
    rec x(Zip1 + Zip2; (s, x); Zip3 +
          ([], [id|id]); (![<padding>()|[]], id); x +
          ([id|id], []); (id, ![<padding>()|[]]); x)

  zip-tail =
    rec x(Zip1c + (Tl, Tl); x)
  zipl-tail-match(s) =
    rec x(Zip1c + Zip2; (s, id); Snd; x)
  zipr-tail-match(s) =
    rec x(Zip1c' + Zip2; (s, id); Snd; x)

  zip-skip(pred, s) =
    rec x(Zip1 + (Skip(pred); (id, x) <+ Zip2; (s, x)); Zip3)

rules

  /** @internal */
  Zip1   : ([],[]) -> []
  /** @internal */
  Zip1a' : ([],_) -> []
  /** @internal */
  Zip1b' : (_,[]) -> []
  /** @internal */
  Zip1c  : ([],x) -> x
  /** @internal */
  Zip1c' : (x,[]) -> x
  /** @internal */
  Zip1d  : ([],[_|_]) -> []
  /** @internal */
  Zip2   : ([x|xs],[y|ys]) -> ((x, y), (xs, ys))

  /** @internal */
  LZip2  : ([x|xs], y) -> ((x, y), (xs, y))
  /** @internal */
  RZip2  : (x, [y|ys]) -> ((x, y), (x, ys))

  /** @internal */
  Zip3   : (x, xs) -> [x|xs]

  /** @internal */
  UnZip1 : [] -> ([], [])
  /** @internal */
  UnZip2 : ((x, y), (xs, ys)) -> ([x|xs], [y|ys])
  /** @internal */
  UnZip3 : [x |  xs] -> (x, xs)

  /** @internal */
  NZip00 : xs -> (0, xs)
  /** @internal */
  NZip01 : xs -> (1, xs)
  /** @internal */
  NZip1  : (n, []) -> []
  /** @internal */
  NZip2  : (n, [y|ys]) -> ((n, y), (<add> (n, 1), ys))
  /** @internal */
  NZip3  : (x, xs) -> [x| xs]

// collection/set/indexed
/**
 * IndexedSet representations
 */
signature
  constructors
    IndexedSet : ImplDep -> IndexedSet

/**
 * IndexedSet construction and deconstruction
 */
strategies

  /**
   * Creates a new set with default initial size and maximum load.
   *
   * @type  _ -> IndexedSet
   */
  new-iset =
    new-iset(|117,75)

  /**
   * Creates a new set with specified initial size and maximum load.
   *
   * @param  Int, Initial size of internal storage
   * @param  Int, 0-100.
   * @type   _ -> IndexedSet
   */
  new-iset(|initial_size, max_load) =
    prim("SSL_indexedSet_create", initial_size, max_load); !IndexedSet(<id>)

  /**
   * Releases all memory occupied by the set.
   * A destroyed set can no longer be used.
   *
   * @type  IndexedSet -> IndexedSet
   */
  iset-destroy =
    ?IndexedSet(set); prim("SSL_indexedSet_destroy", set); !IndexedSet(<id>)

  /**
   * Removes all elements from the set.
   *
   * @type  IndexedSet -> IndexedSet
   */
  iset-clear =
    ?IndexedSet(set); prim("SSL_indexedSet_reset", set); !IndexedSet(<id>)

/**
 * IndexedSet operations
 */
strategies

  /**
   * Adds elem to the set.
   *
   * If the elem is already in the set, then on_old is applied to
   * its index.
   *
   * @param  Int -> a
   * @type   IndexedSet -> (Int | a )
   */
  iset-add(on_old|elem) =
    ?IndexedSet(set); prim("SSL_indexedSet_put", on_old | set, elem)

  /**
   * Ensures that elem is in the set.
   *
   * @type IndexedSet -> IndexedSet
   */
  iset-add(|elem) =
    ?set; iset-add(id|elem); !set

  /**
   * Ensures that all elems in the specified list are in the set.
   *
   * @type IndexedSet -> IndexedSet
   */
  iset-addlist(|lst) =
    ?set; <map({ elem: ?elem; <iset-add(|elem)> set })> lst; !set

  /**
   * Fails if elem is not in the set.
   *
   * @type  IndexedSet -> IndexedSet
   */
  iset-contains(|elem) =
    where(iset-get-index(|elem))

  /**
   * Removes elem from set.
   *
   * If the elements is not in the set, then this strategy does not fail.
   *
   * @type  IndexedSet -> IndexedSet
   */
  iset-remove(|elem) =
    ?IndexedSet(set); prim("SSL_indexedSet_remove", set, elem); !IndexedSet(<id>)

  /**
   * Returns all elements of the set.
   *
   * @type  IndexedSet(a) -> List(a)
   */
  iset-elements =
    ?IndexedSet(set); prim("SSL_indexedSet_elements", set)


  /**
   * Unites a set with another.
   *
   * @param  IndexedSet
   * @type   IndexedSet -> IndexedSet
   */
  iset-union(|set2) =
    ?set1
  ; where(<iset-elements; map({ elem: ?elem; <iset-add(|elem)> set1 })> set2)

  /**
   * Intersects a set with another.
   *
   * @param  IndexedSet
   * @type   IndexedSet -> IndexedSet
   */
  iset-isect(|set2) =
    ?set1
  ; where(iset-elements
          ; map({ elem:
                  ?elem
                ; (<iset-contains(|elem)> set2
                   <+ <iset-remove(|elem)> set1)
                }))

  /**
   * Checks whether one set is a subset of another.
   *
   * @param  IndexedSet
   * @type   IndexedSet -> IndexedSet
   */
  iset-subset(|set2) =
    ?set1
  ; where(<iset-elements; map({ elem: ?elem; <iset-contains(|elem)> set1 })> set2)

  /**
   * Checks whether a set has equal contents as another.
   *
   * @param  IndexedSet
   * @type   IndexedSet -> IndexedSet
   */
  iset-eq(|set2) =
    ?set1
  ; where(iset-subset(|set2))
  ; where(<iset-subset(|set1)> set2)

  /**
   * Applies s to the elements of a Set until it no more elements are added to this set.
   *
   * @param a -> List(a)
   * @type  Set(A) -> Set(A)
   */
  iset-fixpoint(s) =
    ?set@IndexedSet(_)
    ; repeat(
        where(
          iset-elements
        ; list-some(
            s
          ; list-some({new:
              ?new
            ; <iset-add(fail|new)> set
            })
          )
        )
      )

/**
 * Low-level set strategies (having knowledge of an index)
 */
strategies

  /**
   * Gets the index of elem in the set.
   *
   * Fails if elem is not in the set.
   *
   * @type  IndexedSet -> Int
   */
  iset-get-index(|elem) =
    ?IndexedSet(set); prim("SSL_indexedSet_getIndex", set, elem)

  /**
   * Gets the element at index in the set.
   *
   * Always provide a valid index: behaviour is undefined if the index
   * is not in the set.
   *
   * @type  IndexedSet -> Int
   */
  iset-get-elem(|index) =
    ?IndexedSet(set); prim("SSL_indexedSet_getElem", set, index)

// collection/tuple/common
strategies

  /** Convert a tuple to a list.
   *
   * @type List(a) -> Tuple(a)
   */
  TupleToList : "" # (xs) -> xs

  /** Convert a list to a tuple.
   *
   * @type Tuple(a) -> List(a)
   */
  ListToTuple : xs -> "" # (xs)

  /** Retrieve the first element of a tuple.
   *
   * @type Tuple(a, xs...) -> a
   */
  Fst   : "" # ([x | xs]) -> x

  /** Retrieve the second element of a tuple.
   *
   * @type Tuple(a, b, xs...) -> b
   */
  Snd   : "" # ([x, y | xs]) -> y

  /** Retrieve the third element of a tuple.
   *
   * @type Tuple(a, b, c, xs...) -> c
   */
  Third : "" # ([x, y, z | xs]) -> z

  /** Duplicate a term into a two-element tuple
   *
   * @type a -> Tuple(a, a)
   */
  Dupl  : x -> (x, x)

  /** Apply a pair of strategies, f and g, to an element.
   *
   * @param f        a -> a'
   * @param g        a -> b'
   * @type           a -> Tuple(a', b')
   */
  split(f, g) = !(<f>, <g>)

  /** Apply a triple of strategies, f, g and h to an element.
   *
   * @param f        a -> a'
   * @param g        a -> b'
   * @param h        a -> c'
   * @type           a -> Tuple(a', b', c')
   */
  split3(f, g, h) = !(<f>, <g>, <h>)

  /** Swap two elements in a tuple.
   *
   * @type Tuple(a, b) -> Tuple(b, a)
   */
  Swap : (x, y) -> (y, x)

  /** Retrieve the head of a tuple.
   *
   * @type Tuple(a) -> a
   * @see Fst
   */
  Thd = Fst

  /** Retrieve the tail of a tuple. A new tuple with all elements except
   * the first will be returned.
   *
   * @type Tuple(a) -> Tuple(a)
   */
  Ttl : "" # ([x | xs]) -> "" # (xs)

  /** Get the nth element of a tuple. The index must be smaller than the
   * number of elements in the tuple.
   *
   * @type (Int, Tuple(a)) -> a
   * @see index
   */
  tindex =
    (id, ?""#(<id>)); index

  /** Predicate that checks if the supplied term is a tuple.
   *
   * @type Tuple(a) -?> Tuple(a)
   */
  is-tuple =
    ?""#(_)

  /** Apply a strategy s to a swapped version of the supplied tuple.
   * The supplied tuple will be swapped, then is s applied.
   *
   * @param s          Tuple(b,a) -> Tuple(b', a')
   * @type             Tuple(a,b) -> Tuple(b', a')
   */
  flip(s) = Swap; s

  /** Apply a strategy to each element of a tuple. This strategy maps
   * a strategy s over all elements in a tuple.
   *
   * @param s           a -> b
   * @type              Tuple(a) -> Tuple(b)
   */
  tmap(s) =
    is-tuple; all(s)

  /** Concatenate the lists in a tuple of lists, using s as the
   * concatenation strategy.
   *
   * The concatenation strategy is asked to concatenate a two-element
   * tuple of lists and produce a list. Concatenation goes from right to
   * left.
   *
   * @param s          Tuple(List(a), List(a)) -> List(a)
   * @type             Tuple(List(a))
   */
  tconcat(s) =
    is-tuple; crush(![], s)

  /** Concatenate the lists in a tuple of lists, using s2 as the
   * concatenation strategy and s1 as the startup strategy.
   *
   * The strategy s1 is applied once initially to an empty list, and
   * can be used to create a custom tail on the resulting list. It can
   * also be used to concatenate into non-list types.
   *
   * The concatenation strategy s2 is asked to concatenate a
   * two-element tuple of lists and produce list. Concatenation goes
   * from right to left.
   *
   * Example: <tconcat'(!0, \([a],b)-><add> (a,b)\)> ([1],[2],[3]) => 6
   *
   * @param s1         Nil -> b
   * @param s2         Tuple(List(a), b) -> b
   * @type             Tuple(List(a))
   * @see tconcat
   */
  tconcat'(s1, s2) =
    is-tuple; crush(<s1> [], s2)

  /** Apply a s1 and s2 in a catamorphic way to reduce a tuple.
   *
   * s2 must be a catamorphism, i.e. it must be able to reduce the
   * elements of the tuple from right to left.
   *
   * This strategy is also named tfoldr, as it is equivalent to a
   * right-fold on tuples.
   *
   * @param s1         Nil -> b
   * @param s2         Tuple(a, b) -> b
   * @type             Tuple(a) -> b
   * @see foldr
   */
  tcata(s1, s2) =
    is-tuple; crush(s1, s2)

  /**
   * Fold a tuple from right to left using s2 as the folding strategy.
   * s1 is used to obtain the right-element (of type b) for s2.
   *
   * @param s1         Nil -> b
   * @param s2         Tuple(a, b) -> b
   * @type             Tuple(a) -> b
   * @see tcata
   */
  tfoldr(s1, s2) =
    tcata(s1, s2)

  /** Zip two tuples with s as the zipping strategy.
   *
   * Example: <tzip(add)> ((1,2,3),(5,4,3)) -> [6,6,6]
   *
   * @param s          Tuple(a,b) -> c
   * @type             Tuple(Tuple(a), Tuple(b)) -> c
   * @see zip
   */
  tzip(s)  =
    (TupleToList, TupleToList); zip(s)

  /**
   * @inc tuple-zip-test
   */
  tuple-zip(s) =
    rec x(![<tmap(Hd); s> | <tmap(Tl); x>]
          <+ tmap([]); ![])

  /**
   * @inc tuple-unzip-test
   */
  tuple-unzip(s) =
    rec x(![<map(Thd); s> | <map(Ttl); x>] <+ map(()); ![])
  ; !"" #(<id>)

// collection/tuple/cons
signature
  constructors
    : ()
    : a -> (a)
    : a * b -> (a, b)
    : a * b * c -> (a, b, c)
    : a * b * c * d -> (a, b, c, d)
    : a * b * c * d * e -> (a, b, c, d, e)
    : a * b * c * d * e * f -> (a, b, c, d, e, f)
    : a * b * c * d * e * f * g -> (a, b, c, d, e, f, g)
    : a * b * c * d * e * f * g * h -> (a, b, c, d, e, f, g, h)
    : a * b * c * d * e * f * g * h * i -> (a, b, c, d, e, f, g, h, i)
    : a * b * c * d * e * f * g * h * i * j -> (a, b, c, d, e, f, g, h, i, j)
    : a * b * c * d * e * f * g * h * i * j * k -> (a, b, c, d, e, f, g, h, i, j, k)
    : a * b * c * d * e * f * g * h * i * j * k * l -> (a, b, c, d, e, f, g, h, i, j, k, l)
    : a * b * c * d * e * f * g * h * i * j * k * l * m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
    : a * b * c * d * e * f * g * h * i * j * k * l * m * n -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    : a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q * r -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)

overlays
 /**
  * Overlay for a pair, converts two terms to a 2-tuple.
  */
  Pair(x, y) = (x, y)

// lang/cong
strategies

Anno_Cong__(termStrat, annoStrat): term{^annos} -> term'{^annos'}
  where term'  := <termStrat> term
      ; annos' := <annoStrat> annos

// lang/dynamic-rules
signature
  constructors
    RuleScope  : IndexedSet * Hashtable -> RuleScope
    ChangeSet  : IndexedSet * IndexedSet * Hashtable -> RuleScope

    Label      : String -> Label
    SplitPos   : String * String -> SplitPos
    BreakCS    : String * String -> BreakCS
    ContinueCS : String * String -> ContinueCS
    IgnoreB    : String -> IgnoreB
    IgnoreC    : String -> IgnoreC

    Catch       : String * String -> Catch
    Finally     : String -> Finally
    TryBlock    : Int * String * [Catch] * Finally -> TryBlock
    Structure   : String -> Structure
    IgnoreT     : String -> IgnoreT
    ThrowCS     : String * String -> ThrowCS
    ExceptionCS : String * String -> ExceptionCS

signature
  constructors
    DR_DUMMY : DUMMY
    DR_UNDEFINE : String -> DUMMY


/**
 * Currently active rule set
 */
strategies

  /**
   * Retrieve the primitive dynamic rules hashtable.
   */
  dr-rule-sets-hashtable =
    prim("SSL_dynamic_rules_hashtable")

  /**
   * @type  _ -> List(RuleScope)
   */
  dr-get-rule-set(|name) =
    prim("SSL_hashtable_get", <dr-rule-sets-hashtable>, name)
    <+ dr-new-rule-set
       ; dr-set-rule-set(|name)

  dr-set-rule-set(|name) =
    where(
      ?ruleset
      ; prim("SSL_hashtable_put", <dr-rule-sets-hashtable>, name, ruleset)
    )

  dr-switch-rule-set(|name) =
    where(dr-get-rule-set(|name) => rs)
    ; dr-set-rule-set(|name)
    ; !rs

  // Note: the storing the currently active rule set should
  // be done in a global variable at the C level (probably).
  // We should abstract from that as much as possible and
  // just consider the rule-set as a value that can be
  // changed. Manipulating the content should be the same
  // for any storage solution we use.

  // a question to consider: should operations be relative
  // to the current rule-set or should we make a set of
  // operations that work on a named rule-set and deal
  // with the pointer change at a higer-level?

  // Well, we can actually have two APIs, one working on
  // the implicit global rule-set, and the other working
  // on the explicit representation.

  // whose responsibility is it to initialize the outer scope?
  // In the definition above an initial hashtable is created
  // when no rule-set was available yet.

strategies // high-level API with implicit rule set

  // Note that the compiler can generate a specifically named
  // rule for each of the strategies in this API, e.g,
  // add-rule-name, lookup-rule-name, etc. Then the compiler
  // can specialize the applications.

  dr-scope(s | name) =
    dr-begin-scope(|name)
    ; (s < dr-end-scope(|name)
         + dr-end-scope(|name); fail)

  /**
   * @type  t -> t
   */
  dr-begin-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-scope
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-end-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-leave-scope
      ; dr-set-rule-set(|name)
    )

  /**
   * Scope all dynamic rules.
   *
   * @note While get-config and set-config do not actually use dynamic rules,
   *       this strategy also scopes the config hashtable.
   */
  dr-scope-all(s) =
    {| DrScopedRules, DrScopedConfig :
      finally(
        dr-scope-all-start; s
      , dr-scope-all-end
      )
    |}

  /**
   * Start a new scope for all dynamic rules.
   *
   * @note While get-config and set-config do not actually use dynamic rules,
   *       this strategy also scopes the config hashtable.
   *
   * @see dr-scope-all(s)
   */
  dr-scope-all-start =
    where(
      config := <lookup-table(|"config")>
    ; table-hashtable
    ; hashtable-put(|"config", <hashtable-copy> config)
    ; table  := Hashtable(<dr-rule-sets-hashtable>)
    ; names  := ["DrScopedRules" | <hashtable-keys> table]

    ; dr-begin-scopes(|names)
    ; rules(
        DrScopedRules  := names
        DrScopedConfig := config
      )
    )

  /**
   * End a scope for all dynamic rules.
   *
   * @see dr-scope-all(s)
   */
  dr-scope-all-end =
    where(
      table := Hashtable(<dr-rule-sets-hashtable>)
    ; names := <DrScopedRules>
    ; table-hashtable
    ; hashtable-put(|"config", <DrScopedConfig>)
    ; dr-end-scopes(|names)

      // Remove other, newly defined rules
    ; <diff> (<hashtable-keys> table, names)
    ; list-loop(
        { key: ?key
        ; <hashtable-remove(|key)> table
        }
      )
    )

  dr-scopes(s | names) =
    dr-begin-scopes(|names)
    ; (s < dr-end-scopes(|names)
         + dr-end-scopes(|names); fail)

  /**
   * @type  t -> t
   */
  dr-begin-scopes(|names) =
    where(
      !names
      ; map({?name
             ; dr-get-rule-set(|name)
             ; dr-add-scope
             ; dr-set-rule-set(|name)})
    )

  /**
   * @type  t -> t
   */
  dr-end-scopes(|names) =
    where(
      !names
      ; map({?name
             ; dr-get-rule-set(|name)
             ; dr-leave-scope
             ; dr-set-rule-set(|name)})
    )

  /**
   * @type  t -> t
   */
  dr-start-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-start-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-commit-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-commit-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-discard-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-discard-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-label-scope(|name, label) =
    where(
      dr-get-rule-set(|name)
      ; dr-label-scope(|label)
      ; dr-set-rule-set(|name)
    )

   /**
    * Get all scope labels ordered from inner, most recent, to outer, oldest.
    */

  dr-get-scope-labels(|name) =
    dr-get-rule-set(|name)
    ; dr-get-scope-labels

   /**
    * Get the first scope label for which s succeeds starting with the
    * inner, most recent, scope.
    */

  dr-get-first-scope-label(s|name) =
    dr-get-rule-set(|name)
    ; dr-get-first-scope-label(s)

strategies

  /**
   * Apply s in a state where the current dynamic rules for name are ignored.
   *
   * @param strategy to apply (a -> b)
   * @param name of the dynamic rules (String)
   * @type a -> b
   */
  dr-ignore-state(s|name) =
    where(
      dr-new-rule-set => newrule
      ; dr-switch-rule-set(|name) => oldrule
    )
  ; s
  ; where(
      <dr-leave-scope> newrule
      ; <dr-set-rule-set(|name)> oldrule
    )

  /**
   * Apply s in a state where the current dynamic rules for names are ignored.
   *
   * @param strategy to apply (a -> b)
   * @param names of the dynamic rules (List(String))
   * @type a -> b
   */
  dr-ignore-states(s|names) =
    where(
      newrules := <map(dr-new-rule-set)> names
      ; zip(dr-switch-rule-set | names) => oldrules
    )
    ; s
    ; where(
        <list-loop(dr-leave-scope)> newrules
      ; <zip(dr-set-rule-set | names)> oldrules
      )

strategies

  dr-lookup-rule(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-rule(|key)

  dr-lookup-all-rules(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-all-rules(|key)

  dr-lookup-rule-pointer(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-rule-pointer(|key)

  dr-all-keys(|name) =
    dr-get-rule-set(|name)
    ; dr-all-keys(|[], <new-iset>)

  dr-set-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rule-vis(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rules-vis(|name, label, key, values) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, values)
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, label, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule-vis(|name, label, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, [])
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set(|key, value)
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set(|label, key, value)
      ; dr-set-rule-set(|name)
    )

  dr-add-rule-vis(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set-vis(|label, key, value)
      ; dr-set-rule-set(|name)
    )

  /**
   * Intersect live rule-set with given rule set changing the live rule set.
   */

  dr-intersect-with(|name) =
    <dr-intersect-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Intersect live rule-set with given rule set changing both.
   */

  dr-intersect-symm(|name) =
    <dr-intersect-rule-sets-symm>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Merge live rule-set with given rule set using union changing the live rule set.
   */

  dr-union-with(|name) =
    <dr-union-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Merge live rule-set with give rule set using union changing both.
   */

  dr-union-symm(|name) =
//    <dr-union-rule-sets-symm>(<id>, <dr-get-rule-set(|name)>)
    <dr-union-rule-sets-symm>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)


  /**
   * Left choice with dynamic rule roll-back in case s1 fails.
   */

  dr-left-choice(s1,s2|rulenames) =
    where(<map(dr-start-change-set(|<id>))> rulenames)
    ; s1
    < where(<map(dr-commit-change-set(|<id>))> rulenames)
    + where(<map(dr-discard-change-set(|<id>))> rulenames)
      ; s2

/**
 * Low-level API working directly on rule-set.
 */

strategies // debugging

  dr-save-rule-set =
    alltd(hashtable-getlist)

strategies // scope

  // a rule-set is represented by a list of (label list, hash-table) pairs

  dr-new-scope =
    !RuleScope(<new-iset; iset-add(|())>, <new-hashtable>)

  dr-new-rule-set =
    ![<dr-new-scope>]

  dr-add-scope =
    ![<dr-new-scope> | <id>]

  dr-destroy-scope =
    RuleScope(iset-destroy, hashtable-destroy)

  dr-leave-scope :
    [scope | scopes] -> scopes
    where <dr-destroy-scope> scope

  dr-get-inner-scope :
    [scope | scopes] -> scope

  dr-label-scope(|label) =
    [ RuleScope(iset-add(|label), id)
      + ChangeSet(iset-add(|label), id, id)
    | id]
    // todo: distinction between rulescope and changeset necessary here or not??
//    [RuleScope(labels, tbl) | scopes] -> [RuleScope([label | labels], tbl) | scopes]

   dr-get-scope-labels =
     mapconcat(?RuleScope(<iset-elements>,_) + ?ChangeSet(<iset-elements>,_,_))

   /**
    * Get the first scope label for which s succeeds.
    */

   dr-get-first-scope-label(s) =
     fetch-elem(?RuleScope(<iset-elements; fetch-elem(s)>,_)
                + ?ChangeSet(<iset-elements; fetch-elem(s)>,_,_))

strategies // change sets

  dr-new-change-set =
    !ChangeSet(<new-iset>, <new-iset>, <new-hashtable>)

  dr-start-change-set =
    ![<dr-new-change-set> | <id>]

  dr-destroy-change-set =
    ChangeSet(iset-destroy, iset-destroy, dr-destroy-and-unmark)

  dr-destroy-and-unmark =
    ?Hashtable(csid)
    ; hashtable-destroy
    ; try(
        <DR_BREAK>IgnoreB(csid) => labelb
        ; rules(DR_BREAK.labelb :- IgnoreB(csid))
      )
    ; try(
        <DR_BREAK>IgnoreC(csid) => labelc
        ; rules(DR_BREAK.labelc :- IgnoreC(csid))
      )
    ; try(
        <DR_EXCEPTION>IgnoreT(csid)
        ; rules(DR_EXCEPTION :- IgnoreT(csid))
      )

  dr-clone-change-set =
    ?ChangeSet(labels1, rmset1, tbl1)
    ; dr-new-change-set => cs@ChangeSet(labels2, rmset2, tbl2)
    ; <iset-addlist(|<iset-elements>labels1)>labels2
    ; <iset-addlist(|<iset-elements>rmset1)>rmset2
    ; <hashtable-keys>tbl1
    ; map({key : ?key; <hashtable-put(|key, <hashtable-get(|key)>tbl1)>tbl2})
    ; !cs

  dr-commit-change-set =
    dr-commit-change-set(id)

  /**
   * The strategy destroy indicates whether the change
   * set should also be destroyed after the commmit.
   */
  dr-commit-change-set(destroy) :
    [cs@ChangeSet(labelset, rmset, tbl@Hashtable(csid)) | rs] -> rs''
    where <hashtable-keys> tbl
        ; foldr(<dr-commit-labels(|labelset)> rs
               , dr-apply-change(|tbl)) => rs'
        ; <iset-elements> rmset
        ; foldr(!rs', dr-apply-removal) => rs''
        ; try(
            destroy
            ; <DR_BREAK>IgnoreB(csid) => labelb
            ; (<fetch(ChangeSet(id, id, ?Hashtable(csidnextb)))>rs''
               ; dr-define-ignoreB(|csidnextb, labelb)
               <+ fatal-err(|"dr-break was called outside of a fix and merge operator or a dr-label call"))
          )
        ; try(
            destroy
            ; <DR_BREAK>IgnoreC(csid) => labelc
            ; (<fetch(ChangeSet(id, id, ?Hashtable(csidnextc)))>rs''
               ; dr-define-ignoreC(|csidnextc, labelc)
               <+ fatal-err(|"dr-continue was called outside of a fix and merge operator call"))
          )
        ; try(
            destroy
            ; <DR_EXCEPTION>IgnoreT(csid)
            ; (<fetch(ChangeSet(id, id, ?Hashtable(csidnextt)))>rs''
               ; dr-define-ignoreT(|csidnextt)
               <+ fatal-err(|"dr-throw was not called in the proper exception handling context"))
          )
        ; try(destroy; <dr-destroy-change-set> cs)

  dr-discard-change-set :
    [cs@ChangeSet(_, _, _) | rs] -> rs
    where <dr-destroy-change-set> cs

  dr-commit-labels(|labelset) =
    [ ChangeSet(iset-union(|labelset), id, id)
      + RuleScope(iset-union(|labelset), id)
    | id]

  /**
   * commit to ruleset is finding the first ChangeSet (any) *or* the first
   * RuleScope that has the appropriate scopeid (i.e. hashtable pointer)
   * and setting the key-value into it
   */

  dr-apply-change(|tbl) :
    (key1@(scpid, key), rs) -> <dr-commit-to-rule-set(|scpid, key, <hashtable-get(|key1)> tbl)> rs


  dr-commit-to-rule-set(|scpid, key, value) =
    dr-commit-to-change-set(|scpid, key, value)
    <+ dr-commit-to-rule-scope(|scpid, key, value)

  dr-commit-to-change-set(|scpid, key, value) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; where(
        (<dr-lookup-rule-in-scope(|key, scpid)>rs => value
         < <hashtable-remove(|(scpid, key))>tbl
         + <hashtable-put(|(scpid, key), value)>tbl)
        ; <iset-remove(|(scpid, key))>rmset
      )

  dr-commit-to-rule-scope(|scpid, key, value) =
    ?[RuleScope(_, tbl@Hashtable(scpid)) | rs]
    ; where(<hashtable-put(|key, value)>tbl)
    <+ [RuleScope(id, id) | dr-commit-to-rule-set(|scpid, key, value) ]

/*
 * the old implementation (for reference)
 *

  dr-commit-to-rule-set(|scpid, key, value) =
    fetch(
      dr-commit-to-change-set(|scpid, key, value)
    + dr-commit-to-rule-scope(|scpid, key, value))

  dr-commit-to-change-set(|scpid, key, value) =
    ?ChangeSet(_, _, tbl)
    ; where(<hashtable-put(|(scpid, key), value)> tbl)

  dr-commit-to-rule-scope(|scpid, key, value) =
    ?RuleScope(_,tbl@Hashtable(scpid))
    ; where(<hashtable-put(|key, value)> tbl)
*/

  dr-apply-removal :
    (key1@(scpid, key), rs) -> <dr-remove-from-rule-set(|scpid, key)> rs

  dr-remove-from-rule-set(|scpid, key) =
    fetch(
      dr-remove-from-change-set(|scpid, key)
    + dr-remove-from-rule-scope(|scpid, key))

  dr-remove-from-change-set(|scpid, key) =
    ChangeSet(id, iset-add(|(scpid, key)), ?tbl)
  ; where(<hashtable-remove(|(scpid, key))> tbl)

  dr-remove-from-rule-scope(|scpid, key) =
    ?RuleScope(_,tbl@Hashtable(scpid))
  ; where(<hashtable-remove(|key)> tbl)

strategies // looking up

  /**
   * Fetch the most recent definition for key.
   */

  // The "removed" parameter is now a list, which allows duplicates
  // to be added. This is not wrong, but it is marginally inefficient.
  // We actually need set-like behavior. Indexed sets, however, are
  // not an option because of the check of whether or not "removed"
  // contains key' in function look2. Since look2 is called later on,
  // when a RuleScope is reached, "removed" will potentially contain
  // some extra elements which should not be considered. This is the
  // case because of the in-place update of indexed sets.

  dr-lookup-rule(|key) =
    dr-lookup-rule(fail | key, [])

  dr-lookup-rule(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <not(fetch(?(hptr, key)))> removed
          ; <hashtable-get(|key)> tbl
       <+ <dr-lookup-rule(look | key, removed)> rs)

  dr-lookup-rule(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key')> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-rule(look2 | key, <conc>(keys, removed))> rs
      end

  /**
   * Version of dr-lookup-rule that looks for definition of a key
   * in a particular scope. The expected scope id (scpid) is the
   * pointer to the hashtable of a rule scope and is usually
   * identified by means of a label, i.e., a label indicates the
   * rule scope and the rule scope has a unique scope id.
   */

  dr-lookup-rule-in-scope(|key, scpid) =
    dr-lookup-rule-in-scope-rs(|key, scpid)
    <+ dr-lookup-rule-in-scope-cs(|key, scpid)

  dr-lookup-rule-in-scope-rs(|key, scpid) =
    ?[RuleScope(_, tbl@Hashtable(scpid)) | rs]      // if this is the right scope,
    < <hashtable-get(|key)>tbl                      // then check for key
    + (?[RuleScope(_, _) | rs]                      // else recurse
       ; <dr-lookup-rule-in-scope(|key, scpid)>rs)

  dr-lookup-rule-in-scope-cs(|key, scpid) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; (<iset-contains(|(scpid, key))>rmset
       < fail                                // key is marked for removal, so
                                             // in effect it is not defined
       + (<hashtable-get(|(scpid, key))>tbl
          <+ <dr-lookup-rule-in-scope(|key, scpid)>rs))

  /**
   * Fetch the most recent definition for key and return a pointer
   * to the table that defines it.
   */

  dr-lookup-rule-pointer(|key) =
    dr-lookup-rule-pointer(fail | key, [])

  dr-lookup-rule-pointer(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <not(fetch(?(hptr, key)))> removed
          ; <hashtable-get(|key)> tbl
          ; !(<id>, key, tbl)
       <+ <dr-lookup-rule-pointer(look | key, removed)> rs)

  dr-lookup-rule-pointer(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key'); !(<id>, key', tbl)> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-rule-pointer(look2 | key, <conc>(keys, removed))> rs
      end

  /**
   * Fetch all definitions for key.
   */

  dr-lookup-all-rules(|key) =
    dr-lookup-all-rules(fail | key, [])

  dr-lookup-all-rules(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; <conc>(<<look>(hptr, key)
              <+ <not(fetch(?(hptr, key)))> removed
                 ; <hashtable-get(|key)> tbl
              <+ ![]>
            ,<dr-lookup-all-rules(look | key, removed) <+ ![]> rs)

  dr-lookup-all-rules(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key')> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-all-rules(look2 | key, <conc>(keys, removed))> rs
      end

  /**
   * Fetch all keys defined in a rule set.
   */

  dr-all-keys(|removed, result) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; <partition(?(hptr, <id>))>removed => (localr, removed')
    ; <hashtable-keys>tbl
    ; filter({key: ?key; <not(fetch-elem(?key))>localr; !key}) => keys
    ; <iset-addlist(|keys)>result
    ; <dr-all-keys(|removed', result)>rs

  dr-all-keys(|removed, result) =
    ?[ChangeSet(_, rmset, tbl) | rs]
    ; <iset-elements>rmset
    ; <conc>(<id>, removed) => removed'
    ; <hashtable-keys>tbl
    ; filter({k, key: ?k@(_, key); <not(fetch-elem(?k))>removed'; !key}) => keys
    ; <iset-addlist(|keys)>result
    ; <dr-all-keys(|removed', result)>rs

  dr-all-keys(|removed, result) =
    ?[]; <iset-elements>result

strategies // setting a rule

  // A rule is always stored as a mapping from key to a list of values.
  // Setting a rule entails removing previous rules.

  /**
   * set a rule in the inner scope
   *
   * The inner scope has label () since all scopes are labeled
   * this way.
   */

  dr-set-in-rule-set(|key, value) =
    dr-set-in-rule-set(|(), key, value)

  /**
   * set a rule in the scope with specified label
   */

  dr-set-in-rule-set(|label, key, value) =
    dr-set-in-rule-set(dr-set-fail | label, key, value)

  dr-set-fail(|scpid, tbl, key, value) =
    fail

  dr-set-in-rule-set(set : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
           | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (set(|hptr, tbl, key, value)
           <+ where(<hashtable-put(|key, value)> tbl))
        + <dr-set-in-rule-set(set | label, key, value)> rs
      )

  dr-set-in-rule-set(set1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
           | label, key, value) =
    ?[ChangeSet(labelset, rmset, tbl1) | rs]
    ; where(
        let set2(|scpid, tbl2, key, value) =
              set1(|scpid, tbl2, key, value)
              <+ <dr-lookup-rule-in-scope(|key, scpid)> rs => value
                 ; <hashtable-remove(|(scpid, key))> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
              <+ <hashtable-put(|(scpid, key), value)> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
         in if <iset-contains(|label)> labelset
            then <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
                 ; set2(|hptr, tbl, key, value)
            else <dr-set-in-rule-set(set2 | label, key, value)> rs
            end
        end
      )


    // what to do if no scope with the label is defined?
    // currently this fails. This might default to adding to
    // the inner scope and labeling that inner scope as
    // well. However, that is quite expensive since
    // it would entail first going through all scopes to
    // establish non-existence of a label.


  /**
   * Add a rule to the rule-set with the specified label and make sure
   * it is visible by deleting any rules with the same key in scopes
   * upto the specified scope. Deleting by removing from the table, not
   * undefining.
   */

  dr-set-in-rule-set-vis(|key, value) =
    dr-set-in-rule-set(|key, value)

  dr-set-in-rule-set-vis(|label, key, value) =
    dr-set-in-rule-set-vis(dr-set-fail, dr-rm-fail | label, key, value)

  dr-rm-fail(|scpid, tbl, key) =
    fail

  dr-set-in-rule-set-vis(
      set : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        if <iset-contains(|label)> labelset then
          set(|hptr, tbl, key, value)
          <+ <hashtable-put(|key, value)> tbl
        else
          (rm(|hptr, tbl, key) <+ <hashtable-remove(|key)> tbl)
          ; <dr-set-in-rule-set-vis(set, rm | label, key, value)> rs
        end
      )

  dr-set-in-rule-set-vis(
      set1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm1  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[ChangeSet(labelset, rmset, tbl1) | rs]
    ; where(
        let set2(|scpid, tbl2, key, value) =
              set1(|scpid, tbl2, key, value)
              <+ <dr-lookup-rule-in-scope(|key, scpid)> rs => value
                 ; <hashtable-remove(|(scpid, key))> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
              <+ <hashtable-put(|(scpid, key), value)> tbl1
                 ; <iset-remove(|(scpid, key))> rmset

            rm2(|scpid, tbl2, key) =
              rm1(|scpid, tbl2, key)
              <+ if <dr-lookup-rule-in-scope(|key, scpid)> rs then
                   <hashtable-remove(|(scpid, key))> tbl1
                   ; <iset-add(|(scpid, key))> rmset
                 end

         in if <iset-contains(|label)> labelset then
              <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
              ; set2(|hptr, tbl, key, value)
            else
              <dr-set-in-rule-set-vis(set2, rm2 | label, key, value)> rs
            end
        end
      )

strategies // extending a rule

  // Extending a rule entails adding a value to the list of values
  // corresponding to the key. The intended semantics is that all
  // these values are

  dr-add-to-rule-set(|key, value) =
    dr-add-to-rule-set(|(), key, value)

  /**
   * add a rule to the scope for label
   *
   * @assert: dr-add-to-rule-set(|l, k, v)
   *               = set-rule(|l, k, [v | <lookup-rule(|l, k, v) <+ ![]>])
   */
  dr-add-to-rule-set(|label, key, value) =
    dr-add-to-rule-set(dr-add-fail | label, key, value)

  dr-add-fail(|scpid, tbl, key, value) =
    fail

  dr-rm-fail(|scpid, tbl, key) =
    fail

  dr-add-to-rule-set(add : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
             | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (add(|hptr, tbl, key, value)
           <+ where(<hashtable-push(|key, value)> tbl))
        + <dr-add-to-rule-set(add | label, key, value)> rs
      )

  dr-add-to-rule-set(add1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
             | label, key, value) =
    ?[ChangeSet(labelset, rmset, tbl1) | rs]
    ; where(
        let add2(|scpid, tbl2, key, value) =
              add1(|scpid, tbl2, key, value)
              <+ {values:  // this is when the hash table of the change
                           // set already contains a binding for the key
                  ![value | <hashtable-get(|(scpid, key))> tbl1] => values
                  ; if <dr-lookup-rule-in-scope(|key, scpid)> rs => values then
                      <hashtable-remove(|(scpid, key))> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    else
                      <hashtable-put(|(scpid, key), values)> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    end
                 }
                           // this is when the hash table of the change set
                           // already does not already contain a binding for the key
              <+ (<dr-lookup-rule-in-scope(|key, scpid)> rs <+ ![])
                 ; \ values -> <hashtable-put(|(scpid, key), [value | values])> tbl1 \

         in if <iset-contains(|label)> labelset then
               <fetch-elem(?RuleScope(_, tbl@Hashtable(hptr)))> rs
               ; add2(|hptr, tbl, key, value)
            else
               <dr-add-to-rule-set(add2 | label, key, value)> rs
            end
        end
      )

  /**
   * add a rule to the scope for label such that it is visible afterwards
   *
   * @assert: dr-add-to-rule-set(|l, k, v)
   *               = set-rule(|l, k, [v | <lookup-rule(|l, k, v) <+ ![]>])
   */
  dr-add-to-rule-set-vis(|label, key, value) =
    dr-add-to-rule-set-vis(dr-add-fail, dr-rm-fail | label, key, value)

  dr-add-to-rule-set-vis(
      add : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        if <iset-contains(|label)> labelset then
           add(|hptr, tbl, key, value)
           <+ <hashtable-push(|key, value)> tbl
        else
          (rm(|hptr, tbl, key) <+ <hashtable-remove(|key)> tbl)
          ; <dr-add-to-rule-set-vis(add, rm| label, key, value)> rs
        end
      )

  dr-add-to-rule-set-vis(
      add1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm1  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[ChangeSet(labelset, rmset, tbl1) | rs]
    ; where(
        let add2(|scpid, tbl2, key, value) =
              add1(|scpid, tbl2, key, value)
              <+ {values:  // this is when the hash table of the change
                           // set already contains a binding for the key
                  ![value | <hashtable-get(|(scpid, key))> tbl1] => values
                  ; if <dr-lookup-rule-in-scope(|key, scpid)> rs => values then
                      <hashtable-remove(|(scpid, key))> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    else
                      <hashtable-put(|(scpid, key), values)> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    end
                 }
                           // this is when the hash table of the change set
                           // already does not already contain a binding for the key
              <+ (<dr-lookup-rule-in-scope(|key, scpid)> rs <+ ![])
                 ; \ values -> <hashtable-put(|(scpid, key), [value | values])> tbl1 \

            rm2(|scpid, tbl2, key) =
              rm1(|scpid, tbl2, key)
              <+ if <dr-lookup-rule-in-scope(|key, scpid)> rs then
                   <hashtable-remove(|(scpid, key))> tbl1
                   ; <iset-add(|(scpid, key))> rmset
                 end

         in if <iset-contains(|label)> labelset then
              <fetch-elem(?RuleScope(_, tbl@Hashtable(hptr)))> rs
              ; add2(|hptr, tbl, key, value)
            else
              <dr-add-to-rule-set-vis(add2, rm2 | label, key, value)> rs
            end
        end
      )

strategies // intersection and union of rule-sets

  /**
   * Merge two rule sets scope by scope.
   *
   * @merge-rs : operation to merge RuleScopes
   * @merge-cs : operation to merge ChangeSets
   */

  dr-merge-rule-sets(merge-rs, merge-cs) =
    rec x(
      eq < fail
      + (dr-merge-rule-sets1(merge-rs, x)
         <+ dr-merge-rule-sets2(merge-cs, x))
    )

  dr-merge-rule-sets1(merge-rs, merge-rec) :
    (rs1@[RuleScope(labels1, tbl1) | rs1a],
     rs2@[RuleScope(labels2, tbl2) | rs2a]) -> rs1
    where
      ior(<merge-rs> (rs1, tbl1, rs2, tbl2), <merge-rec> (rs1a, rs2a))

  dr-merge-rule-sets2(merge-cs, merge-rec) :
    (rs1@[cs1@ChangeSet(labels1, rmset1, tbl1@Hashtable(csid1)) | rs1a],
     rs2@[cs2@ChangeSet(labels2, rmset2, tbl2@Hashtable(csid2)) | rs2a]) -> [cs | rs1a]
    where

      ((<DR_BREAK>IgnoreB(csid1) <+ <DR_BREAK>IgnoreC(csid1) <+ <DR_EXCEPTION>IgnoreT(csid1)) < !"ignore" + !"") => slabel1
      ; ((<DR_BREAK>IgnoreB(csid2) <+ <DR_BREAK>IgnoreC(csid2) <+ <DR_EXCEPTION>IgnoreT(csid2)) < !"ignore" + !"") => slabel2

      // if one branch had a break and one had a continue,
      // we need to propagate the effect of continue (the
      // "milder" of the two) in terms of marking the change
      // set as ignored
      ; try(
          <DR_BREAK>IgnoreB(csid1) => lb1
          ; <DR_BREAK>IgnoreC(csid2) => lc2
          ; rules(DR_BREAK.lb1 :- IgnoreB(csid1))
          ; dr-define-ignoreC(|csid1, lc2)
        )
      ; try(
          <DR_BREAK>IgnoreB(csid2) => lb2
          ; <DR_BREAK>IgnoreC(csid1) => lc1
          ; rules(DR_BREAK.lb2 :- IgnoreB(csid2))
          ; dr-define-ignoreC(|csid2, lc1)
        )

      ; (// "ignore" & "ignore" have to be merged, with the "ignore" system label kept
         // "" & "" is the normal merge
         <eq>(slabel1, slabel2)
         < (ior(<merge-cs> (rs1, rmset1, tbl1, rs2, rmset2, tbl2), <merge-rec> (rs1a, rs2a))
            ; !cs1 => cs
            ; try(
                <DR_EXCEPTION>IgnoreT(csid2)
                ; dr-define-ignoreT(|csid1)
              )
            ; try(
                <DR_BREAK>IgnoreB(csid2) => lb
                ; dr-define-ignoreB(|csid1, lb)
              )
            ; try(
                <DR_BREAK>IgnoreC(csid2) => lc
                ; dr-define-ignoreC(|csid1, lc)
              )
           )
         + (<eq>(rs1a, rs2a)
            < (<eq>(slabel1, "ignore") // slabel1 = "ignore" & slabel2 != "ignore", so we ignore cs1
               ; !cs2
               <+ <eq>(slabel2, "ignore") // slabel1 != "ignore" & slabel2 = "ignore", so we ignore cs2
                  ; !cs1)
              => cs
            + fatal-err(|"Merging of rulesets cannot continue because the non-ingnored change set is based on a different ruleset than the ignored change set."))
        )

  /**
   * Fixes references in change set that point to rule scopes that will
   * no longer be part of the merged ruleset. It is assumed that the references
   * that point to rule scopes in rsbad have to be replaced with references to
   * the corresponding (according to position) rule scopes in rsgood.
   *
   * No longer used.
   */
  dr-fix-change-set =
    ?(cs@ChangeSet(_, rmset, tbl), rsgood, rsbad)
    ; <filter(?RuleScope(_, Hashtable(<id>)))>rsgood => scpidsgood_
    ; <filter(?RuleScope(_, Hashtable(<id>)))>rsgood => scpidsbad_
    ; try(
        // only do this if it is indeed the case
        <not(eq)>(scpidsgood_, scpidsbad_)
        ; try(
            // sanity check
            <not(eq)>(<length>scpidsgood_, <length>scpidsbad_)
            ; fatal-err(|"Expected structurally matching rule sets!")
          )

        // some part of the rule sets might still be equal. Eliminate that
        // part from both lists to avoid needless fixing
        ; <eliminate-common-suffix>(scpidsgood_, scpidsbad_) => (scpidsgood, scpidsbad)

        ; <iset-elements>rmset
        ; map({key, scpid, k, idx :
            ?key@(scpid, k)
            ; try(
                <get-index>(scpid, scpidsbad) => idx
                ; <iset-remove(|key)>rmset
                ; <iset-add(|(<index>(idx, scpidsgood), k))>rmset
              )
          })
        ; <hashtable-keys>tbl
        ; map({key, scpid, k, idx, val :
            ?key@(scpid, k)
            ; try(
                <get-index>(scpid, scpidsbad) => idx
                ; <hashtable-get(|key)>tbl => val
                ; <hashtable-remove(|key)>tbl
                ; <hashtable-put(|(<index>(idx, scpidsgood), k), val)>tbl
              )
          })
      )
    ; !cs

  /**
   * Intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope
   * note that labels are ignored
   *
   * @todo: intersect labelsets as well!!??
   */

  dr-intersect-rule-sets =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-intersect-wempty(|tbl2, [])> tbl1}
      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <iset-union(|rmset2)> rmset1
         ; <hashtable-intersect-wempty(|tbl2, [])> tbl1}
    )

  apply-rm-set(|rmset) = ?tbl
    ; where(
        <iset-elements> rmset
        ; map({x: ?x; <hashtable-remove(|x)> tbl})
      )

  /**
   * Symmetric intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope
   * note that labels are ignored
   *
   * @todo: intersect labelsets as well!!
   */

  dr-intersect-rule-sets-symm =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-intersect-symm-wempty(|[])> (tbl1, tbl2)}
      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <apply-rm-set(|rmset1)> tbl2
         ; <iset-union(|rmset2)> rmset1
         ; <iset-union(|rmset1)> rmset2
         ; <hashtable-intersect-symm-wempty-ignore-left(|[])> (tbl1, tbl2)}
    )

  /**
   * Union of two rule-sets
   *
   * assumption: the scope structure of the two rule-sets is the same
   * and union works scope by scope
   *
   */

  dr-union-rule-sets =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-union(|tbl2)> tbl1}

      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <iset-union(|rmset2)> rmset1
         ; <hashtable-merge(
             symmetric-no,
             iterate1-yes,
             iterate2-yes,
             remove-no,
             union,
             ![],
             \ (scpid,key) -> <dr-lookup-rule-in-scope(|key, scpid)> rs1\,
             \ (scpid,key) -> <dr-lookup-rule-in-scope(|key, scpid)> rs2\
           )> (tbl1, tbl2)}
    )

  dr-union-rule-sets-symm =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-union-symm-wempty(|[])> (tbl1, tbl2)}

      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <apply-rm-set(|rmset1)> tbl2
         ; <iset-union(|rmset2)> rmset1
         ; <iset-union(|rmset1)> rmset2

         ; <hashtable-merge(
             symmetric-yes,
             iterate1-yes,
             iterate2-yes,
             remove-no,
             union,
             ![],
             change1-no,
             change2-yes,
             \ (scpid,key) -> <dr-lookup-rule-in-scope(|key, scpid)> rs1 \,
             \ (scpid,key) -> <dr-lookup-rule-in-scope(|key, scpid)> rs2 \
           )> (tbl1, tbl2)}
    )

strategies // generic fork-and-merge strategies

  fork-rule-sets :
    rulename -> (rulename, rs)
    where dr-get-rule-set(|rulename)
        ; dr-start-change-set => rs
        ; dr-start-change-set(|rulename)

  merge-rule-sets(merge) =
    ?(rulename, <id>)
    ; try(<merge>(rulename, <id>))
    ; dr-commit-change-set(|rulename)

  /**
   * Fork and merge two rule-sets.
   *
   * @param merge :
   */

  dr-fork-and-merge(merge, s1, s2 | rulenames) =
    where(<map(fork-rule-sets)> rulenames => rs1)
    ; restore(s1, where(<map(dr-discard-change-set(|<id>))> rulenames))
    ; where(<map({(?rulename,dr-switch-rule-set(|rulename))})> rs1 => rs2)
    ; restore(s2, where(<map(dr-discard-change-set(|<id>))> rulenames))
    ; where(<map(merge-rule-sets(merge))> rs2)

  dr-fork-and-merge(merge1, merge2, s1, s2 | rulenames1, rulenames2) =
    where(
      <map(fork-rule-sets)> rulenames1 => rs1a;
      <map(fork-rule-sets)> rulenames2 => rs1b
    )
    ; restore(
        s1,
        where(
          <map(dr-discard-change-set(|<id>))> rulenames1;
          <map(dr-discard-change-set(|<id>))> rulenames2
        )
      )
    ; where(
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1a => rs2a;
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1b => rs2b
      )
    ; restore(
        s2,
        where(
          <map(dr-discard-change-set(|<id>))> rulenames1;
          <map(dr-discard-change-set(|<id>))> rulenames2
        )
      )
    ; where(
        <map(merge-rule-sets(merge1))> rs2a;
        <map(merge-rule-sets(merge2))> rs2b
      )

strategies // generic fix-point strategies

  /**
   * Iterate and merge two rule-sets.
   *
   * @param merge :
   */

/*
 * the old implementation (for reference)
 *

  dr-fix-and-merge-no-break(merge, s | rulenames) =
    where(<map(fork-rule-sets)> rulenames => rs)
    ; repeat(
        where(
          restore(s, where(<map(dr-discard-change-set(|<id>))> rulenames))
          ; if <filter({?(rulename,<id>); <merge>(rulename, <id>)})> rs; []
            then
              ?e; fail // no changes in any of the rules
            else
              id       // some rule changed; continue
            end
        )
      )
    ; !e
    ; where(<map(dr-commit-change-set(|<id>))> rulenames)
*/

  dr-fix-and-merge(merge, s | rulenames) =
    dr-fix-and-merge(merge, s | rulenames, "")

  dr-fix-and-merge(merge, s | rulenames, label) =
    dr-label(merge, dr-fix-and-merge-internal(merge, s | rulenames) | rulenames, label)

  // notes:
  //  - keep just the last cs's from dr-break
  dr-fix-and-merge-internal(merge, s | rulenames) =
    where(<map(fork-rule-sets)> rulenames => rs)
    ; where(
        prim("SSL_hashtable_get", <dr-rule-sets-hashtable>, "DR_EXCEPTION")
        ; [RuleScope(iset-elements, hashtable-getlist)] => [RuleScope(labels, tbl)]
        ; !0  => exRS
        <+ !1 => exRS
      )
    ; repeat(
        where(
          restore(s, where(<map(dr-discard-change-set(|<id>))> rulenames))
          ; if <filter({rulename, ruleset, csid:
                 ?(rulename, ruleset)
                 // getting a change set marked as ignored here means that the
                 // loop _always_ ends with a break, so we might as well not have
                 // had a loop at all, since it will only be executed once
                 ; where(dr-get-rule-set(|rulename) => [ChangeSet(_, _, Hashtable(csid)) | _])
                 ; if <DR_BREAK>IgnoreB(csid)
                   then
                     <merge>(rulename, ruleset)
                     ; fail
                   else
                     <dr-merge-continue-change-sets(merge | <DR_BREAK>Label(rulename))>rulename
                     ; <merge>(rulename, ruleset)
                   end
               })> rs; []
            then
              ?e; fail // no changes in any of the rule sets
            else
              // further down below, we need to be able to extract the elements
              // in the list returned by bagof-DR_BREAK which were defined during
              // the first run (from above) of the strategy s and the ones in the
              // last run. For this, we need to make sure there will be some
              // separators in that list which we can use to get what we need.
              // The separator will be (), and here is the point where we add it
              where(<map({rulename, label:
                      ?rulename
                      ; <DR_BREAK>Label(rulename) => label
                      ; rules(DR_BREAK :+ BreakCS(rulename, label) -> ())
                    })>rulenames)
              ; where(try(
                  <eq>(exRS, 0)
                  ; dr-new-rule-set
                  ; [RuleScope(iset-addlist(|labels), hashtable-putlist(|tbl))]
                  ; dr-set-rule-set(|"DR_EXCEPTION")
                ))
              ; id     // some rule changed; continue
            end
        )
      )

    // we only want to use those elements from bagof-DR_BREAK that are from
    // the first and the last run of strategy s in the repeat from above.
    // For that, we used () as a separator (see comment above). Here we make
    // sure that when bagof-DR_BREAK is called in dr-label, only the proper
    // change sets are returned for merging
    ; <map({rulename, label:
        ?rulename
        ; <DR_BREAK>Label(rulename) => label
        ; (<bagof-DR_BREAK>BreakCS(rulename, label) <+ ![])
        ; list-tokenize(|[()])
        ; first-last
        ; concat
        ; where(rules(DR_BREAK :- BreakCS(rulename, label)))
        ; reverse-map({val: ?val; rules(DR_BREAK :+ BreakCS(rulename, label) -> val)})
      })>rulenames

    ; !e
    ; where(<map(dr-commit-change-set(|<id>))> rulenames)

  dr-fix-and-merge(merge1, merge2, s | rulenames1, rulenames2) =
    where(<map(fork-rule-sets)> rulenames1 => rs1;
          <map(fork-rule-sets)> rulenames2 => rs2)
    ; repeat(
        where(
          restore(
            s,
            where(
              <map(dr-discard-change-set(|<id>))> rulenames1;
              <map(dr-discard-change-set(|<id>))> rulenames2
            )
          )
          ; if and(<filter({?(rulename,<id>); <merge1>(rulename, <id>)})> rs1; []
                  ,<filter({?(rulename,<id>); <merge2>(rulename, <id>)})> rs2; [])
            then
              ?e; fail // no changes in any of the rules
            end
        )
      )
    ; !e
    ; where(<map(dr-commit-change-set(|<id>))> rulenames1
           ;<map(dr-commit-change-set(|<id>))> rulenames2)

  dr-merge-continue-change-sets(merge | label) =
    ?rulename
    ; dr-get-rule-set(|rulename) => [ChangeSet(_, _, Hashtable(csid)) | rs]
    ; (<bagof-DR_BREAK>ContinueCS(rulename, label) <+ ![])
    ; where(rules(DR_BREAK :- ContinueCS(rulename, label)))
    ; if not(?[]); <DR_BREAK>IgnoreC(csid)
      then
        // discard and replace the current change set with the first
        // one from the list returned by bagof-DR_BREAK (it could have
        // been any other element of that list just as well)
        where(dr-discard-change-set(|rulename))
        ; [![<id> | rs]; dr-set-rule-set(|rulename) | id]; Tl
      else id
      end

    // merge all the change sets (prepended to the common part of the ruleset)
    ; map(![<id> | rs]; try(<merge>(rulename, <id>)))

strategies // labeling statements, break, continue

  /**
   * @todo destroy the change sets introduced by calls to dr-break
   */
  dr-label(merge, s | rulenames, label) =
    {| DR_BREAK :

      // register <label> as the active label
      rules(DR_BREAK+label)
      ; where(<map({rulename:
                ?rulename
                ; rules(DR_BREAK : Label(rulename) -> label)
              })>rulenames)

      // for each rule r in <rulenames> define a dynamic rule which
      // marks the position of the change set created below in the
      // ruleset of r
      ; where(
          <map({rulename, pos:
                ?rulename
                ; dr-get-rule-set(|rulename)
                ; length => pos
                ; rules(DR_BREAK : SplitPos(rulename, label) -> pos)
              })>rulenames
        )

      // we need a change set to collect all the changes
      // to the rule set which are created on control flow
      // paths that do not end with a call to dr-break or
      // dr-continue
      ; where(<map(dr-start-change-set(|<id>))>rulenames)

      // run the strategy and save the result
      ; restore(s, where(<map(dr-discard-change-set(|<id>))>rulenames))
      ; ?e

      // for each rule r in <rulenames> we essentially want to merge the current
      // ruleset for rule r with the change sets for r and the current <label>
      // returned by bagof-DR_BREAK (prepended to the common part of the ruleset)
      ; <map({rulename, rs, csid, csidnew, cslbl:
          ?rulename
          ; dr-get-rule-set(|rulename) => [ChangeSet(_, _, Hashtable(csid)) | rs]
          ; (<bagof-DR_BREAK>BreakCS(rulename, label) <+ ![])
          ; if not(?[]); <DR_BREAK>IgnoreB(csid)
            then
              // discard replace the current change set with the first one from the list
              // returned by bagof-DR_BREAK (it could have been any other element of that
              // list just as well)
              where(dr-discard-change-set(|rulename))
              ; [![<id> | rs]; dr-set-rule-set(|rulename) | id]; Tl
            else id
            end

          // merge all the change sets (prepended to the common part of the ruleset)
          ; map(![<id> | rs]; try(<merge>(rulename, <id>)))

          // commit the change sets created above
          ; dr-commit-change-set(|rulename)
        })>rulenames

      ; !e
    |}

  dr-break(|rulename) =
    dr-break(|rulename, <DR_BREAK>Label(rulename))

  dr-break(|rulename, label) =
    where(
      dr-get-rule-set(|rulename) => rs

      // split the ruleset in two parts: the one before the
      // labeled statement and the one after it
      ; back-split-at(|<DR_BREAK>SplitPos(rulename, label))

      // build the change set with all the changes from
      // the first part of the pair generated above...
      ; dr-build-aggregated-change-set => bcs

      // ... and add it to the rule which collects all
      // the change sets pertaining to control flow paths
      // that lead to a break
      ; rules(DR_BREAK.label :+ BreakCS(rulename, label) -> bcs)

      // go back to the active ruleset and mark the innermost change set as ignored
      ; !rs
      ; fetch(ChangeSet(id, id, ?Hashtable(csid)))
//      ; rules(DR_BREAK.label : IgnoreB(csid) -> label)
      ; dr-define-ignoreB(|csid, label)
    )

/**
  * This implementation of the strategy doesn't work.
  * (left here for reference purposes only)
  *
  * Reason: replacing a number of change sets & rule scopes with
  *         their clones introduces inconsistency issues during merging
  *         that are way too difficult to solve.
  *

  dr-break-bp(|rulename) =
    where(
      <DR_BREAK>Label(rulename) => label
      ; dr-get-rule-set(|rulename)
      ; back-split-at(|<DR_BREAK>SplitPos(rulename, label))
      ; ?(inRs, outRs)
      ; <map({scope, lbls :
          (?ChangeSet(_, _, _); dr-new-change-set)
          <+ \ RuleScope(labels, table) -> scope
                 where dr-new-scope => scope@RuleScope(lbls, tbl)
                       ; <iset-addlist(|<iset-elements>labels)>lbls
                       ; <hashtable-keys>table
                       ; map({key, val :
                           ?key
                           ; <hashtable-get(|key)>table => val
                           ; <hashtable-put(|key, val)>tbl
                         }) \
        })>inRs
      ; <conc>(<id>, outRs)
      ; dr-set-rule-set(|rulename)
    )

*/

  // dr-break version for backward propagation transformations
  dr-break-bp(|rulename) =
    where(
      <DR_BREAK>Label(rulename) => label
      ; dr-get-rule-set(|rulename)
      ; back-split-at(|<DR_BREAK>SplitPos(rulename, label))

      // here we make the assumption that we always have a
      // change set as the first element in the rule set,
      // which comes from the assumption that the user always
      // uses dr-transaction with rule scopes in backward
      // propagation transformations
      ; ?([ChangeSet(_, rmset, tbl) | inRs], outRs)
      ; <iset-clear>rmset
      ; <hashtable-clear>tbl
      ; <reverse>inRs
      ; dr-build-bp-change-set(|rmset, tbl, outRs)
    )

  dr-build-bp-change-set(|rmset, tbl, ruleset) =
    [?rs@RuleScope(_, _) | dr-build-bp-change-set(|rmset, tbl, [rs | ruleset])]
    <+ []

  dr-build-bp-change-set(|rmset, tbl, ruleset) =
    ?[ChangeSet(_, rmset1, tbl1) | rest]
    ; <iset-elements>rmset1
    ; map({scpid, key, value :
        ?(scpid, key)
        ; try(
            <dr-lookup-rule-in-scope(|key, scpid)>ruleset => value
            ; <hashtable-put(|(scpid, key), value)>tbl
          )
      })
    ; <hashtable-keys>tbl1
    ; map({scpid, key, value :
        ?(scpid, key)
        ; (<dr-lookup-rule-in-scope(|key, scpid)>ruleset => value
           < <hashtable-put(|(scpid, key), value)>tbl
           + <iset-add(|(scpid, key))>rmset)
      })
    ; <dr-build-bp-change-set(|rmset, tbl, ruleset)>rest

  dr-continue(|rulename) =
    dr-continue(|rulename, <DR_BREAK>Label(rulename))

  dr-continue(|rulename, label) =
    where(
      dr-get-rule-set(|rulename) => rs

      // split the ruleset in two parts: the one before the
      // labeled statement and the one after it
      ; back-split-at(|<DR_BREAK>SplitPos(rulename, label))

      // build the change set with all the changes from
      // the first part of the pair generated above...
      ; dr-build-aggregated-change-set => ccs

      // ... and add it to the rule which collects all
      // the change sets pertaining to control flow paths
      // that lead to a continue
      ; rules(DR_BREAK.label :+ ContinueCS(rulename, label) -> ccs)

      // go back to the active ruleset and mark the innermost change set as ignored
      ; !rs
      ; fetch(ChangeSet(id, id, ?Hashtable(csid)))
      ; dr-define-ignoreC(|csid, label)
    )

  /**
   * This strategy takes a pair of lists of change sets and rule scopes
   * and returns a change set which contains all the changes from the
   * change sets in the left member of the input pair which refer to
   * rule scopes in the right member of the input pair.
   */
  dr-build-aggregated-change-set =

    // create the extra change set
    (?sourceRs, dr-start-change-set => rs@[aggCs@ChangeSet(_, rmset, tbl) | _])

    // commit all change sets in sourceRs to the extra change set
    ; <reverse-map(
        ![<id> | rs]
        ; try(dr-commit-change-set(fail))
      )>sourceRs

    // collect all the scope ids of the rule scopes in sourceRs
    ; <filter(?RuleScope(_, Hashtable(<id>)))>sourceRs => scpids

    // remove all the elements from rmset that refer to rule scopes
    // whose scope id is part of scpids
    ; <iset-elements>rmset
    ; map({k, scpid :
        ?k@(scpid, _)
        ; try(<fetch-elem(?scpid)>scpids; <iset-remove(|k)>rmset)
      })

    // remove all the elements from tbl that refer to rule scopes
    // whose scope id is part of scpids
    ; <hashtable-keys>tbl
    ; map({k, scpid :
        ?k@(scpid, _)
        ; try(<fetch-elem(?scpid)>scpids; <hashtable-remove(|k)>tbl)
      })

    // return the built change set
    ; !aggCs

strategies // exception handling strategies

  dr-init-exception-block(has-finally | catch-tags, rulenames) =
    where(<map({rulename, tb :
      ?rulename
      ; !TryBlock(
          <dr-get-rule-set(|rulename); length>
          , <new>
          , <map(!Catch(<new>, <id>))>catch-tags
          , <has-finally < !Finally(<new>) + !Finally("")>) => tb
      ; rules(DR_EXCEPTION :+ Structure(rulename) -> tb)
      ; dr-start-change-set(|rulename)
    })>rulenames)

  dr-throw(eq-test | tag, rulename) =
    where(
      get-matching-id(eq-test | tag, rulename) => (pos, ID, catchID)
      ; dr-get-rule-set(|rulename) => rs
      ; back-split-at(|pos)
      ; dr-build-aggregated-change-set => tcs
      ; rules(DR_EXCEPTION :+ ThrowCS(rulename, ID) -> (tcs, catchID))
      ; <fetch(ChangeSet(id, id, ?Hashtable(csid)))>rs
      ; dr-define-ignoreT(|csid)
    )

  get-matching-id(eq-test | tag, rulename) =
    (<bagof-DR_EXCEPTION>Structure(rulename) <+ ![])
    ; where(
        fetch-elem({pos, catches :
          ?TryBlock(pos, _, catches, _)
          ; <fetch-elem({cID, ctag : ?Catch(cID, ctag); <eq-test>(tag, ctag); !cID})>catches
        }) => catchID
        <+ fatal-err(|"dr-throw: Thrown exception does not match any catch clause")
      )
    ; fetch-elem({pos, catches, fID :
        ?TryBlock(pos, _, catches, Finally(fID))
        ; (<fetch-elem({cID, ctag : ?Catch(cID, ctag); <eq-test>(tag, ctag); !cID})>catches
           <+ <not(eq)>(fID, ""); !fID)
        ; !(pos, <id>, catchID)
      })

  get-matching-id(|catchID, rulename) =
    (<bagof-DR_EXCEPTION>Structure(rulename) <+ ![])
    ; fetch-elem({pos, catches, fID :
        ?TryBlock(pos, _, catches, Finally(fID))
        ; (<fetch-elem(?Catch(catchID, _); !catchID)>catches
           <+ <not(eq)>(fID, ""); !fID)
        ; !(pos, <id>)
      })
      <+ fatal-err(|"dr-complete-finally: Could not forward exception due to missing catch clause")

  dr-complete-catch(merge, s | rulenames) =
    ?term

    ; <map({rulename, cID, cs, rs, hd, tl :
        ?rulename
        ; (<DR_EXCEPTION>Structure(rulename) => TryBlock(_, _, [Catch(cID, _) | _], _)
           <+ fatal-err(|"dr-complete-catch was called when no catch clause was active or when a finished exception block was not completed"))
        ; (dr-get-rule-set(|rulename) => [cs@ChangeSet(_, _, _) | rs]
           <+ fatal-err(|"dr-complete-catch was not called in a proper exception handling context"))
        ; <bagof-DR_EXCEPTION>ThrowCS(rulename, cID)
        ; if ?[(hd, _) | tl] then
            <dr-set-rule-set(|rulename)>[<dr-clone-change-set>hd | rs]
            ; <map(![<?(<id>, _)> | rs]; try(<merge>(rulename, <id>)))>tl
          else
            <dr-set-rule-set(|rulename)>[<dr-clone-change-set>cs | rs]
          end
        ; !cs
      })>rulenames => css

    ; restore(<s>term => e,
        <zip>(css, rulenames)
        ; map({cs, rulename, rs :
            ?(cs, rulename)
            ; dr-get-rule-set(|rulename)
            ; [dr-destroy-change-set | ?rs]
            ; ![cs | rs]
            ; dr-set-rule-set(|rulename)
          })
      )

    ; <zip>(css, rulenames)
    ; map({cs, rulename, pos, ID, cID, catches, fin, fID, cs', rs :
        ?(cs, rulename)
        ; (<once-DR_EXCEPTION>Structure(rulename) => TryBlock(pos, ID, [Catch(cID, _) | catches], fin@Finally(fID))
           <+ fatal-err(|"dr-complete-catch: Unexpected failure here!"))
        ; rules(DR_EXCEPTION :+ Structure(rulename) -> TryBlock(pos, ID, catches, fin))
        ; rules(DR_EXCEPTION :- ThrowCS(rulename, cID))
        ; (dr-get-rule-set(|rulename) => [cs'@ChangeSet(_, _, _) | rs]
           <+ fatal-err(|"dr-complete-catch: A change set was expected here!"))
        ; (<eq>(fID, "")
           < rules(DR_EXCEPTION :+ ExceptionCS(rulename, ID) -> cs')
           + rules(DR_EXCEPTION :+ ExceptionCS(rulename, fID) -> cs'))
        ; ![cs | rs]
        ; dr-set-rule-set(|rulename)
      })

    ; !e

  dr-complete-finally(merge, s | rulenames) =
    ?term

    ; <map({rulename, tb, fID, cs, csid, rs, tcss, hd, tl :
        ?rulename
        ; (<once-DR_EXCEPTION>Structure(rulename) => tb@TryBlock(_, _, [], Finally(fID))
           <+ fatal-err(|"dr-complete-finally was called when a catch clause was still active"))
        ; try(<eq>(fID, ""); fatal-err(|"dr-complete-finally was called when a finally clause was not active"))
        ; (dr-get-rule-set(|rulename) => [cs@ChangeSet(_, _, Hashtable(csid)) | rs]
           <+ fatal-err(|"dr-complete-finally was not called in a proper exception handling context"))
        ; (<bagof-DR_EXCEPTION>ThrowCS(rulename, fID) <+ ![]) => tcss
        ; (<bagof-DR_EXCEPTION>ExceptionCS(rulename, fID) <+ ![])
        ; <conc>(<id>, <map(?(<id>, _))>tcss)
        ; if ?[hd | tl]; <DR_EXCEPTION>IgnoreT(csid) then
            dr-discard-change-set(|rulename)
            ; <dr-set-rule-set(|rulename)>[<dr-clone-change-set>hd | rs]
            ; <map(try(<merge>(rulename, <![<id> | rs]>)))>tl
          else
            where(<dr-set-rule-set(|rulename)>[<dr-clone-change-set>cs | rs])
            ; map(try(<merge>(rulename, <![<id> | rs]>)))
          end
        ; !(tb, cs, rulename)
      })>rulenames => temp

    ; restore(<s>term => e,
        <map({tb, cs, rulename, rs :
          ?(tb, cs, rulename)
          ; dr-get-rule-set(|rulename)
          ; [dr-destroy-change-set | ?rs]
          ; ![cs | rs]
          ; dr-set-rule-set(|rulename)
          ; rules(DR_EXCEPTION :+ Structure(rulename) -> tb)
        })>temp
      )

    ; <map({rulename, pos, ID, fID, csid, rs :
        ?(TryBlock(pos, ID, [], Finally(fID)), _, rulename)
        ; rules(DR_EXCEPTION :+ Structure(rulename) -> TryBlock(pos, ID, [], Finally("")))
        ; rules(DR_EXCEPTION :- ExceptionCS(rulename, fID))
        ; (dr-get-rule-set(|rulename) => rs@[ChangeSet(_, _, Hashtable(csid)) | _]
           <+ fatal-err(|"dr-complete-finally: A change set was expected here!"))
        ; try(
            <not(DR_EXCEPTION)>IgnoreT(csid)
            ; (<bagof-DR_EXCEPTION>ThrowCS(rulename, fID) <+ ![])
            ; map(?(_, <id>))
            ; make-set
            ; map({catchID, pos, nextID, tcs :
                ?catchID
                ; get-matching-id(|catchID, rulename) => (pos, nextID)
                ; <back-split-at(|pos)>rs
                ; dr-build-aggregated-change-set => tcs
                ; rules(DR_EXCEPTION :+ ThrowCS(rulename, nextID) -> (tcs, catchID))
              })
          )
        ; rules(DR_EXCEPTION :- ThrowCS(rulename, fID))
      })>temp

    ; !e

  dr-complete-exception-block(merge | rulenames) =
    where(
      <map({rulename, ID, csid, rs, hd, tl :
        ?rulename
        ; (<once-DR_EXCEPTION>Structure(rulename) => TryBlock(_, ID, [], Finally(""))
           <+ fatal-err(|"dr-complete-exception-block was called before completing all catch clauses (and the finally clause) or in a non-proper exception handling context"))
        ; (dr-get-rule-set(|rulename) => [ChangeSet(_, _, Hashtable(csid)) | rs]
           <+ fatal-err(|"dr-complete-exception-block was not called in a proper exception handling context"))
        ; (<bagof-DR_EXCEPTION>ExceptionCS(rulename, ID) <+ ![])
        ; if ?[hd | tl]; <DR_EXCEPTION>IgnoreT(csid) then
            dr-discard-change-set(|rulename)
            ; <dr-set-rule-set(|rulename)>[<dr-clone-change-set>hd | rs]
            ; <map(![<id> | rs]; try(<merge>(rulename, <id>)))>tl
          else
            map(![<id> | rs]; try(<merge>(rulename, <id>)))
          end
        ; rules(DR_EXCEPTION :- ExceptionCS(rulename, ID))
        ; dr-commit-change-set(|rulename)
      })>rulenames
    )

strategies // transactional run of a strategy

  dr-transaction(s | rulenames) =
    where(<map(dr-start-change-set(|<id>))>rulenames)
    ; restore(s, where(<map(dr-discard-change-set(|<id>))>rulenames))
    ; where(<map(dr-commit-change-set(|<id>))>rulenames)

strategies // fork with intersection and union

  /**
   * two-way split in data-flow (if-then-else) for list of rules
   */

  /**
   * Fork and intersection of two rule-sets
   */
  dr-fork-and-intersect(s1, s2 | rulenames) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                     , s1, s2 | rulenames)

  /**
   * Fork and union of two rule-sets
   */
  dr-fork-and-union(s1, s2 | rulenames) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                     , s1, s2 | rulenames)

  /**
   * Fork and combined union and intersection of two rule-sets
   */
  dr-fork-and-intersect-union(s1, s2 | rulenames1, rulenames2) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                     ,\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                     , s1, s2 | rulenames1, rulenames2)

strategies // fix-point with intersection and union

  /**
   * loop in data-flow (while)
   */

  /**
   * Iterate intersection of two rule-sets
   */
  dr-fix-and-intersect(s | rulenames) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
                    , s | rulenames)

  dr-fix-and-intersect(s | rulenames, label) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
                    , s | rulenames, label)

  /**
   * Iterate union of two rule-sets
   */
  dr-fix-and-union(s | rulenames) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
                    , s | rulenames)

  dr-fix-and-union(s | rulenames, label) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
                    , s | rulenames, label)

  /**
   * Iterate combined union and intersection of two rule-sets
   */
  dr-fix-and-intersect-union(s | rulenames1, rulenames2) =
    dr-fix-and-merge( \ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
                    , \ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
                    , s | rulenames1, rulenames2)

strategies // label statements with intersection and union

  /**
   * labeled _non-iterative_ statement in data-flow
   */

  /**
   * Label current point in data-flow with <label> to accommodate
   * break's. Intersection of rule-sets after running <s>:
   *   - the "main" rule-set resulted by running <s>
   *   - all the rule-sets generated by calls to dr-break
   *     with the same label as this one
   *
   * !! Only use this to label non-iterative statements. !!
   * !! Use dr-fix-and-intersect which takes a label     !!
   * !! argument to label iterative statements.          !!
   */
  dr-label-intersect(s | rulenames, label) =
    dr-label(\ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
            , s | rulenames, label)

  /**
   * Label current point in data-flow with <label> to accommodate
   * break's. Union of rule-sets after running <s>:
   *   - the "main" rule-set resulted by running <s>
   *   - all the rule-sets generated by calls to dr-break
   *     with the same label as this one
   *
   * !! Only use this to label non-iterative statements. !!
   * !! Use dr-fix-and-union which takes a label         !!
   * !! argument to label iterative statements.          !!
   */
  dr-label-union(s | rulenames, label) =
    dr-label(\ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
            , s | rulenames, label)

strategies // exceptions

  dr-complete-catch-intersect(s | rulenames) =
    dr-complete-catch(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                     , s | rulenames)

  dr-complete-finally-intersect(s | rulenames) =
    dr-complete-finally(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                       , s | rulenames)

  dr-complete-exception-block-intersect(|rulenames) =
    dr-complete-exception-block(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                               | rulenames)



  dr-complete-catch-union(s | rulenames) =
    dr-complete-catch(\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                     , s | rulenames)

  dr-complete-finally-union(s | rulenames) =
    dr-complete-finally(\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                       , s | rulenames)

  dr-complete-exception-block-union(|rulenames) =
    dr-complete-exception-block(\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                               | rulenames)

strategies // n-way split

  /**
   * n-way split in data-flow (case)
   *
   * @todo : generalize to factor out table merge operation
   */

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames) =
    if empty then id
    else
      where(<map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs0)
      ; dr-fold-and-intersect(empty, hd, tl | rulenames, rs0)
      ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    end

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames, rs0) =
    if empty then id
    else
      where(
        <map({?(rulename,<id>)
              ; dr-start-change-set
              ; dr-set-rule-set(|rulename)})> rs0
      )
      ; hd
      ; where(
          <map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs1
        )
      ; tl(dr-fold-and-intersect(empty, hd, tl | rulenames, rs0))
      ; where(
          <map({?(rulename, <id>); dr-intersect-with(|rulename)})> rs1
        )
    end

  /**
   * fork and intersect over a list
   *
   * @todo : generalize to factor out table merge operation
   */

  dr-map-and-intersect(s | rulenames) =
    let tl(s') = [id | s']
     in dr-fold-and-intersect([], [s|id], tl | rulenames)
    end

strategies // workaround for overlapping lhhs in dynamic rule

  dr-define-ignoreB(|csid, label) =
    rules(DR_BREAK.label : IgnoreB(csid) -> label)

  dr-define-ignoreC(|csid, label) =
    rules(DR_BREAK.label : IgnoreC(csid) -> label)

  dr-define-ignoreT(|csid) =
    rules(DR_EXCEPTION : IgnoreT(csid))

strategies // rule-set equality

  dr-eq-rule-sets =
  let rseq =
        ?(RuleScope(lbl1, tbl1), RuleScope(lbl2, tbl2))
      ; <iset-eq(|lbl2)> lbl1
      ; <hashtable-eq> (tbl1, tbl2)
    +   ?(ChangeSet(lbl1, rmset1, tbl1), ChangeSet(lbl2, rmset2, tbl2))
      ; <iset-eq(|lbl2)> lbl1
      ; <iset-eq(|rmset2)> rmset1
      ; <hashtable-eq> (tbl1, tbl2)
   in where(zip(rseq))
  end

strategies // debugging

  dr-debug-rule-set(|name) = dr-debug-rule-set(|name, "")

  dr-debug-rule-set(|name, msg) =
    where(
        (!msg => "" <+ say(!msg))
      ; <debug(!"Ruleset for: ")> name
      ; dr-print-rule-set(|name)
    )

  dr-print-rule-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-print-rule-set
    )

  dr-print-rule-sets(|names) =
    where(
      <map(debug; dr-print-rule-set(|<id>))> names
    )

  dr-print-rule-set-msg(|msg) =
    where(!msg => "" <+ say(<concat-strings>["\n--- BEGIN(", msg,  ") ---"]))
    ; dr-print-rule-set
    ; where(!msg => "" <+ say(<concat-strings>["--- END  (", msg,  ") ---\n"]))

  dr-print-rule-set =
    where(map(dr-print-scope))

  dr-print-scope =
    ?RuleScope(labelset, tbl)
  ; where(
      debug
    ; <iset-elements; debug(!"labels: ")> labelset
    ; <hashtable-keys> tbl
          ; map(where(<fprintnl>(stderr(), ["  ", <id>, " -> " ]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; map(<fprintnl>(stderr(), ["    ", <id>]))
                 )
         )
    )

  dr-print-scope =
    ?ChangeSet(labelset, rmset, tbl@Hashtable(csid))
  ; where(
      debug
    ; <iset-elements; debug(!"labels: ")> labelset
    ; <iset-elements; debug(!"removed: ")> rmset
    ; <hashtable-keys> tbl
    ; map(where(<fprintnl>(stderr(), ["  ", <id>, " -> "]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; map(<fprintnl>(stderr(), ["    ", <id>]))
                 )
         )
    ; try(
        <DR_BREAK>IgnoreB(csid) => blabel
        ; <fprintnl>(stderr(), ["Change set is marked as ignored (due to break) up to label ", blabel, "."])
      )
    ; try(
        <DR_BREAK>IgnoreC(csid) => clabel
        ; <fprintnl>(stderr(), ["Change set is marked as ignored (due to continue) up to label ", clabel, "."])
      )
    )

strategies // friendlier debugging (numbers instead of ugly strings for hashtable ids)

  dr-friendly-debug-rule-set(|name) = dr-friendly-debug-rule-set(|name, "")

  dr-friendly-debug-rule-set(|name, msg) =
    where(
        (!msg => "" <+ say(!msg))
      ; <debug(!"Ruleset for: ")> name
      ; dr-friendly-print-rule-set(|name)
    )

  dr-friendly-print-rule-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-friendly-print-rule-set
    )

  dr-friendly-print-rule-sets(|names) =
    where(
      <map(debug; dr-friendly-print-rule-set(|<id>))> names
    )

  dr-friendly-print-rule-set-msg(|msg) =
    where(!msg => "" <+ say(<concat-strings>["\n--- BEGIN(", msg,  ") ---"]))
    ; dr-friendly-print-rule-set
    ; where(!msg => "" <+ say(<concat-strings>["--- END  (", msg,  ") ---\n"]))

  dr-friendly-print-rule-set =
    where({| DRFriendlyName, DR_Count :
      rules(
        DRCount : "rs" -> 0
        DRCount : "cs" -> 0
      )
      ; reverse-map({
             ?RuleScope(_, Hashtable(rsid))
             ; where(
                 <DRCount>"rs" => idxrs; <inc>idxrs => idxrs'
                 ; <concat-strings>["RuleScope(", <int-to-string>idxrs, ")"] => name
               )
             ; rules(
                 DRFriendlyName : rsid -> name
                 DRCount        : "rs" -> idxrs'
               )
          <+ ?ChangeSet(_, _, Hashtable(csid))
             ; where(
                 <DRCount>"cs" => idxcs; <inc>idxcs => idxcs'
                 ; <concat-strings>["ChangeSet(", <int-to-string>idxcs, ")"] => name
               )
             ; rules(
                 DRFriendlyName : csid -> name
                 DRCount        : "cs" -> idxcs'
               )
        })
        ; map(dr-friendly-print-scope)
    |})

  dr-friendly-print-rule-set-msg(|msg) =
    where(!msg => "" <+ say(<concat-strings>["\n--- BEGIN(", msg,  ") ---"]))
    ; dr-friendly-print-rule-set
    ; where(!msg => "" <+ say(<concat-strings>["--- END  (", msg,  ") ---\n"]))

  dr-friendly-print-scope =
    ?RuleScope(labelset, tbl@Hashtable(rsid))
    ; <DRFriendlyName>rsid
    ; where(
        debug
        ; <iset-elements; debug(!"labels: ")> labelset
        ; <hashtable-keys> tbl
        ; map(
            where(<fprintnl>(stderr(), ["  ", <id>, " -> " ]))
            ; where(
                \ key -> <hashtable-get(|key)> tbl \
                ; map(<fprintnl>(stderr(), ["    ", <id>]))
              )
          )
      )

  dr-friendly-print-scope =
    ?ChangeSet(labelset, rmset, tbl@Hashtable(csid))
    ; <DRFriendlyName>csid
    ; where(
        debug
        ; <iset-elements; debug(!"labels: ")> labelset
        ; <iset-elements; debug(!"removed: ")> rmset
        ; <hashtable-keys> tbl
        ; map(
            where((DRFriendlyName <+ id, id); <fprintnl>(stderr(), ["  ", <id>, " -> "]))
            ; where(
                \ key -> <hashtable-get(|key)> tbl \
                ; map(<fprintnl>(stderr(), ["    ", <id>]))
              )
          )
        ; try(
            <DR_BREAK>IgnoreB(csid) => blabel
            ; <fprintnl>(stderr(), ["Change set is marked as ignored (due to break) up to label ", blabel, "."])
          )
        ; try(
            <DR_BREAK>IgnoreC(csid) => clabel
            ; <fprintnl>(stderr(), ["Change set is marked as ignored (due to continue) up to label ", clabel, "."])
          )
      )

// lang/stacktrace
strategies

  /**
   * Return a list of all the current stack frame namess. A stack
   * frame name is the name of the rule or strategy on a given
   * stack frame. The list might not be complete; refer to the module
   * documentation for lang/stacktrace for details.
   *
   * @type -> List(String)
   */
  stacktrace-get-all-frame-names = prim("SSL_stacktrace_get_all_frame_names")

  /**
   * Return the name of the currently active stack frame. This
   * strategy returns the name of the strategy that calls
   * stacktrace-get-current-frame, with certain restrictions,
   * see the lang/stacktrace module documentation.
   *
   * @type -> String
   */
  stacktrace-get-current-frame-name = prim("SSL_stacktrace_get_current_frame_name")

  /**
   * Return the index (depth) of the current stack, including the call to this
   * strategy.
   *
   * @type -> Int
   */
  stacktrace-get-current-frame-index = prim("SSL_stacktrace_get_current_frame_index")

  print-stacktrace =
    where(
      prim("SSL_stacktrace_get_all_frame_names")
    ; try(?["print_stacktrace_0_0" | <id>])
    ; reverse
    ; list-loop(<fprintnl> (stderr(), ["\t", <id>]))
    )

// lang/strategy-reference
strategies

  /**
  * Capture a reference to a strategy as a term. The strategy s must be fully specified (i.e. all its arguments must be specified).
  *
  * @note The resulting reference term cannot be pretty-printed or matched against (at least not realiably). The reference
  * to the strategy is only valid within the instance of the interpreter which produced it
  *
  * @param a -?> b
  * @type _ -> ___StrategyRef___()
  */
  to-sref(s) = prim("SSL_EXT_to_sref", s|)

  /**
  * Apply the strategy referenced by the term. The referenced strategy is applied to the input term.
  *
  * @type a -> <t> a
  */
  apply-sref(|t) = prim("SSL_EXT_apply_sref",|t)

// lang/with
strategies

  /**
   * Evaluate a strategy s, or, if s fails, end with a fatal error.
   *
   * @note In future revisions, a facility may be provided to "catch"
   *       failures raised by with clauses and uses of this strategy.
   */
  with(s|message) =
    where(s <+ ?term; prim("SSL_stacktrace_get_all_frame_names"); report-failure(|message, term))

  /**
  * Evaluate strategy s1 and catch with-failures that get thrown.
  * If s1 throws a with-failure then s2 is called on the original input term
  * and a List(String) representation of the stack trace.
  * The following defines the behaviour of catch-with on input term t:
  *
  * <s1> t if success(s1) or fail(s1)
  * <s2> (message, t, trace) if withfail(s1)
  *
  * @param a -> b
  * @param (String, a, List(String)) -> c
  * @type a -> b | c
  */
  catch-with(s1, s2) = prim("SSL_EXT_catch_with", s1, s2|)

  /**
  * @internal
  */
  report-with-failure(|strategyname) =
    report-failure(|["Internal error: with clause failed unexpectedly in ", strategyname ], <id>)

// strategy/general/free-variables
strategies

  free-vars(getvars, boundvars) =
    rec x(getvars
          <+ split(crush(![],union,x), boundvars <+ ![]); diff)

  free-vars(getvars, boundvars
           , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term) =
    rec x(getvars
          <+ {vs: where(boundvars => vs);
                  boundin(split(x, !vs); diff, x, ![])};
             crush(![],union,id)
          <+ crush(![],union,x))

/* // if we had strategy abstraction /\(x1,...,xn) -> s

  free-vars(getvars, boundvars, boundin) =
    collect(getvars
           ,/\ (x,nil) ->
            {vs: where(boundvars => vs);
                 boundin(split(x, !vs); diff, x, nil)})
*/

  free-vars(getvars, boundvars
           , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term
           , eq)
  = rec x(getvars
          <+ {vs: where(boundvars => vs);
                  boundin(split(x, !vs); diff(eq), x, ![])};
             crush(![],union,id)
          <+ crush(![],union,x))

/*

  \paragraph{Variables are not Leafs}

  In a more complicated style of free variable extraction,
  variables are not leaves of abstract syntax trees, but can
  contain subterms that again contain variables.

*/
strategies

  free-vars2(getvars, boundvars) =
    rec x(split(getvars <+ ![],
          split(crush(![],union,x), boundvars <+ ![]); diff);
          union)

  free-vars2(getvars, boundvars
            , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term) =
    rec x(split(getvars <+ ![],
                ({vs: where(boundvars => vs);
                      boundin(split(x, !vs); diff, x, ![])};
                 crush(![],union,id)
                 <+ crush(![],union,x)));
          union)

  free-vars2(getvars, boundvars
            , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term
            , eq)
  = rec x(split(getvars <+ ![]
               ,{vs: where(boundvars => vs);
                     boundin(split(x, !vs); diff(eq), x, ![]);
                     crush(![],union,id)}
                <+ crush(![],union,x)
               ); union)

// strategy/general/memo
strategies

  memo-scope(s) = {| Memo: s |}

 /**
  * <memo(tbl, s)> t first looks up the term t in the memo table. If
  * present the association in the table is produced, else the result
  * of <s> t is computed and stored in the table.
  */
  memo(s) :
    t -> t'
    where ( <Memo> t => t' )
       <+ ( <s> t => t'; rules(Memo: t -> t') )

// strategy/general/option
signature
  sorts Option(a)
  constructors
    None : Option(a)
    Some : a -> Option(a)
strategies

  option(s) = None + Some(s)

// strategy/general/parenthesize
strategies

  parenthesize(paren, prios) =
    where(prios; init-parenthesation-rules)
    ; bottomup(try(Disambiguate(paren)))

  // assumes parenthesation rules are already generated

  parenthesize(paren) =
    bottomup(try(Disambiguate(paren)))

  Disambiguate(paren) :
    e@op#([l | args]) -> (op#([l' | <conc>(mid', [r'])]))
    where <split-init-last> args => (mid, r)
        ; <try(test(<RightAssoc> (e,<id>)); paren)> l => l'
  ; <map(test(<GreaterThan>(e,<id>)); paren)> mid => mid'
        ; <try(test(<LeftAssoc>  (e,<id>)); paren)> r => r'

  Disambiguate(paren) :
    e@op#([l]) -> (op#([l']))
    where <test(<GreaterThan>(e,<id>)); paren> l => l'

/**
 * Generation of the parenthesation rules.
 */
strategies

  init-parenthesation-rules =
    !([], <id>)
    ; repeat(gen-left + gen-right + gen-non-assoc + gen-none)

  gen-left :
    (greater, [(Some("left"), ops) | rest]) -> (<conc>(ops, greater), rest)
    where <for-each-pair(GenLeftAssoc)> (ops, ops)
        ; <for-each-pair(GenGreaterThan; GenLeftAssoc; GenRightAssoc)> (greater, ops)

  gen-right :
    (greater, [(Some("right"), ops) | rest]) -> (<conc>(ops, greater), rest)
    where <for-each-pair(GenRightAssoc)> (ops, ops)
        ; <for-each-pair(GenGreaterThan; GenLeftAssoc; GenRightAssoc)> (greater, ops)

  gen-non-assoc :
    (greater, [(Some("non-assoc"), ops) | rest]) -> (<conc>(ops, greater), rest)
    where <for-each-pair(GenLeftAssoc; GenRightAssoc)> (ops, ops)
        ; <for-each-pair(GenGreaterThan; GenLeftAssoc; GenRightAssoc)> (greater, ops)

  gen-none :
    (greater, [(None(), ops) | rest]) -> (<conc>(ops, greater), rest)
    where <for-each-pair(GenGreaterThan; GenLeftAssoc; GenRightAssoc)> (greater, ops)

  GenLeftAssoc =
    ?(op1, op2)
    ; rules(
        LeftAssoc : (op1#(_), op2#(_)) -> ()
      )

  GenRightAssoc =
    ?(op1, op2)
    ; rules(
        RightAssoc : (op1#(_), op2#(_)) -> ()
      )

  GenGreaterThan =
    ?(op1, op2)
    ; rules(
        GreaterThan : (op1#(_), op2#(_)) -> ()
      )

// strategy/general/rename
rules

  RnVar(isvar : (name -> env) * name -> term) :
    (t, env) -> <isvar(split(id, !env); lookup)> t

  RnBinding(bndvrs) :
    (t, env1) -> (t, env1, env2)
    where <bndvrs> t => xs; map(new) => ys;
          <conc>(<zip(id)>(xs,ys), env1) => env2

  DistBinding(s) :
    (t, env1, env2) -> <all( \x -> <s>(x, env2)\ )> t

strategies

 /**
  * renaming bound variables assuming that variables are bound
  * in all subterms of a binding construct
  * variable declarations in binding constructs are assumed to
  * have the same shape as variable uses
  */
  rename(isvar : (name -> env) * name -> term
        , bndvars) =
    \ t -> (t, []) \ ;
    rec x(env-alltd(RnVar(isvar)
                    <+ RnBinding(bndvars);
                       DistBinding(x)))

rules

  DistBinding(s, boundin : (term -> term) * (term -> term) * (term -> term) * term -> term):
    (t, env1, env2) -> <boundin(\x -> <s>(x, env2)\
                               ,\x -> <s>(x, env1)\
                               ,id)> t

strategies

 /**
  * The strategy \verb|rename(isvar, mkvar, bnd)| renames all
  * bound variables in a term to fresh variables;
  *
  * Parameters:
  *
  * isvar: Succeeds if applied to a variable
  * newvar: Takes a string and builds a variable
  * bnd: Maps a binding construct to the list of bound variables
  *
  * renaming while making a distinction between subterms
  * in which the variables are bound or not
  * variables at binding sites are assumed to have
  * the same shape as other variable occurences
  */
  rename(isvar : (name -> env) * name -> term
        , bndvars
        , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term) =
    \ t -> (t, []) \ ;
    rec x(env-alltd(RnVar(isvar)
                    <+ RnBinding(bndvars);
                       DistBinding(x, boundin)))

rules

  RnBinding(bndvrs, paste : (term -> vars) * term -> term) :
    (t, env1) -> (<paste(!ys)> t, env1, env2)
    where <bndvrs> t => xs; map(new) => ys;
          <conc>(<zip(id)>(xs,ys), env1) => env2


strategies

  rename(isvar : (name -> env) * name -> term
        , bndvars
        , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term
        , paste : (term -> vars) * term -> term
        )
  = \ t -> (t, []) \ ;
    rec x(env-alltd(RnVar(isvar)
                    <+ RnBinding(bndvars, paste);
                       DistBinding(x, boundin)))

rules

  RnBinding(bndvrs, paste : (term -> vars) * term -> term, newvar : term -> term) :
    (t, env1) -> (<paste(!ys)> t, env1, env2)
    where <bndvrs> t => xs; map(newvar) => ys;
          <conc>(<zip(id)>(xs,ys), env1) => env2

strategies

  rename(isvar : (name -> env) * name -> term
        , bndvars
        , boundin : (term -> term) * (term -> term) * (term -> term) * term -> term
        , paste : (term -> vars) * term -> term
        , newvar : term -> term
        )
  = \ t -> (t, []) \ ;
    rec x(env-alltd(RnVar(isvar)
                    <+ RnBinding(bndvars, paste, newvar);
                       DistBinding(x, boundin)))


// strategy/general/substitution
strategies

  // substitutions accept two types of input
  // 1) a pair of a substitution (is list of pairs) and a term
  // 2) a triple of a list of variables, a list of terms that should
  //    replace them, and a term

  subs-args =
    ?(sbs, t) <+ \ (xs, ys, t) -> (<zip(id)> (xs, ys), t) \

rules

  // replacing a variable with its value in the substitution

  SubsVar(isvar, mksbs) :
    t -> <lookup> (x, sbs)
    where <isvar> t => x; mksbs => sbs

strategies

  // substitute variables, no regard for variable bindings, and
  // rename bound variables in substituted terms

  substitute(isvar, ren) =
    subs-args => (sbs,t); !t;
    alltd(SubsVar(isvar, !sbs); ren)

  // substitute variables, no regard for variable bindings

  substitute(isvar) =
    substitute(isvar, id)

  // substitute all variables, rename bound variables on the way down,
  // and rename the bound variables in the terms that are substituted
  // for variables using the renaming strategy ren

  substitute(isvar
            , varshape: (name -> env) * name -> term
            , bndvars
            , boundin: (term -> term) * (term -> term) * (term -> term) * term -> term
            , paste: (term -> vars) * term -> term
            , ren)
  = subs-args => (sbs,t); !(t, []);
    rec x(env-alltd(RnVar(varshape)
                    <+ Fst; SubsVar(isvar, !sbs); ren
                    <+ RnBinding(bndvars, paste);
                       DistBinding(x,boundin)))

  // substitute variables and rename bound variables encountered
  // on the way to prevent variable capture, don't rename
  // substituted terms

  substitute(isvar
            , varshape: (name -> env) * name -> term
            , bndvars
            , boundin: (term -> term) * (term -> term) * (term -> term) * term -> term
            , paste: (term -> vars) * term -> term )
  = substitute(isvar, varshape, bndvars, boundin, paste, id)

// strategy/general/unification
strategies

  equal =
    for(id ,[], UfIdem <+ UfDecompose
                //<+ debug(!"not equal: "); FAIL
    )

rules

  UfIdem :
    [(x,x) | ps] -> ps

  UfDecompose :
    [(f#(xs), f#(ys)) | ps] -> <conc>(<zip(id)>(xs, ys), ps)

strategies

  diff =
    for(\ ps -> ([],ps) \ , (id,[]), (id, UfIdem <+ UfDecompose) <+ UfShift)

rules

  UfShift :
    (ps1, [p | ps2]) -> ([p | ps1], ps2)

strategies

  pattern-match(isvar) =
    for(\ pairs -> (pairs, []) \
       ,\ ([], sbs) -> sbs \
       ,(UfIdem, id) <+ MatchVar(isvar) + (UfDecompose, id))

rules

  MatchVar(isvar) :
    ([(x,y) | ps], sbs) -> (ps, [(x, y) | sbs])
    where <isvar> x; <not(fetch({z: ?(x,z); <not(eq)> (y, z)}))> sbs

strategies

 /**
  * The strategy unify unifies a list of pairs of terms and creates the
  * most general unifier for them. The strategy is parameterized
  * by a strategy \verb|isvar| that determines the shape of variables.
  *
  * The result is a list of pairs \verb|(x1,p1)|, where \verb|x1| is
  * a term for which \verb|isvar| succeeds and \verb|p1| is the term
  * it should be substituted with to unify the terms.
  *
  * E.g. <unify(isvar)> [(t1,t2),(t3,t4),...] => [(x1,p1),(x2,p2),...]
  */
  unify(isvar) =
    for(\ pairs -> (pairs, []) \
       ,\ ([], sbs) -> sbs \
       ,(UfIdem, id) <+ UfVar(isvar) + UfSwap(isvar) <+ (UfDecompose, id))

rules

  UfVar(isvar) :
  ([(x,y) | ps], sbs) -> (ps', [(x, y) | sbs''])
  where <isvar> x; <not(is-subterm)>(x,y);
              <substitute(isvar)> ([(x,y)], (sbs, ps)) => (sbs'', ps')

  UfSwap(isvar) :
  ([(x,y) | ps], sbs) -> ([(y,x) | ps], sbs)
  where <not(isvar)> x; <isvar> y

strategies

  equal(fltr) =
    for(id ,[], UfIdem
                <+ try([(fltr,fltr)|id]); UfDecompose
                //<+ debug(!"not equal: "); FAIL
    )

strategies

 /**
  * The following equality strategy has an additional filter
  * that can be used for checking equality modulo alpha renaming.
  * The filter applies to the entire pair and can change something
  * in one term based on the other term.
  */
  equal(fltr1, fltr2) =
    for(id ,[], UfIdem
                <+ [(try(fltr1),try(fltr1)); try(fltr2)|id]; UfDecompose
                //<+ debug(!"not equal: "); FAIL
    )

// strategy/pack/common
rules

  PackInit : root -> (root, (), [])

strategies

 /**
  * Packing a module consists of collecting all modules into
  * a single file.
  */
  pack(parser, imp) =
    PackInit;
    graph-nodes(Fst; parser, get-imports(imp), \ (n,x,xs) -> [x|xs] \ )

  get-imports(imp) =
    collect(imp); concat

rules

  WriteMod(getname, write, ext) :
    mod -> <write>(<add-extension>(<getname>mod, <ext>()), mod)

strategies

 /**
  * Unpacking is the reverse of packing, i.e., writing each module
  * in a list of modules to a separate file.
  */
  unpack(wrapper: (term -> term) * term -> term, getname, ext) =
    wrapper(WriteMod(getname, WriteToTextFile, ext))

strategies

 /**
  * <flatten> (root, mods)| produces a flattened version of the root module.
  */
  flatten(imp, nameeq, getcontent) =
    \ (root, mods) -> (root, mods, []) \;
    graph-nodes(lookup(nameeq),
    get-imports(imp),
    \ (_,x,y) -> <conc>(<getcontent>x, y)\ )

// strategy/pack/graph
rules

  GnInit :
    (root, graph, nodes) -> ([root], [root], graph, nodes, [])

  GnInitRoots :
    (roots, graph, nodes) -> (roots, roots, graph, nodes, [])

  GnNext(get-node, out-edges, add-node) :
    ([name | todo], done, graph, nodes, undef) ->
    (<conc> (todo', todo), <conc> (todo', done),
     graph, <add-node> (name, node, nodes), undef)
    where <get-node> (name, graph) => node;
          <out-edges> node => names;
    <diff> (names, done) => todo'

  GnNextChangeGraph(get-node, out-edges, add-node) :
    ([name | todo], done, graph, nodes, undef) ->
    (<conc> (todo', todo), <conc> (todo', done),
     graph', <add-node> (name, node, nodes), undef)
    where <get-node> (name, graph) => (node,graph');
          <out-edges> node => names;
    <diff> (names, done) => todo'

  GnUndefined :
    ([name | todo], done, graph, nodes, undef) ->
    (todo, done, graph, nodes, [name | undef])

  GnExit :
    ([], done, graph, nodes, undef) -> (nodes, undef)

strategies

  graph-nodes-undef-roots(get-node, out-edges, add-node) =
    for(GnInitRoots, GnExit, GnNext(get-node, out-edges, add-node)
                             <+ GnUndefined)

  graph-nodes-undef(get-node, out-edges, add-node) =
    for(GnInit, GnExit, GnNext(get-node, out-edges, add-node)
                        <+ GnUndefined)

  graph-nodes-undef-roots-chgr(get-node, out-edges, add-node) =
    for(GnInitRoots, GnExit, GnNextChangeGraph(get-node, out-edges, add-node)
                        <+ GnUndefined)

  graph-nodes-undef-chgr(get-node, out-edges, add-node) =
    for(GnInit, GnExit, GnNextChangeGraph(get-node, out-edges, add-node)
                        <+ GnUndefined)

 /**
  * The strategy 'graph-nodes' is a generic
  * algorithm for mapping a graph to a collection of nodes reachable
  * from a given root node. The algorithm is parameterized with the
  * following notions: 'get-node' maps a node name and a graph to the
  * node itself, 'out-edges' maps a node to the names of its out
  * edges, 'add-node' that adds a name and its corresponding node to a
  * collection of nodes.
  *
  *    get-node  :: name * graph -> node
  *    out-edges :: node -> List(name)
  *    add-node  :: name * node * nodes -> nodes
  */
 graph-nodes(get-node, out-edges, add-node) =
    graph-nodes-undef(get-node, out-edges, add-node);
    \ (nodes, undef) -> nodes \

  graph-nodes-roots(get-node, out-edges, add-node) =
    graph-nodes-undef-roots(get-node, out-edges, add-node);
    \ (nodes, undef) -> nodes \

// strategy/pack/modules
strategies

  pack-options =
    ArgOption("-I" + "--Include",
  where(<extend-config>("-I", ["-I", <id>])); !(),
  !"-I d | --Include d   Include modules from directory d")

  + Option("--nodep" + "-nodep",
  where(<set-config> ("-nodep", "")); !(),
  !"--nodep              Don't create dependency file")

  + ArgOption("--dep" + "-d" + "-dep",
  where(<set-config> ("-dep", <id>)); !(),
  !"--dep f | -d f       Write dependency to file f")

  pack-modules(pack : (term -> term) * term -> term)
    = pack-modules(pack, fail)
      <+ <fatal-error> ["Packing modules failed"]

  pack-modules(pack : (term -> term) * term -> term, dep-base) =
    option-wrap(pack-options <+ io-options,
      (<get-config; filter(not("-I"))> "-I" <+ ![]) => path
      ; (<get-config> "-i" <+ !stdin()) => infile
      ; (<get-config> "-o" <+ !stdout()) => outfile
      ; <pack(!path)> infile => (files, spec)
      ; (<get-config> "-b"; <WriteToBinaryFile>(outfile, spec)
         <+ <WriteToTextFile>(outfile, spec))
      ; try((<get-config> "-dep" <+ not(<get-config> "-nodep"); dep-base) => depfile
            ; <create-dep-file(!depfile)> (outfile, files))
    )

  create-dep-file(dep-base) :
    (outfile, files) -> (outfile, files)
    where <dep-base> outfile => out
  ; <fopen> (<add-extension> (out, "dep"), "w") => dep
  ; <fprintnl> (dep, [out | <separate-by(!" \\\n\t")> [" :" | files]])
  ; <fclose> dep

// strategy/traversal/environment
rules

  all-dist(s) :
    (t, env) -> <all(\x -> <s>(x,env)\)> t

  one-dist(s) :
    (t, env) -> <one(\x -> <s>(x,env)\)> t

  d(s) :
    (t, env) -> <s> t

  t(s) :
    (t, env) -> (<s>t, env)

  coll(s) :
    f#(xs) -> (f#(ys), zs)
    where <unzip(s)> xs => (ys, zs)

strategies

  env-alltd(s) =
    rec x(s <+ all-dist(x))

  env-topdown(s) =
    rec x(s; all-dist(x))

  env-topdown(s, skip: (term -> term) * term -> term) =
    rec x(s; (skip(x) <+ all-dist(x)))

  env-bottomup(s) =
    rec x(split(all-dist(x), Snd); s)

/*
  thread(s) :
    (c#(ts), x) -> (c#(ts'), y)
    where <thread-map(s)> (ts, x) => (ts', y)
*/

  thread-replacement(s) :
    (c#(ts), x) -> (c#(ts'), y)
    where <thread-map(s)> (ts, x) => (ts', y)

  thread-alltd(s) =
    rec x(s <+ thread-replacement(x))

  thread-bottomup(s) =
    rec x(thread-replacement(x); s)

  count-bottomup(s) =
    !(<id>,0); thread-bottomup(try((s, inc)))

  env-oncetd(s) =
    rec x(s <+ one-dist(x))

// strategy/traversal/fixpoint
strategies

  // reduce(s) = repeat(rec x(s + one(x)))

  reduce(s) =
    repeat(rec x(some(x) + s))

  outermost(s) =
    repeat(oncetd(s))

  innermost'(s) =
    repeat(oncebu(s))

  innermost(s)  =
    bottomup(try(s; innermost(s)))

  innermost-old(s) =
    rec x(all(x); (s; x <+ id))

  pseudo-innermost3(s) =
    rec x(all(x); rec y(try(s; all(all(all(y); y); y); y)))

  innermost-memo(s) =
    rec x(memo(all(x); (s; x <+ id)))

 /**
  * innermost-tagged(s) reduces the subject term by applying s to
  * innermost redices first. Terms in normal form are tagged (using
  * attributes) to prevent renormalization.
  */
  innermost-tagged(s : a -> a) = // : a -> a
    where(new => tag);
    rec x(?_{tag} <+ (all(x); (s; x <+ !<id>{tag})));
    bottomup(?<id>{tag})

// strategy/traversal/list-environment
rules

  all-l-dist(s) :
    (t, env) -> <all-l(\x -> <s>(x,env)\)> t

strategies

  env-alltd-l(s) =
    rec x(s <+ all-l-dist(x))

  env-topdown-l(s) =
    rec x(s; all-l-dist(x))

  env-topdown-l(s, skip: (term -> term) * term -> term) =
    rec x(s; (skip(x) <+ all-l-dist(x)))

  env-bottomup-l(s) =
    rec x(split(all-l-dist(x), Snd); s)

// strategy/traversal/list
strategies
/*

  Term traversals can be categorized into classes according to
  how much of the term they traverse and to which parts
  of the term they modify.

  \paragraph{Everywhere}

  The most general class of traversals visits every node
  of a term and applies a transformation to it. The following
  operators define traversals that apply a strategy \verb|s|
  to all nodes of a term.

*/

  all-l(s) = ?[_|_] < [s | s] + all(s)


  topdown-l(s) =
    rec x(s; all-l(x))

  bottomup-l(s) =
    rec x(all-l(x); s)

  downup-l(s) =
    rec x(s; all-l(x); s)

  downup-l(s1, s2) =
    rec x(s1; all-l(x); s2)

  downup2-l(s1, s2) =
    rec x(s1; all-l(x); s2)

/*

  The traversals above go through all constructors. If it
  is not necessary to traverse the entire tree, the following
  versions of the traversals can be used. They are parameterized
  with a strategy operator \verb|stop| that

*/

  topdownS-l(s, stop: (a -> a) * a -> a) =
    rec x(s; (stop(x) <+ all-l(x)))

  bottomupS-l(s, stop: (a -> a) * a -> a) =
    rec x((stop(x) <+ all-l(x)); s)

  downupS-l(s, stop: (a -> a) * a -> a) =
    rec x(s; (stop(x) <+ all-l(x)); s)

  downupS-l(s1, s2, stop: (a -> a) * a -> a) =
    rec x(s1; (stop(x) <+ all-l(x)); s2)

/*

  A variation on bottomup is a traversal that also provides the
  original term as well as the term in which the direct subterms
  have been transformed. (also known as a paramorphism?)

*/

  bottomup-para-l(s) =
    rec x(!(<id>, <all-l(x)>); s)

/*

  \paragraph{Frontier}

  Find all topmost applications of \verb|s|;

*/

  alltd-l(s) =
    rec x(s <+ all-l(x))

  alldownup2-l(s1, s2) =
    rec x((s1 <+ all-l(x)); s2)

  alltd-fold-l(s1, s2) =
    rec x(s1 <+ all-l(x); s2)

// strategy/traversal/simple
/**
 * Traverse a term everywhere.
 *
 * The most general class of traversals visits every node
 * of a term and applies a transformation to it. The following
 * operators define traversals that apply a strategy s
 * to all nodes of a term.
 */
strategies

  /** Apply strategy s to each term in a top down, left to right,
   * (prefix) order.
   *
   * Note: new terms resulting from rewrites during the traversal will
   * also be traversed.
   *
   * @param s - the strategy to apply
   * @type Term -> Term
   */
  topdown(s) =
    s; all(topdown(s))

  /** Apply strategy s to each term in a bottom up, left to right,
   * (postfix) order.
   *
   * @param s - the strategy to apply
   * @type Term -> Term
   */
  bottomup(s) =
    all(bottomup(s)); s

  /** Apply strategy s to all terms going down then going up. The traversal
   * will traverse the spine until a leaf is reached, then proceed to the
   * other leaves, before it returns up the spine.
   *
   * Each term, including the leaves, will be visited in both the down and
   * up directions.
   *
   * @param s - the strategy to apply
   * @type Term -> Term
   */
  downup(s) =
    s; all(downup(s)); s

  /** Apply strategy s1 to all terms going down then apply s2 to all terms
   * when going up. This strategy will traverse the spine until a leaf is
   * reached, then proceed to the other leaves until none are left, before
   * it returns up the spine.
   *
   * Each term, including the leaves, will be visited in both the down and
   * up directions, with s1 then s2 applied to it, respectively.
   *
   * @param s1 - the strategy applied on the way down
   * @param s2 - the strategy applied on the way up
   * @type Term -> Term
   * @see downup
   */
  downup(s1, s2) =
    s1; all(downup(s1, s2)); s2

  downup2(s1, s2) =
    s1; all(downup2(s1, s2)); s2


/**
 * Traversal that can stop at certain points.
 *
 * The traversals above go through all constructors. If it
 * is not necessary to traverse the entire tree, the following
 * versions of the traversals can be used. They are parameterized
 * with a strategy operator 'stop' that
 */
strategies

  /** Apply strategy s to each term in a top down, left to right, (prefix)
   * order, but stop traversal when stop succeeds.
   *
   * @param s         Term -> Term
   * @param stop      (a -> a) * a -> a
   * @type Term -> Term
   * @see topdown
   */
  topdownS(s, stop: (a -> a) * a -> a) =
    s
    ; (stop(topdownS(s,stop)) <+ all(topdownS(s,stop)))

  /** Apply strategy s to each term in a bottom up, left to right,  (postfix)
   * order, but stop traversal when stop succeeds.
   *
   * @param s         Term -> Term
   * @param stop      (a -> a) * a -> a
   * @type Term -> Term
   * @see bottomup
   */
  bottomupS(s, stop: (a -> a) * a -> a) =
    (stop(bottomupS(s, stop)) <+ all(bottomupS(s, stop)))
    ; s

  /** Apply strategy s to all terms when going down then when going up,
   * but stop traversal when stop succeeds.
   *
   * @param s         Term -> Term
   * @param stop      (a -> a) * a -> a
   * @type Term -> Term
   * @see downup
   */
  downupS(s, stop: (a -> a) * a -> a) =
    s
    ; (stop(downupS(s, stop)) <+ all(downupS(s, stop))); s

  /** Apply strategy s1 to all terms going down then apply s2 to all terms
   * when going up, but stop travesal when stop succeeds.
   *
   * @param s1         Term -> Term
   * @param s2         Term -> Term
   * @param stop      (a -> a) * a -> a
   * @type  Term -> Term
   * @see downup
   */
  downupS(s1, s2, stop: (a -> a) * a -> a) =
    s1
    ; (stop(downupS(s1, s2, stop)) <+ all(downupS(s1, s2, stop)))
    ; s2

  /**
   * A unit for topdownS, bottomupS and downupS. For example,
   * topdown(s) is equivalent to topdownS(s,don't-stop).
   *
   * @param s Term -> Term
   * @type _ -> fail
   * @see topdownS
   * @see bottomupS
   * @see downupS
   */
  don't-stop(s) =
    fail

  /**
   * A variation on bottomup is a traversal that also provides the
   * original term as well as the term in which the direct subterms
   * have been transformed. (also known as a paramorphism?)
   */
  bottomup-para(s) =
    !(<id>, <all(bottomup-para(s))>)
    ; s

/**
 * Traversal of a term along a spine.
 *
 * A spine of a term is a chain of nodes from the root to some
 * subterm. 'spinetd' goes down one spine and applies 's' along
 * the way to each node on the spine. The traversal stops when
 * 's' fails for all children of a node.
 */
strategies

  /**
   * Apply s along the spine of a term, in top down order.
   *
   * A spine of a term is a chain of nodes from the root to some
   * subterm. The traversal stops when 's' fails for all children
   * of a node.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  spinetd(s) =
    s; try(one(spinetd(s)))

  /**
   * Apply s along the spine of a term, in bottom up order.
   *
   * A spine of a term is a chain of nodes from the root to some
   * subterm. The traversal stops when 's' fails for all children
   * of a node.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  spinebu(s) =
    try(one(spinebu(s))); s

  spinetd'(s) =
    s; (one(spinetd'(s)) + all(fail))

  spinebu'(s) =
    (one(spinebu'(s)) + all(fail)); s


/**
 * Apply s everywhere along all spines where s applies.
 */
strategies

  /** Apply s everywhere along all spines where s applies, in top down
   * order.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   * @see   spinetd
   */
  somespinetd(s) =
    rec x(s; try(some(x)))

  /** Apply s everywhere along all spines where s applies, in bottom
   * up order.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   * @see   spinetd
   */
  somespinebu(s) =
    rec x(try(some(x)); s)

/**
 * Apply s at one position. One s application has to succeed.
 */
strategies

  /** Apply s at one position inside a term, in top down order. Once
   * s has succeeded, the traversal stops. If s never succeeds, this
   * strategy fails.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   *
   * @see collect-one
   */
  oncetd(s) =
    rec x(s <+ one(x))

  /** Apply s at one position inside a term, in bottom up order. Once
   * s has succeeded, the traversal stops. If s never succeeds, this
   * strategy fails.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  oncebu(s) =
    rec x(one(x) <+ s)

  oncetd-skip(s, skip: (a -> a) * a -> a) =
    rec x(s <+ skip(x) <+ one(x))

/**
 * Apply s at some positions, but at least one.
 *
 * As soon as one is found, searching is stopped, i.e., in the top-down case
 * searching in subtrees is stopped, in bottom-up case, searching
 * in upper spine is stopped.
 */
strategies

  /** Apply s at some positions inside a term, at least once, in top
   * down order. Once s succeeds, the traversal stopped.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   * @see oncetd
   */
  sometd(s) =
    rec x(s <+ some(x))

  /** Apply s at some positions inside a term, at least once, in bottom
   * up order. Once s succeeds, the traversal stopped.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   * @see oncetd
   */
  somebu(s) =
    rec x(some(x) <+ s)

/**
 * Frontier
 *
 * Find all topmost applications of 's'
 */
strategies

  /** Find all topmost applications of s.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  alltd(s) =
    rec x(s <+ all(x))

  alldownup2(s1, s2) =
    rec x((s1 <+ all(x)); s2)

  alltd-fold(s1, s2) =
    rec x(s1 <+ all(x); s2)

/**
 * Leaves
 */
strategies

  leaves(s, is-leaf, skip: (a -> a) * a -> a) =
    rec x((is-leaf; s) <+ skip(x) <+ all(x))

  leaves(s, is-leaf) =
    rec x((is-leaf; s) <+ all(x))

/**
 * Find as many applications as possible, but at least one.
 */
strategies

  /** Apply s as many times as possible, but at least once, in bottom up
   * order.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  manybu(s) =
    rec x(some(x); try(s) <+ s)

  /** Apply s as many times as possible, but at least once, in top down
   * order.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  manytd(s) =
    rec x(s; all(try(x)) <+ some(x))

strategies

  somedownup(s) =
    rec x(s; all(x); try(s) <+ some(x); try(s))

  /** Apply s to a term in breadth first order.
   *
   * @param s          Term -> Term
   * @type  Term -> Term
   */
  breadthfirst(s) =
    rec x(all(s); all(x))

// strategy/collect
/**
 * Collect all subterms
 */
strategies

  /**
   * collect all subterms for which s succeeds
   *
   * This strategy returns a *set* of subterms. The result
   * will therefore not contain duplicates.
   */
  collect-all(s) =
    collect-all(s, union)

  /**
   * collect all subterms with user-defined union operator.
   *
   * The un argument must take two lists and produce a single one.
   */
  collect-all(s,un) =
    rec x(
      ![<s> | <crush(![],un,x)>]
      <+ crush(![],un,x)
    )

  /**
   * collect all subterms with user-defined union operator and
   * a skip argument.
   *
   * The un argument must take two lists and produce a single one.
   * If duplicates must be removed, then this argument should be union,
   * otherwise it usually conc.
   *
   * The reduce argument can be used to reduce the current term before
   * collecting subterms of it. Producing the empty list will result
   * in a complete skip of all subterms.
   *
   * example:
   *   collect-all(?Var(_), conc, \ Assign(_, e) -> e \)
   *
   * applied to:
   *   Assign(Var("x"), Plus(Var("y"), Var("z")))
   *
   * results in:
   *   [Var("y"), Var("z")]
   *
   * The collect-all is applied to the term after the reduce, i.e the
   * example collect-all applied to
   *
   *   Assign(Var("x"), Var("y"))
   *
   * results in:
   *   [Var("y")]
   *
   * @since  0.9.6
   */
  collect-all(s, un, reduce) =
    rec x(
       ![<s> | <crush(![],un,x)>]
    <+ reduce; x
    <+ crush(![],un,x)
    )

/**
 * Collect outermost subterms
 */
strategies

  /**
   * collect outermost subterms for which s succeeds
   *
   * This strategy returns a *set* of subterms. The result
   * will therefore not contain duplicates.
   */
  collect-om(s) =
    collect-om(s, union)

  /**
   * Synonym of collect-om.
   */
  collect(s) =
    collect-om(s)

  /**
   * collect outermost subterms with user-defined union operator.
   *
   * The un argument must take two lists and produce a single one.
   */
  collect-om(s, op) =
    ![<s>]
    <+ crush(![], op, collect-om(s, op))

  /**
   * collect outermost subterms with user-defined union operator and
   * a skip argument.
   *
   * See collect-all(s, un, skip) for a description of the arguments.
   *
   * @since  0.9.6
   */
  collect-om(s, un, skip) =
    rec x(
       ![<s>]
    <+ skip; crush(![],un,x)
    <+ crush(![],un,x)
    )

strategies

 /**
  * Produces pair of a reduced term and a list of extracted subterms.
  *
  * Reduces terms with f and extracts information with g resulting in a
  * pair (t, xs) of a reduced term and the list of extracted subterms.
  */
  collect-split(f, g) =
    rec x(CollectSplit(x, !(<try(f)>, <g <+ ![]>)))

  collect-split(splitter) =
    rec x(CollectSplit(x, splitter <+ !(<id>,[])))

  /**
   * Helper of collect-split. Don't use.
   */
  CollectSplit(s, splitter) :
    c#(as){annos*} -> (t, <union> (ys, <unions> xs))
      where <unzip(s)> as => (bs, xs);
      <splitter> c#(bs){annos*} => (t, ys)

  /**
   * Helper of collect-split. Don't use.
   */
  CollectSplit(s, f, g) =
    CollectSplit(s, !(<try(f)>, <g <+ ![]>))


  collect-split'(splitter) =
    rec x((is-string + is-int); splitter
          <+ CollectSplit(x, splitter))

strategies

  postorder-collect(s) =
    postorder-collect(s, ![])

  postorder-collect(s, acc) =
    where((![<s> | <acc>] <+ acc) => ys);
    crush(!ys, \ (x, xs) -> <postorder-collect(s, !xs)> x \ )

strategies

  collect(s, skip: (a -> a) * (a -> a) * a -> a) =
    ![<s>]
    <+ skip(collect(s,skip), ![]); crush(![],union,id)
    <+ crush(![],union,collect(s,skip))

  collect-exc(base, special : (a -> b) * a -> b) =
    rec coll(
      (base
      <+ special(coll))
      <+ crush(![], union, coll)
    )

  bu-collect(s) =
    rec x(some(x); crush(![],union,[s|id] <+ ![])
          <+ ![<s>] )
    <+ ![]

strategies

  /**
   * collect a single, outermost value from a tree.
   */
  collect-one(s) =
    oncetd(where(s; ?t)); !t

strategies // TODO: where should we put this?

  twicetd(s) =
    oncetd(
      explode-term
    ; (id, at-suffix(Cons(oncetd(s), oncetd(s))))
    ; mkterm
    )

  atmostonce(s) =
    not(twicetd(s))

// strategy/conditional
strategies // Equality

  /**
   * Tests whether two terms are equal.
   */

  eq =
    ?(x, x)

  /**
   * Tests whether two terms are equal.
   */

  equal =
    ?(x, x)

  /**
   * Tests whether current term is equal to argument term.
   */

  equal(|x) =
    ?x

  /**
   * Tests whether two argument terms are equal to each other.
   */

  equal(|x, y) =
    where(!x => y)

strategies // Control-flow combinators

  /**
   * try(s) tries to apply s to the current term, but
   * returns it unchanged (and succeeds) when s fails.
   */

  try(s) =
    s <+ id

  if(c, b) =
    c < b + id

  if(c, b1, b2) =
    c < b1 + b2

  /**
   * Apply restoring action 'rest' if s fails, and then fail.
   *
   * Typically useful if s performs side effects that should be
   * restored/undone in case s fails.
   */

  restore(s, rest) =
    s <+ (rest; fail)

  /**
   * Apply restoring action 'rest' after s terminates, and preserve
   * success/failure behaviour of s.
   *
   * Typically useful if s performs side effects that should be
   * restored always, e.g., when maintaining scope information.
   */

  restore-always(s, rest) =
    s < rest + (rest; fail)

  /**
   * Applies s followed by f whether s failed or not.
   *
   * @result <s> input
   * @fail   s or f failed (consider try(f))
   * @type   a -> b, (a or b) -> _ :: a -> b
   */

  finally(s, f) =
    s < where(f) + (where(f); fail)

strategies // Boolean combinators

  /**
   * true is a synonym for id.
   */

  true =
    id

  /**
   * false is a synonym for fail.
   */

  false =
    fail

  /**
   * ior(s1, s2) implements 'inclusive or', that is, the
   * inclusive choice of s1 and s2. It first tries s1, if
   * that fails it applies s2 (just like s1 <+ s2). However,
   * when s1 succeeds it also tries to apply s2.
   *
   * The results of the transformations are returned.
   */

  ior(s1, s2) =
    (s1; try(s2)) <+ s2

  /**
   * or(s1, s2) is similar to ior(s1,s2), but the application
   * of the strategies is only tested.
   */

  or(s1, s2) =
    if s1 then try(test(s2)) else test(s2) end

  /**
   * and(s1, s2) applies s1 and s2 to the current
   * term and succeeds if both succeed. s2 will always
   * be applied, i.e., and is *not* a short-circuit
   * operator
   */

  and(s1, s2) =
    if s1 then test(s2) else test(s2); fail end

strategies

  // a -> b :: a -> Option(b)
  maybe(s) = !Some(<s>) <+ !None()

  // a -> b, () -> b :: Option(a) -> b
  maybe(s1, s2) : Some(a) -> <s1> a
  maybe(s1, s2) : None()  -> <s2> ()

// strategy/iteration
strategies

  /**
   * Repeatedly apply s until it fails.
   */
  repeat(s) =
    try(s; repeat(s))

  /**
   * Repeatedly apply s until it fails and terminate with application of c.
   */
  repeat(s, c) =
    (s; repeat(s, c)) <+ c

  /**
   * Repeatedly apply s (at least once) and terminate with application of c.
   */
  repeat1(s, c) =
    s; (repeat1(s, c) <+ c)

  /**
   * Repeatedly apply s (at least once).
   */
  repeat1(s) =
    repeat1(s, id)

  /**
   * Repeatedly apply s until c succeeds.
   */
  repeat-until(s, c) =
    s; (c <+ repeat-until(s, c))

  /**
   * Applies s repeatedly exactly n times. If s fails at some point during
   * the n applications, the entire strategy fails. The result of the
   * strategy is that of the nth application of s.
   */
  repeat(s | n) =
    if <eq>(n, 0)
    then
      id
    else
      s; repeat(s|<dec>n)
    end

  /**
   * While c succeeds apply s.
   */
  while(c, s) =
    try(c; s; while(c, s))

  /**
   * While c does not succeed apply s.
   */
  while-not(c, s) =
    c <+ (s; while-not(c, s))

  /**
   * Apply s at least once and then repeat while c succeeds.
   */
  do-while(s, c) =
    s; while(c, s)

  /**
   * Repeat application of s after initialization with i
   * while c fails.
   */
  for(i, c, s) =
    i; while-not(c, s)

  /**
   * Apply s for each integer from low to up (inclusive).
   */
  for(s : Int * a -> a | low, up) =
    if <leq>(low, up) then
      s(|low)
      ; for(s | <inc>low, up)
    end

// term/annotation
strategies

  /**
   * Alias of get-annotations.
   *
   * @inc test-get-annos
   */
  get-annos =
    get-annotations

  /**
   * Returns the list of annotations of the current term.
   */
  get-annotations :
    t{t*} -> t*

  /**
   * Alias of set-annotations.
   *
   * @inc test-set-annos
   */
  set-annos =
    set-annotations

  /**
   * Sets the annotations of the given term t to the annotations a.
   */
  set-annotations :
    (t, t*) -> t{t*}

  set-anno :
    (t1, t2) -> t1{t2}

  /**
   * @todo The xs variable is a hack for issue STR-382.
   * @todo ?[]{} is a hack for issue SPX-724.
   */
  rm-annotations = ?[]{} <+ ?t; !t{}

  /**
   * Succeeds if a term has annotations.
   *
   * @inc test-has-annos
   */
  has-annos =
    ?_{t,t*}

  has-annotation =
    has-annos

  if-annotation(s1, s2) =
    has-annotation < s1 + s2

  strip-annos =
    bottomup(rm-annotations)

  catch-annos =
    rec x(has-annotation < !Anno(<rm-annotations; all(x)>, <get-annotations>) + all(x))

  /**
   * Alias of preserve-annos
   */
  preserve-annotation(s) =
    preserve-annos(s)

  preserve-annos(s):
    t{a*} -> r{a*}
      where <s> t => r

// term/common
strategies

 /**
  * Build a term given a constructor name and a list of terms.
  *
  * Note that this primitive strategy has been turned into a language construct.
  *
  * The pattern f#(xs) denotes the decomposition of a term into its function symbol
  * f and its list of arguments xs. This pattern can be used in matching ?f#(xs)
  * and building !f#(xs) terms (so also in left- and right-hand sides of rules) and
  * also as a congruence s1#(s2).
  *
  * E.g. <mkterm> (f, [t1,...,tn])  builds the constructor application f(t1,...,tn).
  */
  mkterm       = ?(c,ts); prim("SSL_mkterm",c,ts)

 /**
  * Decompose a term into a constructor name and a list of terms.
  *
  * Note that this primitive strategy has been turned into a language construct.
  *
  * The pattern f#(xs) denotes the decomposition of a term into its function symbol
  * f and its list of arguments xs. This pattern can be used in matching ?f#(xs)
  * and building !f#(xs) terms (so also in left- and right-hand sides of rules) and
  * also as a congruence s1#(s2).
  *
  * E.g. <explode-term> f(t1,...,tn) is the inverse of mkterm and produces (f, [t1,...,tn]).
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */
  explode-term = ?t; prim("SSL_explode_term",t)

 /**
  * Get the constructor of a term.
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */
  get-constructor = ?t; prim("SSL_get_constructor", t)

 /**
  * Get the arguments of a term.
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */
  get-arguments = ?t; prim("SSL_get_arguments", t)

  /**
   * Get the arguments of a term application.
   */
  get-appl-arguments =
    get-appl-arguments(id)

  /**
   * Get the arguments of a term application, applying s to the individual arguments.
   *
   * @param a -> b
   * @type f(a1 ... an) -> [b1 ... bn]
   */
  get-appl-arguments(s) =
    ?t; prim("SSL_get_appl_arguments_map", s | t)

 /**
  * Compare the address of two terms and succeeds if the address of the first is
  * smaller than the address of the second.
  *
  * This predicate induces a total ordering on terms and can be used to sort terms.
  * Note that this relation is valid in one session (but what happens after
  * rehashing), but not necessarily between two sessions.
  */
  address-lt =
    ?(t1,t2); prim("SSL_address_lt",t1,t2)

  /**
   * Compare the address of two terms and succeeds if the address of the current
   * term is smaller than the address of the argument.
   */
  term-address-lt(|t2) =
    ?t1; prim("SSL_address_lt",t1,t2)

 /**
  * Give the address of a term.
  *
  * <address> t replaces t with its address (represented as a string).
  * This can be used to obtain a unique symbolic reference to a term.
  *
  * @type t -> String
  */
  address =
    ?t; prim("SSL_address",t)

 /**
  * Give checksum of a term. Similar to atsum from aterm package.
  */
  checksum = ?t ; prim("SSL_checksum",t)

strategies

  crush(nul, sum) :
    _#(xs) -> <foldr(nul,sum)> xs

  crush(nul, sum, s) :
    _#(xs) -> <foldr(nul,sum, s)> xs

strategies

  node-size =
    crush(!0, add, !1)

  term-size =
    crush(!1, add, term-size)

strategies

  at-depth(depth, s) =
      !(<depth> (), <id>)
    ; topdown(
        {d :
           ?(0, <s> )
        <+ ?(d, <id>); all(!(<dec> d, <id>))
        }
      )

/**
 * Occurence Counting.
 */
strategies

  om-occurrences(s) =
    if s then !1 else crush(!0, add, om-occurrences(s)) end

  occurrences(s) =
    <add> (<if s then !1 else !0 end>, <crush(!0, add, occurrences(s))>)

// term/integer
strategies

  is-int =
    ?i; prim("SSL_is_int", i)

strategies

  /**
   * Adds two numbers (integer or real)
   */
  add  = ?(x,y); (prim("SSL_addi",x,y) <+ prim("SSL_addr",x,y))

  /**
   * Adds two integers
   */
  addi = ?(x,y); prim("SSL_addi",x,y)

  /**
   * Adds two integers
   */
  int-add(|y) =
    ?x; prim("SSL_addi", x, y)

  /**
   * Adds two reals
   */
  addr = ?(x,y); prim("SSL_addr",x,y)

strategies

  /**
   * Bitwise OR's two integers
   */
  iori = ?(x, y); prim("SSL_iori",x,y)

  /**
   * Bitwise XOR's two integers
   */
  xori = ?(x, y); prim("SSL_xori",x,y)

  /**
   * Bitwise AND's two integers
   */
  andi = ?(x, y); prim("SSL_andi",x,y)

  /**
   * Bitwise shift x to the left by y places
   */
  shli = ?(x, y); prim("SSL_shli",x,y)

  /**
   * Bitwise shift x to the right by y places
   */
  shri = ?(x, y); prim("SSL_shri",x,y)

strategies

  /**
   * Subtracts two numbers (integer or real)
   */
  subt  = ?(x,y); (prim("SSL_subti",x,y) <+ prim("SSL_subtr",x,y))

  /**
   * Subtracts two integers
   */
  subti = ?(x,y); prim("SSL_subti",x,y)

  /**
   * Subtracts two integers
   */
  int-subt(|y) =
    ?x; prim("SSL_subti", x, y)

  /**
   * Subtracts two reals
   */
  subtr = ?(x,y); prim("SSL_subtr",x,y)

strategies

  /**
   * Multiplies two numbers (integer or real)
   */
  mul   = ?(x,y); (prim("SSL_muli",x,y) <+ prim("SSL_mulr",x,y))

  /**
   * Multiplies two integers
   */
  muli  = ?(x,y); prim("SSL_muli",x,y)

  /**
   * Multiplies two reals
   */
  mulr  = ?(x,y); prim("SSL_mulr",x,y)

strategies

  /**
   * Divides two numbers (integer or real)
   */
  div = ?(x,y); (prim("SSL_divi",x,y) <+ prim("SSL_divr",x,y))

  /**
   * Divides two integers
   */
  divi  = ?(x,y); prim("SSL_divi",x,y)

  /**
   * Divides two reals
   */
  divr  = ?(x,y); prim("SSL_divr",x,y)

strategies

  /**
   * Returns the modulo (remainder after division) of two integers or reals.
   */
  mod =
    modi <+ modr

  /**
   * Returns the modulo (remainder after division) of two integers
   */
  modi =
    ?(x,y); prim("SSL_modi",x,y)

  /**
   * Returns the modulo (remainder after division) of two floats
   */
  modr =
    ?(x,y); prim("SSL_modr",x,y)

strategies

  gt  = ?(x,y); test(prim("SSL_gti",x,y) <+ prim("SSL_gtr",x,y))
  gti = ?(x,y); test(prim("SSL_gti",x,y))
  gtr = ?(x,y); test(prim("SSL_gtr",x,y))

  geq = ?(x,x) <+ gt
  lt  = not(geq)
  leq = not(gt)

strategies

  /**
   * @type Int -> Int
   */
  int-leq(|y) =
    not(int-gt(|y))

  /**
   * @type Int -> Int
   */
  int-gt(|y) =
    ?x; where(prim("SSL_gti",x,y))

  /**
   * @type Int -> Int
   */
  int-lt(|y) =
    ?x; where(prim("SSL_lti", x, y))

strategies

  // :: Int * Int * Int -> fail?
  leq-leq = comp-comp(leq, leq)
  leq-lt  = comp-comp(leq, lt)
   lt-leq = comp-comp(lt,  leq)
   lt-lt  = comp-comp(lt,  lt)

  // Int * Int -> fail?, Int * Int -> fail? :: Int * Int * Int -> fail?
  comp-comp(s1, s2) =
      ?(x, y, z)
    ; where(<s1> (x, y); <s2> (y, z))

strategies

  /**
   * @type  Int -> fail?
   */
  even = where(<mod> (<id>, 2) => 0)

  /**
   * @type (Int, Int) -> Int
   */
  max = gt < Fst + Snd
  min = gt < Snd + Fst

  /**
   * @type  Int -> Int
   */
  pos = where(<geq> (<id>, 0))
  neg = where(<lt>  (<id>, 0))

//  int   = ?x; prim("SSL_int",x)

strategies

  /**
   * Sets a seed for the following sequence of next-random calls.
   * Typically, the seed is set to the Unix time (the result of the strategy time).
   *
   * @see    man srand
   * @since  0.9.4
   * @type   Int -> ()
   */
  set-random-seed = ?seed; prim("SSL_srand", seed)

  /**
   * Gets the maximum random number that will be returned by the next-random number generator.
   * Corresponds to RAND_MAX in C.
   *
   * @type _ -> Int()
   */
  get-random-max = prim("SSL_RAND_MAX")

  /**
   * Returns a random number between 0 and get-random-max.
   *
   * For a given seed, this strategy always returns the same sequence  of numbers.
   * If no seed value has been set using set-random-seed, then the seed is 1, which
   * means that the sequence of random numbers will always be the same if you set no seed.
   *
   * @see    man rand
   * @since  0.9.4
   * @type   _ -> Int
   */
  next-random = prim("SSL_rand")

strategies

  apply-int-to-str-tuple(s) =
    (string-to-int, string-to-int) ; s ; int-to-string

  addS  = apply-int-to-str-tuple(add)
  subtS = apply-int-to-str-tuple(subt)
  mulS  = apply-int-to-str-tuple(mul)
  divS  = apply-int-to-str-tuple(div)
  modS  = apply-int-to-str-tuple(mod)
  maxS  = apply-int-to-str-tuple(max)
  minS  = apply-int-to-str-tuple(min)

  gtS   = where((string-to-int, string-to-int); gt)
  geqS  = where((string-to-int, string-to-int); geq)
  ltS   = where((string-to-int, string-to-int); lt)
  leqS  = where((string-to-int, string-to-int); leq)

  /**
   * Increments a number.
   *
   * @type Int -> Int
   */
  inc = <add>  (<id>, 1)

  /**
   * Increments an integer
   *
   * @type Int -> Int
   */
  int-inc =
    int-add(|1)

  /**
   * Decrements a number.
   *
   * @type Int -> Int
   */
  dec = <subt> (<id>, 1)

  /**
   * Decrements an integer.
   *
   * @type Int -> Int
   */
  int-dec =
    int-subt(|1)

strategies

  log2 =
    !(<id>, 0);
    repeat((!(<divi>(<id>, 2), <mod; ?0>(<id>, 2)); Fst, inc));
    ?(1, <id>)

strategies

  gcd =
    (abs,abs)
  ; let gcd' = \ (x,0) -> x \ + \ (x,y) -> <gcd'>(y,<mod>(x,y)) \
    in
      gcd'
    end

  abs =
    (is-int + is-real)
    ; if neg then
        <subt> (0, <id>)
      end

signature
  constructors
    Infinite : IntI
             : Int -> IntI

rules

  add-inf =
    let add-inf1: (Infinite(), _) -> Infinite()
        add-inf2: (_, Infinite()) -> Infinite()
     in (add-inf1 + add-inf2) <+ add
    end

  lt-inf = ?(<is-int>, Infinite()) <+ (is-int, is-int); lt

strategies

  new-counter =
    new; reset-counter

  reset-counter = ?c;
    where(<set-counter> (c, 0))

  set-counter =
    ?(c,n); rules( Counter : c -> n )

  get-counter =
    Counter <+ <set-counter> (<id>, 0); !0

  next-counter =
    ?c; get-counter; inc; where(<set-counter> (c, <id>))

strategies

  int-to-string = ?x; prim("SSL_int_to_string",x)
  string-to-int = ?x; prim("SSL_string_to_int",x)

/**
 * Conversion of strings to integers
 */
strategies

 /**
  * @type String -> Int
  * @inc hex-string-test
  */
  hex-string-to-int = <generic-string-to-int> (<id>, 16)

 /**
  * @type String -> Int
  * @inc dec-string-test
  */
  dec-string-to-int = <generic-string-to-int> (<id>, 10)

  oct-string-to-int = <generic-string-to-int> (<id>, 8)

 /**
  * @type String -> Int
  * @inc bin-string-test
  */
  bin-string-to-int = <generic-string-to-int> (<id>, 2)

  /**
   * @type List(Char) -> Int
   */
  hex-chars-to-int = <generic-chars-to-int> (<id>, 16)

  /**
   * @type List(Char) -> Int
   */
  dec-chars-to-int = <generic-chars-to-int> (<id>, 10)

  /**
   * @type List(Char) -> Int
   */
  oct-chars-to-int = <generic-chars-to-int> (<id>, 8)

  /**
   * @type List(Char) -> Int
   */
  bin-chars-to-int = <generic-chars-to-int> (<id>, 2)

  /**
   * @type String * Int -> Int
   */
  generic-string-to-int =
      (explode-string, id)
    ; generic-chars-to-int

  /**
   * @type List(Char) * Int -> Int
   */
  generic-chars-to-int =
    neg-chars-to-int <+ pos-chars-to-int

  // :: List(Char) * Int -> Int
  neg-chars-to-int:
    (['-' | chars], radix) -> <mul> (-1, <pos-chars-to-int> (chars, radix))
      where <gt> (<length> chars, 0)

  // :: List(Char) * Int -> Int
  pos-chars-to-int =
      ?([char | chars], r)
    ; <foldl(<add> (<char-to-digit> (<Fst>, r), <mul> (<Snd>, r)))>
        (chars, <char-to-digit> (char, r))

  // :: Char -> Int
  char-to-digit:
    (x, radix) -> result
      where <is-num> x
          ; <subt> (x, '0') => result
          ; <lt> (result, radix)

  char-to-digit:
    (x, 16) -> <add> (10, <subt> (x, 'a'))
      where <leq-leq> ('a', x, 'f')

  char-to-digit:
    (x, 16) -> <add> (10, <subt> (x, 'A'))
      where <leq-leq> ('A', x, 'F')

// term/opt
strategies

 /**
  * Maps a strategy over an optional term.
  */
 map-opt(s) = ?None() <+ Some(s)

 /**
  * Filters a strategy over an optional term.
  */
 filter-opt(s) = ?None() <+ ?Some(<id>); (s; !Some(<id>) <+ !None())

// term/placeholder
strategies

  /**
   * Returns the placeholder of an ATerm placeholder.
   *
   * e.g. applied to the placeholder <Foo()> this returns Foo().
   */
  get-placeholder =
    ?t; prim("SSL_getPlaceholder", t)

  /**
   * Creates a placeholder.
   *
   * e.g. applied to the Foo() this returns <Foo()>.
   */
  make-placeholder =
    ?t; prim("SSL_makePlaceholder", t)

  /**
   * Checks if the current term is a placeholder.
   *
   * Succeeds if it is.
   */
  is-placeholder =
    ?t; prim("SSL_isPlaceholder", t)

// term/properties
strategies

  /**
   * Succeeds if the first argument is a subterm of the second.
   *
   * A term x is a subterm of a term y if x = y
   * or if x is a subterm of one of the chuldren of y.
   *
   * @type  (a, b) -> (a, b)
   */
  is-subterm =
    ?(x, y); where(<oncetd(?x)> y)

  /**
   * Succeeds if the first argument (x) is a subterm of the second (y) and x is not y.
   *
   * @type  (a, b) -> (a, b)
   */
  is-proper-subterm =
    ?(x, y); not(eq); is-subterm

strategies

  /**
   * Succeeds if the first argument (x) is a superterm of the second (y).
   *
   * @type  (a, b) -> (a, b)
   */
  is-superterm =
    ?(x, y); where(<oncetd(?y)> x)

  /**
   * Succeeds if the first argument (x) is a superterm of the second (y) and x is not y.
   *
   * @type  (a, b) -> (a, b)
   */
  is-proper-superterm =
    ?(x, y); not(eq); is-superterm

strategies

  is-proper-subterm-set =
    ?([y|_], xs); where(<fetch(not(?y); oncetd(?y))> xs)

  is-proper-superterm-set =
    ?([x|_], ys); where(<fetch(<is-proper-superterm>(x,<id>))> ys)

strategies


  /**
   * Succeeds if the current term has no direct subterms.
   *
   * @type  a -> a
   */
  is-leaf =
    all(fail)

  /**
   * Succeeds if the current term has at least one direct subterm.
   *
   * @type  a -> a
   */
  is-inner-node =
    one(id)

// term/real
strategies

  /** Predicate to check if the current term is a real number.
   *
   * @type Real -> Real
   */
  is-real = ?x; prim("SSL_is_real",x)

  /** Compute cosine of a real number.
   *
   * @type Real -> Real
   */
  cos   = ?x; prim("SSL_cos",x)

  /** Compute sine of a real number.
   *
   * @type Real -> Real
   */
  sin   = ?x; prim("SSL_sin",x)

  /** Compute square of a real number.
   *
   * Note: The number sqrt is applied to must be non-negative, as complex
   * numbers are not supported.
   *
   * @type Real -> Real
   */
  sqrt  = ?x; prim("SSL_sqrt",x)

  /** Compute arc tangent of a par of real numbers. The result, when applied to
   * the pair (x,y), is the arc tangent of y/x, expressed as radians between
   * -PI and PI. The signs of the parameters x and y are used to determine the
   * correct quadrant.
   *
   * @type Real -> Real
   */
  atan2 = ?(x,y); prim("SSL_atan2",x,y)

  /** Convert a real to a string with default (maximal) precision.
   *
   * @type Real -> String
   */
  real-to-string        = ?x; prim("SSL_real_to_string",x)

  /** Convert a real to a string with given precision.
   *
   * The term argument prec specifies the number of digits after the
   * period is required. The result is rounded.
   *
   * Example: <real-to-string(2)> 12.124 => "12.12"
   *
   * @type prec Int
   * @type Real -> String
   */
  real-to-string(|prec) = ?x; prim("SSL_real_to_string_precision",x,prec)

  /** Construct a real from a string.
   *
   * Example: <string-to-real> "123.0e+02"
   *
   * @type String -> Real
   */
  string-to-real = ?x; prim("SSL_string_to_real",x)

  /** Construct a real from an int.
   *
   * @type Int -> Real
   */
//  real = ?x; prim("SSL_real",x)

// term/share
strategies

 /**
  * The strategy share defined in this module achieves such
  * an explicit sharing for arbitrary terms. The approach used by
  * the strategy is to first turn the term into its underlying
  * graph and then inlining those subterms that are not shared
  * (only occur once) or that cannot be shared in this way (upto
  * the needs of an application).
  */
  share(mkvar, always, mklet) =
  graph(mkvar);
  inline-graph(always, mklet)

strategies

  edge(mkvar)      = split(address; mkvar, all(address; mkvar))
  list-edge(mkvar) = split(address; mkvar, map(address; mkvar))

 /**
  * The graph of a term is obtained by turning each node
  * \verb|F(t1,...,tn)| into an edge \verb|(a, F(a1,...,an))|,
  * where \verb|a| is the address of the node and the \verb|ai|
  * are the addresses of its direct subterms. The \verb|mkvar|
  * parameter is used to embed the address in some constructor.
  * (If \verb|mkvar| is \verb|id|, nothing is done.)
  *
  * The first edge in the graph is the root of the tree. By
  * definition it is never shared. The graph can be turned into
  * one big let-expression with the root as its body. That is what
  * the first line of the definition of \verb|inline-graph|
  * accomplishes.
  *
  * Subsequently, nodes that are not shared, i.e., a pointer to
  * which only occurs once, can be inlined. Some nodes may always
  * have to be inlined (for application specific reasons). The
  * shape of such nodes is specified by the parameter
  * \verb|always|.  Edges that cannot be inlined are turned into a
  * let-binding the form of which is determined by the parameter
  * \verb|mklet|.
  *
  * After all graph edges have either been inlined or turned into
  * let-bindings the, now empty, \verb|GraphLet| is discarded and
  * replaced by its body.
  */

  graph(mkvar) =
    rec x(is-list; split(list-edge(mkvar), map(x); unions); MkCons
                <+ split(edge(mkvar), \ _#(xs) -> xs\ ; map(x); unions);
                   MkCons)

signature
  constructors
    GraphLet : List(Product([Int, Term])) * Term -> Term

strategies

  inline-graph(always, mklet) =
  \ [(a, t) | graph] -> GraphLet(graph, t) \ ;
  repeat(
          term-share-inline; (GraphLet([(id,always) | id], id) + term-share-dead) <+
          term-share-dead <+
          term-share-dont-inline(mklet));
  \ GraphLet([], t) -> t \

rules

  term-share-inline :
  GraphLet([(a, skel) | graph], t) ->
  GraphLet([(a, skel) | graph], t')
  where <oncetd((a -> skel))> t => t'

  term-share-dead :
  GraphLet([(a, skel) | graph], t) ->
  GraphLet(graph, t)
  where <not(is-subterm)> (a, t)

  term-share-dont-inline(mklet) :
  GraphLet([(a, skel) | graph], t) ->
  GraphLet(graph, <mklet>(a, skel, t))

// term/string
strategies

  /**
   * Scopes local-newname and local-new, which work by dynamic rule.
   */
  scope-local-new(s) = {| LocalNew, LocalNewAlpha : rules(LocalNewAlpha := 0);  s |}

  /**
   * Generates a locally unique new string with user-defined prefix
   * the form 's_d', where s is a string and d is a positive integer.
   * The produced string is *only* unique within the scope of
   * scope-local-new, and only based on previous calls to
   * local-newname/local-new. If you constructed a similar name by
   * hand it will not be avoided.
   *
   * The prefix comes in front of an increasing number, which is
   * separately maintained and started at 0 for each prefix.
   * The numbering is case-insensitive on the prefix.
   *
   * Examples (results are shown in comment)
   *   scope-local-new(
   *     <local-newname; debug> "a"        // produces "a_0"
   *   ; <local-newname; debug> "a"        // produces "a_1"
   *   ; <local-newname; debug> "A"        // produces "A_2"
   *   ; <local-newname; debug> "b"        // produces "b_0"
   *   ; <local-newname; debug> "b"        // produces "b_1"
   *   ; <local-newname; debug> "b_2"      // produces "b_2_0"
   *   ; <local-newname; debug> "b_2"      // produces "b_2_1"
   *   ; <local-newname; debug> "b_a"      // produces "b_a_0"
   *   ; <local-newname; debug> "b_a"      // produces "b_a_1"
   *   ; <local-newname; debug> "a_"       // produces "a__0"
   *   ; <local-newname; debug> "a_1"      // produces "a_1_0"
   *   )
   */
  local-newname = local-newname(|())

  /**
   * This version of local-newname uses the given context term as a "reentrant scope".
   * When given the same context term and name (within the same `scope-local-new` call), new
   * locally unique names are generated, but with a different context term the counter for the
   * prefix resets. The default context used by `local-newname`/0 is `()`.
   */
  local-newname(|context): prefix -> $[[prefix]_[number]]
      where key := (context, <lower-case> prefix)
          ; number := <LocalNew <+ !0> key
          ; number' := <int-add(|1)> number
          ; rules(LocalNew: key -> number')

  /**
   * Generates a locally unique new string of the form 'c_d',
   * where c is one char and d is a positive integer.
   * The produced string is *only* unique within the scope of
   * scope-local-new, and only based on previous calls to
   * local-newname/local-new. If you constructed a similar name by
   * hand it will not be avoided.
   *
   * Examples (results are shown in comment)
   *   scope-local-new(
   *     <local-new; debug>          // produces "a_0"
   *   ; <local-new; debug>          // produces "b_0"
   *   ; <local-new; debug>          // produces "c_0"
   *   ; <local-new; debug>          // produces "d_0"
   *   ; <local-new; debug>          // produces "e_0"
   *   ; <local-new; debug>          // produces "f_0"
   *   ; <local-new; debug>          // produces "g_0"
   *   ; <local-new; debug>          // produces "h_0"
   *   ; <local-new; debug>          // produces "i_0"
   *   ; <local-new; debug>          // produces "j_0"
   *   ; <local-new; debug>          // produces "k_0"
   *   ; <local-newname; debug> "f"  // produces "f_1"
   *   )
   * Note how the input to local-new is ignored. It does share
   * information with local-newname so the two don't generate
   * overlapping names within the same scope-local-new call.
   */
  local-new = local-new(|())

  /**
   * This version of local-new uses the given context term as a "reentrant scope".
   * When given the same context term (within the same `scope-local-new` call), new locally unique
   * names are generated, but with a different context term the counter resets. The default context
   * used by `local-new`/0 is `()`.
   */
  local-new(|context) =
    // use LocalNewAlpha to shift from ASCII character a to some letter in the alphabet
    ![<int-add(|<LocalNewAlpha>)> 'a']
    // Update LocalNewAlpha with increment modulo 26
  ; where(LocalNewAlpha; int-add(|1); if int-gt(|25) then !0 end; ?alpha; rules(LocalNewAlpha := alpha))
    // implode the letter + underscore list of characters to a string
  ; implode-string
    // apply local-newname to share information and not produce overlapping names between the two
  ; local-newname(|context)

  /**
   * @deprecated: Please use locally scoped new/newname instead.
   * This primitive is bad for deterministic and separate compilation
   * and is very difficult and costly to support. Currently may break
   * its uniqueness guarantee due to garbage collection on the JVM at
   * and inopportune time.
   *
   * Generates a unique new string of the form 'c_d',
   * where c is one char and d is a positive integer.
   */
  new = prim("SSL_new")

  /**
   * @deprecated: Please use locally scoped new/newname instead.
   * This primitive is bad for deterministic and separate compilation
   * and is very difficult and costly to support. Currently may break
   * its uniqueness guarantee due to garbage collection on the JVM at
   * and inopportune time.
   *
   * Generates a unique new string with user-defined prefix
   * the form 'sd', where s is a string and d is a positive integer.
   * The produced string is *always* unique across a program run.
   *
   * The prefix comes in front of an increasing number, which is
   * separately maintained and started at 0 for each prefix.
   *
   * Examples (results are shown in comment)
   *     <newname; debug> "a"        // produces "a0"
   *   ; <newname; debug> "a"        // produces "a1"
   *   ; <newname; debug> "a"        // produces "a2"
   *   ; <newname; debug> "b"        // produces "b0"
   *   ; <newname; debug> "b"        // produces "b1"
   *   ; <newname; debug> "b_2"      // produces "b_20"
   *   ; <newname; debug> "b_2"      // produces "b_21"
   *   ; <newname; debug> "b_a"      // produces "b_a0"
   *   ; <newname; debug> "b_a"      // produces "b_a1"
   *   ; <newname; debug> "a_"       // produces "a_0"
   *   ; <newname; debug> "a_1"      // produces "a_10"
   */
  newname = ?prefix; prim("SSL_newname", prefix)

  /**
   * Generates a unique new term.
   * May not necessarily be a string, depending on the platform.
   * May be slightly more efficient than a standard 'new.'
   *
   * @since 0.18
   */
  newterm =
    if-c-platform(prim("SSL_new"));
    if-java-platform(SRTS-EXT-newint)

  external SRTS-EXT-newint(|)

  /**
   * Predicate that checks if the supplied term is a string.
   *
   * @type String -> String
   */
  is-string  = ?x; prim("SSL_is_string", x)

  /**
   * Predicate that checks if the supplied term is a printable character.
   *
   * @type Char -> Char
   */
  is-char = is-int ; is-ascii

  /**
   * Implodes a list of chars to a string.
   *
   * @type List(Char) -> String
   */
  implode-string = ?x; prim("SSL_implode_string", x)

  /**
   * Explodes a String to a list of chars.
   *
   * @type String -> List(Char)
   */
  explode-string = ?x; prim("SSL_explode_string", x)

  /**
   * Wraps a strategy on a list of chars in a strategy on a string.
   *
   * @param List(Char) -> List(Char)
   * @type  String -> String
   */
  string-as-chars(s) =
      explode-string
    ; s
    ; implode-string

strategies

  /**
   * Concats a tuple of two Strings.
   *
   * @type String * String -> String
   */
  conc-strings =
     ?(_,_)   ; strcat
  <+ ?""#(xs) ; <concat-strings>xs

  /**
   * Concats a tuple of two Strings.
   *
   * @warning  doesn't accept tuples with more than two string.
   * @type     String * String -> String
   * @inc      strcat-1
   * @inc      strcat-2
   * @inc      strcat-3
   * @inc      strcat-4
   */
  strcat =
    ?(str1, str2); prim("SSL_strcat", str1, str2)

  /**
   * Concats a list of Strings
   *
   * @type List(String) -> String
   * @inc      concat-strings-1
   * @inc      concat-strings-2
   * @inc      concat-strings-3
   * @inc      concat-strings-4
   */
  concat-strings =
    ?strings; prim("SSL_concat_strings", strings)

strategies

  /**
   * Returns the number of characters in a string.
   *
   * @type String -> Int
   */
  string-length =
    strlen

  /**
   * Returns the number of characters in a string.
   *
   * @type String -> Int
   * @inc      strlen-1
   * @inc      strlen-2
   * @inc      strlen-3
   */
  strlen =
    ?s; prim("SSL_strlen", s)

strategies

  /**
   * Escapes double quotes, backslash and linefeed to C like escape sequences.
   *
   * @type String -> String
   * @inc  escape-test1
   */
  escape = string-as-chars(escape-chars)

  /**
   * Escapes double quotes, backslash and linefeed to C like escape sequences.
   *
   * @type List(Char) -> List(Char)
   */
  escape-chars =
    escape-chars(Escape)

  /** @internal */
  escape-chars(s) =
    rec x(
       (s; [id, id | x])
    <+ [id | x]
    <+ []
    )

  /**
   * Unescapes double quotes, backslash, linefeed and tabs.
   *
   * @type String -> String
   * @inc unescape-test1
   * @inc unescape-test2
   * @inc unescape-test3
   * @inc unescape-test4
   */
  unescape = string-as-chars(unescape-chars)

  /**
   * Unescapes characters using a specified unescape strategy.
   *
   * @param List(Char) -> List(Char)
   * @type  List(Char) -> List(Char)
   */
  unescape-chars(s) =
    rec x(
      try(s)
    ; ([id | x] <+ [])
    )

  /**
   * Unescapes double quotes, backslash, linefeed and tabs.
   *
   * @type List(Char) -> List(Char)
   */
  unescape-chars =
    unescape-chars(UnEscape)

  /**
   * @type List(Char) -> List(Char)
   */
  Escape =
      Escape-double-quote
    + Escape-backslash
    + Escape-linefeed
    + Escape-carriage-return

  /** @internal */
  Escape-double-quote    : ['"'  | cs ] -> ['\', '"'  | cs ]

  /** @internal */
  Escape-single-quote    : ['\'' | cs ] -> ['\', '\'' | cs ]

  /** @internal */
  Escape-backslash       : ['\'  | cs ] -> ['\', '\'  | cs ]

  /** @internal */
  Escape-linefeed        : ['\n' | cs ] -> ['\', 'n'  | cs ]

  /** @internal */
  Escape-carriage-return : ['\r' | cs ] -> ['\', 'r'  | cs ]

  /**
   * @type List(Char) -> List(Char)
   */
  UnEscape =
      UnEscape-double-quote
    + UnEscape-backslash
    + UnEscape-linefeed
    + UnEscape-tab
    + UnEscape-carriage-return

  /** @internal */
  UnEscape-double-quote    : ['\', '"'  | cs ] -> ['"'  | cs ]

  /** @internal */
  UnEscape-single-quote    : ['\', '\'' | cs ] -> ['\'' | cs ]

  /** @internal */
  UnEscape-backslash       : ['\', '\'  | cs ] -> ['\'  | cs ]

  /** @internal */
  UnEscape-carriage-return : ['\', 'r'  | cs ] -> ['\r' | cs ]

  /** @internal */
  UnEscape-linefeed        : ['\', 'n'  | cs ] -> ['\n' | cs ]

  /** @internal */
  UnEscape-tab             : ['\', 't'  | cs ] -> ['\t' | cs ]

  /** @internal */
  UnEscape(|c) :
    ['\', c | cs ] -> [c  | cs ]

strategies

  /** @internal */
  escape(esc : (List(String) -> List(String)) * List(String) -> List(String) ) =
    explode-string;
    rec x(esc(x) <+ [id | x] <+ []);
    implode-string

  /**
   * @inc escape-test2
   */
  cify = escape(Cify)

  /** @internal */
  uncify = escape(UnCify)

  /** @internal */
  UnCify(x) = UnCify1(x) <+ UnCify2(x) <+ UnCify3(x)

rules

  /** @internal */
  Cify(x) : ['\'' | cs] -> ['_', 'p', '_' | <x>cs]

  /** @internal */
  Cify(x) : ['-'  | cs] -> ['_'           | <x>cs]

  /** @internal */
  Cify(x) : ['_'  | cs] -> ['_', '_'      | <x>cs]

  /** @internal */
  Cify(x) : ['"'  | cs] -> ['_', 'q', '_' | <x>cs]

  /** @internal */
  Cify(x) : ['\'  | cs] -> ['_', 'b', '_' | <x>cs]

  /** @internal */
  UnCify1(x) : ['_', 'b', '_' | cs] -> ['\'  | <x>cs]

  /** @internal */
  UnCify1(x) : ['_', 'q', '_' | cs] -> ['"'  | <x>cs]

  /** @internal */
  UnCify1(x) : ['_', 'p', '_' | cs] -> ['\'' | <x>cs]

  /** @internal */
  UnCify2(x) : ['_', '_'      | cs] -> ['_'  | <x>cs]

  /** @internal */
  UnCify3(x) : ['_'           | cs] -> ['-'  | <x>cs]

/**
 * Quoting Literals
 */
strategies

  /**
   * param  () -> Char
   * @type  String -> String
   */
  quote(c) = string-as-chars(quote-chars(c))

  /**
   * param  () -> Char
   * @type  List(Char) -> List(Char)
   */
  quote-chars(c) = <quote-chars> (<c> (), <id>)

  /**
   * @type Char * List(Char) -> List(Char)
   */
  quote-chars:
    (c, chars) -> <conc> ([c | chars], [c])

  /**
   * Adds single quotes to the start and end of a list
   * of characters.
   *
   * @type List(Char) -> List(Char)
   */
  single-quote-chars = <quote-chars> ('\'', <id>)

  /**
   * Adds double quotes to the start and end of a
   * list of characters.
   *
   * @type List(Char) -> List(Char)
   */
  double-quote-chars = <quote-chars> ('"' , <id>)

  /**
   * @inc single-quote-test
   */
  single-quote = string-as-chars(single-quote-chars)

  /**
   * Adds double quotes to the start and end of
   * a string.
   *
   * @type String -> String
   */
  double-quote = string-as-chars(double-quote-chars)

/**
 * Unquoting
 */
strategies

  /**
   * Removes the first and last character of a string.
   * The characters must satisfy s.
   *
   * @param Char ->? _
   * @type  String -> String
   */
  unquote(s) =
    string-as-chars(unquote-chars(s))

  /**
   * Removes the first and last character of a string.
   * The first character must satisfy s1.
   * The last character must satisfy s2.
   *
   * @param  Char ->? _
   * @param  Char ->? _
   * @type   String -> String
   */
  unquote(s1, s2) =
    string-as-chars(unquote-chars(s1, s2))

  /**
   * Removes the first and last character of a list of characters.
   * The characters must satisfy s.
   *
   * @param  Char ->? _
   * @type   List(Char) -> List(Char)
   */
  unquote-chars(s) =
    unquote-chars(s, s)

  /**
   * Removes the first and last character of a list of characters.
   * The first character must satisfy s1.
   * The last character must satisfy s2.
   *
   * @param  Char ->? _
   * @param  Char ->? _
   * @type   List(Char) -> List(Char)
   */
  unquote-chars(s1, s2) =
      where(Hd;   s1)
    ; where(last; s2)
    ; Tl
    ; init

  /**
   * Removes single quotes from the start and end of a list
   * of characters. Fails if the list is not properly
   * quoted.
   *
   * @type  List(Char) -> List(Char)
   */
  un-single-quote-chars = unquote-chars(?'\'')

  /**
   * Removes double quotes from the start and end of a list
   * of characters. Fails if the list is not properly
   * quoted.
   *
   * @type  List(Char) -> List(Char)
   */
  un-double-quote-chars = unquote-chars(?'"' )

  /**
   * Removes single quotes from the start and end of a string
   * Fails if the string is not properly quoted.
   *
   * @type  String -> String
   */
  un-single-quote = string-as-chars(un-single-quote-chars)

  /**
   * Removes double quotes from the start and end of a string
   * Fails if the string is not properly quoted.
   *
   * @type  String -> String
   */
  un-double-quote = string-as-chars(un-double-quote-chars)

strategies

 /** Predicate that checks if a string is double quoted, i.e. quoted
  * with double quotation marks (").
  *
  * @inc is-double-quote 1
  * @inc is-double-quote 2
  * @inc is-double-quote 3
  * @inc is-double-quote 4
  * @inc is-double-quote 5
  * @inc is-double-quote 6
  *
  * @type   String -> String
  */
  is-double-quoted =
    is-quoted(|'"')

  /**
   * Predicate that checks a string is quoted with single quotes.
   *
   * @type  String -> String
   */
  is-single-quoted =
    is-quoted(|'\'')

  /**
   * Predicate that checks if a character list is double quoted. That
   * is, if the first and last character are both double quotes.
   *
   * @type List(Char) -> List(Char)
   */
  is-double-quoted-chars =
    is-quoted-chars(|'"')

  /**
   * Predicate that checks if a character list is single quoted. That is,
   * if the first and last character are both single quotes.
   *
   * @type List(Char) -> List(Char)
   */
  is-single-quoted-chars =
    is-quoted-chars(|'\'')

  /**
   * Predicate that checks if a string is quoted with the given character.
   *
   * The character c is the quotation character to check for.
   *
   * @param Char
   * @type  String -> String
   */
  is-quoted(|c) =
    where(
      explode-string
      ; is-quoted-chars(|c)
    )

  /**
   * Predicate that checks if a list of characters is quoted with
   * the character given by the term argument. That is, if the
   * first and last character of the list are both equal to c.
   *
   * @param Char
   * @type List(Char) -> List(Char)
   */
  is-quoted-chars(|c) =
    where(?[c | <last>]; ?c)

strategies

  /**
   * @obsolete use string-to-int
   */
  string-to-num =
    obsolete(!"string-to-num; use string-to-int")
    ; string-to-int

strategies

 /**
  * Converts all characters of this string to lower case
  *
  * @type  String -> String
  */
  lower-case = string-as-chars(lower-case-chars)

 /**
  * Converts all characters of this string to upper case
  *
  * @inc upper-case-test
  */
  upper-case = string-as-chars(upper-case-chars)

  /**
   * Converts a list of characters to lower case.
   *
   * Example: <explode-string ; lower-case-char ; implode-string> "STRATEGO" => "stratego"
   *
   * @type  List(Char) -> List(Char)
   */
  lower-case-chars = map(to-lower)

  /**
   * Converts a list of characters to upper case.
   *
   * Example: <explode-string ; upper-case-chars ; implode-string> "stratego" => "STRATEGO"
   *
   * @type  List(Char) -> List(Char)
   */
  upper-case-chars = map(to-upper)

strategies

  /**
   * Breaks a string into tokens.
   *
   * Given a list of possible delimiters (characters that
   * separate tokens), string-tokenize returns a list of
   * tokens for a given string.
   *
   * @param List of separate characters
   * @type  String -> List(String)
   */
  string-tokenize(|sepchars) =
    string-tokenize({c: ?c; <fetch(?c)> sepchars})

  /** @internal */
  string-tokenize(sep) =
      explode-string
    ; list-tokenize(sep)
    ; map(implode-string)

  /**
   * @inc   tokenize-test1
   * @inc   tokenize-test2
   * @inc   tokenize-test3
   * @inc   tokenize-test4
   * @inc   tokenize-test5
   *
   * @type  (List(Char), String) -> List(String)
   */
  string-tokenize =
      ?(sepchars, <id>)
    ; string-tokenize(|sepchars)

strategies

 /**
  * @param s  () -> Char
  * @type String * Int -> String
  * @inc  padd-with-test
  */
  padd-with(s) =
    <align-right> (<s> (), <Fst>, <Snd>)

  /**
   * Remove padding from a string.
   *
   * @internal
   * @since 0.18
   */
  remove-padding =
    string-as-chars(
      split-at-newlines
    ; where(padding := <length> <Hd>)
    ; remove-padding(|padding, padding)
    ; at-last(rtrim(' ' + '\t'))
    ; separate-by(|['\n'])
    ; concat
    )

  internal remove-padding(|max, n) =
    where(<leq> (n, 0))
  ; [id | remove-padding(|max, max)]
  <+
    [?[' '  | <id>] | id]
  ; remove-padding(|max, <dec> n)
  <+
    [?['\t' | <id>] | id]
  ; remove-padding(|max, <subt> (n, 4))
  <+
    where(max' := <subt> (max, n))
  ; [id | remove-padding(|max', max')]
  <+
    []

  /**
   * @type Char * String * Int -> String
   */
  align-right :
    (c, s, n) -> <conc-strings> (add, s)
      where <align-helper(|c, n)> s => add

  /**
   * @type Char * String * Int -> String
   */
  align-left :
    (c, s, n) -> <conc-strings> (s, add)
      where <align-helper(|c, n)> s => add

  /**
   * @type Char * String * Int -> String
   */
  align-center :
    (c, s, n) -> <concat-strings> [add-before, s, add-after]
      where <string-length> s => l
          ; <subt> (n, l) => whitespace
          ; <   even
              < div2; Dupl
              + dec; div2; Dupl; (inc, id)
            > whitespace => (before, after)
          ; <align-helper(|c, <add> (l, before))> s => add-before
          ; <align-helper(|c, <add> (l, after ))> s => add-after

      /**
       * @param c  Char
       * @param n  Int
       * @type String -> String
       */
      align-helper(|c, n) =
        string-length
        ; <subt> (n, <id>)
        ; if pos then
            <copy-char> (<id>, c)
          else
            !""
          end

      div2 = <div> (<id>, 2)

rules

  /** @internal */
  SplitInit : x -> ([], [], x)

  /** @internal */
  SplitExit :
  (xs, cs, []) ->
  <reverse> [<reverse; implode-string> cs|xs]

  /** @internal */
  SplitNext :
  (xs, cs, [32|ys]) ->
  ([<reverse; implode-string> cs | xs], [], ys)

  /** @internal */
  SplitNext :
  (xs, cs, [y|ys]) -> (xs, [y|cs], ys)
  where <not(eq)> (y, 32)

strategies

  /**
   * Splits a string at each occurrence of a whitespace. The
   * resulting list of string does not contain any of the
   * whitespaces. Two adjacent whitespaces will result in
   * an empty string in the result.
   *
   * Example: <split-at-space> "foo  bar" => ["foo", "", "bar"]
   *
   * @type String -> List(String)
   */
  split-at-space =
    explode-string;
    SplitInit;
    rec x(SplitExit <+ SplitNext; x)

 /**
  * @inc split-at-dot-test
  */
  split-at-dot =
    split(![],explode-string)
  ; rec r(   \(int',[46|frac]) -> (int',frac)\
    <+ \(int',[i|rest])  -> <r>(<at-end(![i])>int',rest)\
    <+ (id,Nil))
  ; (implode-string,implode-string)

  // fails if sub isn't in l
 /**
  * @inc split-before-test
  */
  split-before = ?(l,sub1);
        <explode-string>sub1 => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( \ x@(_,x') -> x where <left-match>(x',sub') \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
  (implode-string,implode-string)

  // results in (l,"") if sub isn't in l
 /**
  * @inc split-after-test
  */
  split-after = ?(l,sub1);
        <explode-string>sub1 => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( (id,[]) <+
               \ (x,x') -> (<conc>(x,sub'),<left-match>(x',sub')) \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
  (implode-string,implode-string)


  /**
   * Succeeds if the string produced by s is a substring
   * of the argument string.
   *
   * @param _ -> String
   * @type String -> _
   */
  is-substring(s) =
    explode-string;?long;
    s;explode-string => sub1;

    (<eq>(sub1,long)
  <+
    <rec r({a,xs:
      ?a@[_|xs]; (<left-match>(a,sub1) <+ <r>xs)
    })>long)

  // <copy-char> (3, 32) -> "   "
 /**
  * @inc copy-char-test
  */
  copy-char =
    copy; implode-string

  /**
   * Sorts a list of strings lexicographically, ignoring case, ascending.
   *
   * @inc string-sort-test-a
   * @inc string-sort-test-b
   * @inc string-sort-test-c
   *
   * @type List(String) -> List(String)
   */
  string-sort =
      map(explode-string)
    ; qsort(string-lt)
    ; map(implode-string)

  /**
   * Sorts a list of strings lexicographically ignoring case, descending.
   *
   * @type List(String) -> List(String)
   */
  string-sort-desc =
      map(explode-string)
    ; qsort(string-gt)
    ; map(implode-string)

strategies

  /**
   * Compares two strings or lists of characters lexicographically and succeeds if
   * the first one is larger than the second, ignoring case.
   *
   * @type  (List(Char), List(Char)) -> 1
   * @type  (String, String)         -> 1
   */
  string-gt =
    try((explode-string, explode-string));
    strcasecmp; ?1

  /**
   * Compares two strings or lists of characters lexicographically and succeeds if
   * the first one is smaller than the second, ignoring case.
   *
   * @type  (List(Char), List(Char)) -> 1
   * @type  (String, String)         -> 1
   */
  string-lt =
    try((explode-string, explode-string));
    strcasecmp; ?-1

  /**
   * Succeeds if the first String starts with the second String.
   *
   * If the strategy succeeds, the current term is left untouched.
   *
   * Example: <string-starts-with(|"foo")> "foobar"
   *
   * @type  String -> String
   */
  string-starts-with(|start) =
    where(<left-match> (<explode-string>, <explode-string> start))

  /**
   * Succeeds if the first String ends with the second String.
   *
   * If the strategy succeeds, the current term is left untouched.
   *
   * Example: <string-ends-with(|"bar")> "foobar"
   *
   * @type  String -> String
   */
  string-ends-with(|e) =
    where(<right-match> (<explode-string>, <explode-string> e))


  /**
   * Succeeds if the first list of terms starts with the second list of terms.
   *
   * Returns the suffix of the first list that is not matched.
   *
   * @type  (List(a), List(a)) -> List(a)
   */
  left-match =
      rec r(
         \ ([l|ls],[l|rs]) -> <r> (ls,rs) \
      <+ (id,[])
      )
    ; Fst

  /**
   * Succeeds if the first list of terms ends with the second list of terms.
   *
   * Returns the prefix of the first list that is not matched.
   *
   * @type  (List(a), List(a)) -> List(a)
   */
  right-match =
      (reverse, reverse)
    ; left-match
    ; reverse

 /**
  * @inc strcmp
  */
  strcmp = rec r(
       \([x|xs],[x|ys]) -> <r>(xs,ys)\
    <+ \([],[]) -> 0\
    <+ \([x|_],[y|_]) -> -1 where <lt>(x,y)\
    <+ \([],[_|_]) -> -1\
      // these last two cases are handled faster by just !1
      //  <+ \([_|_],[]) -> 1\
      //  <+ \([x|_],[y|_]) -> 1\
    <+ !1
    )

  /**
   * Compares the n first characters of two character lists, n
   * is given by the last argument. If the two lists are identical,
   * the integer 0 is returned, otherwise the integer 1 is returned.
   *
   * @type List(Char) * List(Char) * Int -> Int
   */
  strncmp = rec r
  (  \(_,_,0) -> 0\
  <+ \([x|xs],[x|ys],i) -> <r>(xs,ys,<subt>(i,1))\
  <+ \([],[],_) -> 0\
  <+ \([x|_],[y|_],_) -> -1 where <lt>(x,y)\
  <+ \([],[_|_],_) -> -1\
  <+ !1
  )

  /**
   * Compares two lists of characters lexicographically, ignoring case.
   *
   * Returns:
   *   -1 if first is smaller than the second.
   *   0  if the strings are equal.
   *   1  if the first is larger than the second.
   *
   * @type (List(Char), List(Char)) -> -1, 0,1 or -1.
   */
  strcasecmp = rec r
  (  \([x|xs],[y|ys]) -> <r>(xs,ys) where <case-char(eq)>(x,y)\
  <+ \([],[]) -> 0\
  <+ \([x|_],[y|_]) -> -1 where <case-char(lt)>(x,y)\
  <+ \([],[_|_]) -> -1\
  <+ !1
  )

strategies

  /**
   * Splits a string into a list of tokens, including the empty ones.
   *
   * This strategy differs from string-tokenize in that it produces an empty ""
   * token when two separator chars are encountered, or after a final separator.
   *
   * Example:
   *  <string-tokenize-keep-empty(|['\n'])> "fu\n\nbar\n" => ["fu","","bar",""]
   *
   * @param The list of characters that may separate two tokens.
   * @type sepChars [char]
   * @type    string -> [string]
   * @since 0.9.5
   */
  string-tokenize-keep-empty(|sepChars) =
    explode-string
    ; rec x( ( split-fetch(<elem> (<id>, sepChars))
             ; \ (tchars, cs) -> [tchars|<x> cs] \ )
          <+ ![<id>])
    ; map(implode-string)


  /**
   * Splits a string into a list of tokens, keeping the separating elements as
   * 1-char-strings within the results list, *and* also keeping the empty
   * "" tokens.
   *
   * Example:
   *  <string-tokenize-keep-all(|['\n'])> "fu\n\nbar\n" => ["fu","\n","","\n","bar","\n",""]
   *
   * @param The list of characters that may separate two tokens.
   * @type sepChars [char]
   * @type    string -> [string]
   * @since 0.9.5
   */
  string-tokenize-keep-all(|sepChars) =
    explode-string
    ; rec x( ( split-fetch-keep(where(<elem> (<id>, sepChars)))
             ; \ (tchars, s, cs) -> [tchars|[[s]|<x> cs]] \ )
          <+ ![<id>])
    ; map(implode-string)

  /**
   * Gets all newline(\n, \r\n or \r)-separated lines in a string.
   * If the string is ended by a newline, the last element of the returned list
   * is the empty string.
   *
   * @type string -> [string]
   * @since 0.9.4
   */
  get-lines =
    explode-string
    ; split-at-newlines
    ; map(implode-string)

  internal split-at-newlines =
    at-suffix(
       (['\n'       | tl] -> [])
    <+ (['\r', '\n' | tl] -> [])
    <+ (['\r'       | tl] -> [])
    )
    ; ![<id> | <split-at-newlines> tl]
    <+ ![<id>]

  /**
   * Applies a strategy to all lines in a string.
   *
   * Lines are expected to be separated by a single '\n'.
   * The last line may be ended by a newline, or not. In the former case, the
   * last line in the resulting string will also be ended by a newline,
   * otherwise not.
   * Initial or intermediate newlines are preserved.
   * The strategy is applied to each line (even the empty ones), *excluding*
   * the newline character. The newline is appended again after application of s
   *
   * @param The strategy that should be applied to each line.
   * @type s string -> string
   * @type   string -> string
   * @since 0.9.4
   */
  all-lines(s) =
    is-string
  ; string-tokenize-keep-empty(|['\n'])
  ; at-last( \ [""] -> [] \  // Do not run s on a final empty line.
           < where(!["\n"] => laststring) // ... but remember that the second last line was delimited by a newline
           + where(![] => laststring))    // ... or not.
  ; map(s)
  ; <separate-by> ("\n", <id>)
  ; <conc> (<id>, laststring) // Restore the final newline, if there was one.
  ; concat-strings


  /**
   * Makes one newline-separated string out of a list of strings.
   *
   * @since 0.9.4
   */
  lines =
    separate-by(!"\n")
  ; <conc> (<id>, ["\n"])
  ; concat-strings

  /**
   * Indents every line in a string with spaces.
   *
   * @param The number of spaces to be put in front of every line.
   * @type n int
   * @type string -> string
   * @since 0.9.4
   */
  indent-text(|n) =
    where(<copy-char> (n, ' ') => prefix)
  ; prefix-lines(|prefix)

  /**
   * Prefixes all lines in a string with a string.
   *
   * @param The prefix.
   * @type p string
   * @type   string -> string
   * @since 0.9.4
   */
  prefix-lines(|p) =
    all-lines(<conc-strings> (p, <id>))

strategies

  /**
   * Trims leading characters from a string. The characters to
   * to trim are given by the strategy argument.
   *
   * Removes from the left-hand side all characters matched by
   * strategy s.
   *
   * Example:  <ltrim-chars(?' ')> "   fred  " => "fred  "
   *
   * @param should match all characters to be removed
   * @type String -> String
   * @since 0.9.5
   */
  ltrim-chars(s) = string-as-chars(ltrim(s))

  /**
   * Trims trailing characters from a string.
   *
   * Removes from the right-hand side all characters matched by
   * strategy s.
   *
   * Example: <rtrim-chars(?' ')> "   fred  " => "   fred"
   *
   * @param should match on all characters to be removed
   * @type String -> String
   * @since 0.9.5
   */
  rtrim-chars(s) = string-as-chars(rtrim(s))

  /**
   * Trims leading and trailing characters from a string. The
   * characters to trim is given by the strategy argument.
   *
   * Removes from both ends all characters matched by strategy
   * s.
   *
   * Example:  <trim-chars(?' ')>  "   fred  " => "fred"
   *
   * @param should match all characters to be removed
   * @type String -> String
   * @since 0.9.5
   */
  trim-chars(s)  = string-as-chars(trim(s))

  /**
   * Succeeds if the character is whitespace.
   *
   * Whitespace is a space (32), or a tab (9)
   *
   * @type Char -> Char
   * @since 0.9.5
   */
  is-whitespace = test('\t' + ' ')

  /**
   * Trims all trailing whitespace in a (single-line) string.
   *
   * @type String -> String
   * @since 0.9.5
   */
  trim-trailing-whitespace =
    rtrim-chars(is-whitespace)

  /**
   * Trims all leading whitespace in a (single-line) string.
   *
   * @type String -> String
   * @since 0.9.5
   */
  trim-leading-whitespace =
    ltrim-chars(is-whitespace)

  /**
   * Trims all trailing and leading whitespace in a (single-line) string.
   *
   * @type String -> String
   * @since 0.9.5
   */
  trim-whitespace =
    trim-chars(is-whitespace)

strategies

  /**
   * Some shuffling strategies
   * @internal
   */
  shuffle-forced =
      where(length; <gt> (<id>, 1))
    ; where(at-suffix(?[x,y|xs]; where(not(<eq> (x, y)))))
    ; rec x({orig: ?orig; shuffle; (where(<eq> (orig, <id>)) < x + id)})
    <+ id

  /** @internal */
  shuffle =
      where(is-list)
    ; map(!(<next-random> (), <id>))
    ; sort-list(SortL((Fst, Fst); gt))
    ; map(Snd)

  /** @internal */
  shuffle-word-mids =
      string-tokenize-keep-all(|[' ', '.', ','])
    ; map(shuffle-word-mid)
    ; concat-strings

  /** @internal */
  shuffle-word-mid =
     where(is-string)
   ; (where(strlen; <lt> (<id>, 3))
   <+ explode-string
   ; ?[i|cs]
   ; <reverse> cs
   ; ?[l|mid]
   ; where(<shuffle-forced; reverse> mid => shuffledmid)
   ; <concat; implode-string> [[i],shuffledmid, [l]])

strategies

  /**
   * @inc is-alphanum-test
   */
  is-alphanum = is-num + is-alpha

  /**
   * Succeeds if the character is part of the lowercase or
   * uppercase alphabet.
   *
   * @type Char -> Char
   */
  is-alpha = is-upper + is-lower

  /**
   * Succeeds if applied to a character that is a hexidecimal
   * digit, i.e. either of the characters in the range '0'-'9'
   * or 'A'-'F' or 'a'-'f'.
   *
   * @type Char -> Char
   */
  is-hexnum =
      is-char
    ; (
        is-num
      + where(<leq-leq> ('a', <id>, 'f'))
      + where(<leq-leq> ('A', <id>, 'F'))
      )

  /**
   * @inc is-num-test
   * @inc is-not-num-test
   */
  is-num =
    where(<leq-leq> ('0', <id>, '9'))

  /**
   * Succeeds if this character is upper-case.
   *
   * @type Char -> Char
   */
  is-upper =
    where(<leq-leq> ('A', <id>, 'Z'))

  /**
   * Succeeds if this character is lower-case.
   *
   * @type Char -> Char
   */
  is-lower =
    where(<leq-leq> ('a', <id>, 'z'))

  /**
   * Succeeds if this string only contains printable ASCII characters.
   *
   * The letters 32 through 126, in total 96 characters, are defined
   * as printable.
   *
   * @type Char -> Char
   */
  is-ascii =
    where(<leq-leq> ( 32, <id>, 127))

  /**
   * Applies a strategy to the upper-case variants of two characters.
   *
   * This is useful for doing case-insenstive operations.
   *
   * @param (Char, Char) -> a
   * @type  (Char, Char) -> a
   */
  case-char(s) = (to-upper, to-upper); s

  /**
   * Ensures that a character is upper-case.
   *
   * This strategy returns the input character if this
   * character is already upper-case.
   *
   * @type Char -> Char
   */
  to-upper =
    is-lower < <subt> (<id>, 32) + id

  /**
   * Ensures that a character is lower-case.
   *
   * This strategy returns the input character if this
   * character is already lower-case.
   *
   * @type Char -> Char
   */
  to-lower = is-upper < <add>  (<id>, 32) + id

  /**
   * Replaces one substring with another in a string.
   *
   * Example: <string-replace(|"foo", "bar")> "foobarfoo" gives "barbarbar"
   *
   * @param old - the old substring which is to be excised
   * @param new - the new subtring which is to be inserted
   * @type String -> String
   *
   * @author Karl Trygve Kalleberg <karltk@stratego.org>
   */
  string-replace(|old, new) =
      !([], <explode-string>, <explode-string> old)
    ; internal-string-replace(|<explode-string> old, <explode-string ; reverse> new)
    ; reverse
    ; implode-string

strategies

  /** @internal */
  internal-string-replace(|old, new) =
    ?(pre, [ hd | tl ], c)
    ; (
        !c => [hd | ctl]
        ; !(pre, tl, ctl)
        ; internal-string-replace-found(|old, new)
        ; internal-string-replace(|old, new)
       <+
          !([ hd | pre ], tl, c)
        ; internal-string-replace(|old, new)
      )

  /** @internal */
  internal-string-replace(|old, new):
    (pre, [], _) -> pre

  /** @internal */
  internal-string-replace-found(|old, new) =
    ?(pre, [ hd | tl ], c)
    ; !c => [ hd | ctl ]
    ; !(pre, tl, ctl)
    ; internal-string-replace-found(|old, new)

  /** @internal */
  internal-string-replace-found(|old, new):
    (pre, rest, []) -> (<conc> (new, pre), rest, old)

  /**
  * @internal
  * Used by desugaring of string interpolation $[... [x] ...]
  */
  internal-ensure-as-string =
    concat-strings(|)
    <+ is-string(|)
    <+ int-to-string(|)
    <+ real-to-string(|)
    <+ { x, y :
      ?x
      ; prim("SSL_stacktrace_get_all_frame_names",|); ?[ _ | y]
      ; !y
      ; report-failure(|"Internal error: escaped term in string quotation is not a string", x)
      }

  /**
  * @internal
  * Used by desugaring of string interpolation $[... [x] ...]
  */
  internal-string-interpolation(|t, padded_s) = <internal-ensure-as-string; string-replace(|"\n", padded_s)> t

// term/zip
strategies

  /** Zips a two-element tuple of structurally similar terms recursively by
   * using the strategy leaf to detect leaves and node to post-transform
   * the result
   *
   * Example: <term-zip(add, id)> (N(1, N(2)), N(2, N(3))) => N(3,N(5))
   *
   * @param leaf       c -?> d
   * @param node       d -> e
   * @type             Tuple(a(c),a(c)) -> a(e)
   * @see term-zip
   */
  pair-term-zip-bu(l, node) =
    rec x(l <+ TermZip(x); node)

rules

  /** Zips the argument lists of two terms of the same type, given as
   * a two element tuple, using strategy s to combine each pair.
   *
   * Example: <TermZip(id)> (Foo(1,2,3),Foo(4,5,6)) => Foo((1,4),(2,5),(3,6))
   *
   * @type s           Tuple(a,b) -> c
   * @type             Tuple(a,a) -> a
   * @see zip
   * @see TermTupleZip
   */
  TermZip(s) :
    (f#(xs), f#(ys)) -> f#(<zip(s)>(xs, ys))

strategies

  /** Zips a tuple of structurally similar terms recursively by using the
   * strategy leaf to detect leaves and node to post-transform the result
   *
   * Example: <term-zip(add, id)> (N(1, N(2)), N(2, N(3))) => N(3,N(5))
   *
   * @param leaf       c -?> d
   * @param node       d -> e
   * @type             Tuple(a(c),a(c)) -> a(e)
   */
  term-zip(l, node) =
    rec x(l <+ TermTupleZip(x); node)

  /** Zips the argument lists of an arbitrary length tuple of terms of the
   * same type, using using strategy s to combine each pair. Note that
   * all terms in the tuple must use the same constructor: both the name
   * and arity must be equal.
   *
   * Example: <TermZip(id)> (Foo(1,2),Foo(4,5),Foo(6,7)) => Foo((1,4,6),(2,5,7))
   *
   * @type s           Tuple(a,b) -> c
   * @type             Tuple(a,a) -> a
   * @see zip
   */
  TermTupleZip(s) =
    tmap({xs: ?f#(xs); !xs});
    tuple-zip(s);
    \ xs -> f#(xs) \

// util/config/common
strategies

  /**
   * Get the value for the specified key from the config table.
   * The key is the current term.
   */
  get-config =
    <table-get> ("config", <id>)

  /**
   * Get all values of config keys for which 'pred' succeeds.
   * The current term is ignored.
   *
   * @returns The list of values for the keys that satisfy pred.
   * @param   Is applied to the keys of the config table.
   * @type  _ -> List(b)
   */
  get-configs(pred) =
    <table-getlist> "config"
    ; filter((pred,id); Snd)

  /**
   * Get all config keys for which pred succeeds
   *
   * @returns  The list of keys that satisfy pred.
   * @param    Is applied to the keys of the config table.
   * @type     _ -> List(a)
   */
  get-config-keys(pred) =
    <table-getlist> "config"
    ; filter((pred,id); Fst)

strategies

  /**
   * Set an entry (key and value) in the config table.
   *
   * @type (a, b) -> _
   */
  set-config =
    ?(key, val)
    ; <table-put> ("config", key, val)

  /**
   * Remove the entry of the specified key from the config table.
   *
   * @type (a, b) -> _
   */
  rm-config =
    ?key
    ; <table-remove> ("config", key)

  /**
   * Adds an entry to the config table if it does not exist, or
   * removes the entry if it does already exist in the config table.
   *
   * @type (a, b) -> _
   */
  toggle-config =
    ?(key, val)
    ; if <get-config> key then
        <table-remove> ("config", key)
      else
        <set-config> (key, val)
      end

  /**
   * Extends the list of values of the specified key with new values.
   * The values are added in front of the current list.
   *
   * @type (a, List(b)) -> _
   */
  extend-config =
    ?(key, val)
    ; <table-put> ("config", key, <conc> (val, <get-config <+ ![]> key))

  /**
   * Extends the list of values of the specified key with new values.
   * The values are added to the end of the current list.
   *
   * @type (a, List(b)) -> _
   */
  post-extend-config =
    ?(key, val)
    ; <table-put> ("config", key, <conc> (<get-config <+ ![]> key, val))

  /**
   * Evaluates a strategy f if and only if the program is compiled to Java.
   */
  if-java-platform(s) = // implemented by the compiler
    s

  /**
   * Evaluates a strategy f if and only if the program is compiled to C.
   */
  if-c-platform(s) = // implemented by the compiler
    s

// util/common/keep
strategies

/**
  * Sets the 'keep' level.
  *
  * E.g. <set-keep>4 sets the keep level to 4.
  */
  set-keep =
    <set-config> ("--keep", <id>)

 /**
  * Give the current 'keep' level. Default is 0.
  */
  get-keep =
    <get-config> "--keep" <+ !0

 /**
  * Builds command-line parameter for 'keep' levels for calling XT tools.
  *
  * E.g. xtc-transform(!"abox2text", pass-keep ) passes the 'keep' level
  * to abox2text.
  */
  pass-keep =
    !["--keep", <subt; int-to-string>(<get-config <+ !1> "--keep", 1)]

/**
 * Apply the supplied strategy if the 'keep' level is set to a value greater
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-keep5(debug) calls the debug strategy if 'keep' level is > 5.
 *
 * @param strategy to be applied
 */
strategies

  if-keep(s|t) =
    if <geq> (<get-keep> (), t) then
      s
    end

  if-keep1(s) = if-keep(s|1)
  if-keep2(s) = if-keep(s|2)
  if-keep3(s) = if-keep(s|3)
  if-keep4(s) = if-keep(s|4)
  if-keep5(s) = if-keep(s|5)
  if-keep6(s) = if-keep(s|6)
  if-keep7(s) = if-keep(s|7)

/**
 * Apply the supplied strategy if the 'keep' level is set to a value lesser
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-less-keep3(s) calls the s strategy if 'keep' level is < 3.
 *
 * @param strategy to be applied
 */
strategies

 /**
  * @obsolete
  */
  if-less-keep1(s|t) = if-less-keep(s|t)

  if-less-keep(s|t) =
    if <leq> (<get-keep> (), t) then
      s
    end

  if-less-keep1(s) = if-keep(s|1)
  if-less-keep2(s) = if-keep(s|2)
  if-less-keep3(s) = if-keep(s|3)
  if-less-keep4(s) = if-keep(s|4)
  if-less-keep5(s) = if-keep(s|5)
  if-less-keep6(s) = if-keep(s|6)
  if-less-keep7(s) = if-keep(s|7)

// util/config/options
strategies

  /**
   * Wraps a strategy into a strategy handling options and io of terms.
   *
   * @param  strategy to apply on the input term
   */
  io-wrap(s) =
    io-wrap(fail, s)

  /**
   * Wraps a strategy into a strategy handling options and io of terms.
   *
   * @param   extra options besides the default io-options
   *          use fail if you have no additional options.
   * @param   strategy to apply on the input term
   */
  io-wrap(extra-opts, s) =
    io-wrap(extra-opts, system-usage, system-about, s)

  /**
   *
   * @param   extra options besides the default io-options.
   *          use fail if you have no additional options.
   *
   * @param   strategy to apply on the input term
   */
  io-wrap(extra-opts, usage, about, s) =
    option-wrap(extra-opts <+ io-options,  usage, about, id, io(s))

  output-wrap(s) =
    output-wrap(fail, s)

  output-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ output-options,  output(s))

  input-wrap(s) =
    input-wrap(fail, s)

  input-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ input-options,  input(s))

strategies

  /**
   * Wraps a strategy into a strategy that handles io options.
   *
   * Reads a term from the file specified by the -i option (or stdin).
   * Writes to a file specified by the -o option (or stdout).
   *
   * @param   strategy to apply on the input term
   */
  io(s) =
    input(output(s))

 /**
  * Wraps a strategy into a strategy that handles output options.
  *
  * Writes to a file specified by the -o option (or stdout).
  */
  output(s) =
      s
    ; !(<<get-config> "-o" <+ !stdout()>, <id>)
    ; ( where(<get-config> "-b") < WriteToBinaryFile + WriteToTextFile )

 /**
  * Wraps a strategy into a strategy that handles input options.
  *
  * Reads a term from the file specified by the -i option (or stdin).
  */
  input(s) =
      ( <get-config> "-i" <+ !stdin() )
    ; ReadFromFile
    ; s

/**
 * Stream based wrappers
 */
strategies

  /**
   * Wraps a strategy into a strategy that handles input and output options.
   * The strategy arguments is applied to a tuple of streams: the input and the output stream.
   *
   * @param (Stream, Stream) -> _
   */
  io-stream-wrap(s) =
    io-stream-wrap(fail, s)

  io-stream-wrap(extra-opts, s) =
    io-stream-wrap(extra-opts, system-usage, system-about, s)

  io-stream-wrap(extra-opts, usage, about, s) =
    option-wrap(extra-opts <+ io-options,  usage, about, id, io-stream(s))

  io-stream(s) =
    let open =
          open-stream <+ ?(<id>, _); perror; <exit> 1

     in fin  := <get-config < <open> (<id>, "r") + stdin-stream> "-i"
      ; fout := <get-config < <open> (<id>, "w") + stdout-stream> "-o"
      ; if <s> (fin, fout) then
          try(<fclose> fout); try(<fclose> fin)
          ; report-success
        else
            prim("SSL_stacktrace_get_all_frame_names") => trace
          ; try(<fclose> fout); try(<fclose> fin)
          ; try(<get-config> "-o"; remove-file)
          ; <report-failure> trace
        end
    end

strategies

  option-wrap(opts, s) =
    option-wrap(opts, system-usage, id, s)

  option-wrap(opts, usage, announce, s) =
    option-wrap(opts, usage, system-about, announce, s)

  /**
   * Read options, display help, report success or failure, call strategy
   */
  option-wrap(opts, usage, about, announce, s) =
    parse-options(opts, usage, about)
    ; announce
    ; (s; report-success <+ prim("SSL_stacktrace_get_all_frame_names") ; report-failure)

strategies

  /**
   * Handles all common options for a transformation tool.
   */
  io-options =
      input-option
    + aterm-output-option
    + general-options

  input-options =
      input-option
    + general-options

  output-options =
      aterm-output-option
    + general-options

  general-options =
      verbose-option
    + keep-option
    + statistics-option
    + aterm-lib-options

 /**
  * Allow all flag starting with -at-* (these are ATerm library flags)
  */
  aterm-lib-options =
    Option(
      string-starts-with(|"-at-")
    , id
    , fail
    )



  /**
   * Option specifcation for level of keeping intermediate results.
   */
  keep-option =
    ArgOption("-k" + "--keep"
    , where(<set-config> ("--keep", <string-to-int>))
    , !"-k i | --keep i  Keep intermediates (default 0)"
    )

  /**
   * Option specifcation for level of statistics printing
   */
  statistics-option =
    ArgOption("--statistics"
    , where(<set-config> ("--statistics", <string-to-int>))
    , !"--statistics i   Print statistics (default 0 = none)"
    )

  /**
   * Option specifications for reading input.
   *
   * Defines -i.
   */
  input-option =
    ArgOption("-i" + "--input"
    , where(<set-config> ("-i",<id>))
    , !"-i f|--input f   Read input from f"
    )

  /**
   * Option specifications for writing output.
   *
   * Defines -o.
   */
  output-option =
    ArgOption("-o" + "--output"
    , where(<set-config> ("-o",<id>))
    , !"-o f|--output f  Write output to f"
    )

  /**
   * Option specifications for ATerm output.
   *
   * Defines -b option for binary output.
   */
  aterm-output-option =
      output-option
    + Option("-b"
      , where(<set-config> ("-b",()))
      , !"-b               Write binary output"
      )

  /**
   * Option specifications for verbosity.
   *
   * Defines -S, --silent, --verbose and -s.
   */
  verbose-option =
      Option("-S"+"--silent"
      , where(<set-verbosity> 0)
      , !"-S|--silent      Silent execution (same as --verbose 0)"
      )
    + ArgOption("--verbose"
      , where(verbose-to-int; set-verbosity)
      , !"--verbose i      Verbosity level i (default 1)
                    ( i as a number or as a verbosity descriptor:
                      emergency, alert, critical, error,
                      warning, notice, info, debug, vomit )"
      )

strategies

  verbose-to-int =
      string-to-level
        <+
      string-to-int

  need-help(u) =
    <get-config> "--help"
    ; u

  if-not-silent(s) =
    test(verbosity => 0) <+ s

  report-success =
      report-run-time
    ; <exit> 0

  /**
   * Report the failure of this program. Must be applied to a list of
   * strings obtained by calling the SSL_stacktrace_get_all_frame_names
   * directly after the failure occurred (without any intervening calls
   * to any rules/strategies).
   *
   * @type List(String) -> _
   *
   * @param exit
   *          The exit strategy to use, e.g., xtc-exit.
   */
  report-failure(exit) =
      ?stacktrace
    ; report-run-time
    ; <fprintnl> (stderr(), [<log-src> (), ": rewriting failed, trace:"])
    ; <reverse ; map(<fprintnl> (stderr(), ["\t", <id>]))> stacktrace
    ; <exit> 1

  report-failure =
    report-failure(exit)

  report-failure(|message, term) =
    report-failure(
      log(|Critical(), message, term)
    ; <exit> 1
    )

  /**
   * Report the failure of this program, without showing a stack trace.
   *
   * @see report-failure
   * @see fatal-err(|msg)
   */
  report-failure-no-trace =
    report-failure-no-trace(exit)

  report-failure-no-trace(exit) =
      <fprintnl> (stderr(), [<log-src> (), ": rewriting failed"])
    ; <exit> 1

  whoami =
    <get-config> "program"

// util/config/parse-options
signature
  sorts Option
  constructors
    Program   : String  -> Option
    Undefined : String -> Option

strategies

  /**
   *  Always provide --help switch.
   */
  system-usage-switch =
      Option("--help" + "-h" + "-?"
      , <set-config> ("--help", ())
      , !"-h|-?|--help     Display usage information"
      )

  /**
   * Always provide the --about and --version switch.
   */
  system-about-switch =
      Option( "--about"
      , <set-config> ("--about", ())
      , !"--about          Display information about this program"
      )
    + Option("--version"
      , where(<set-config> ("--about", ()); <set-config> ("-v",()))
      , !"--version        Same as --about"
      )

/**
 * Parse command-line options
 */
strategies

  /**
   * Invokes system-usage and system-about on help and about.
   */
  parse-options(s) =
    parse-options(s, system-usage, system-about)

  /**
   * Parse options. Add system-usage switch and display usage info when user
   * specified '-h' switch.
   */
  parse-options(s, usage, about) =
    where(<table-put> ("usage-table", "usage", []))
    ; parse-options'(s <+ system-usage-switch <+ system-about-switch)
    ; try(
          where(<get-config> "--help")
        ; usage
        ; <exit> 0
      <+  where(<get-config> "--about")
        ; about
        ; <exit> 0
      <+  fetch(Undefined(?option))
        ; <fprintnl> (stderr(), ["Invalid option: ", option])
        ; usage
        ; <exit> 1
      )
    ; where(<table-destroy> "usage-table")

  /**
   * Register all usages of all defined switches; then parse switches as
   * specified by the user.
   */
  parse-options'(s)=
    ?[program | args]
    ; where(<set-config> ("program", program))

    ; where(id
        // apply s to register the usage info
        ; try(<s> "register-usage-info")

        // apply s to perform the initial actions
        ; try(<s> ("handle-init-action", args))
     )

    // apply s to handle the command-line options
    ; [!Program(<id>) | rec x(([] + s; [id|x]) <+ UndefinedOption)]

    ; where(id
        // apply s to perform the default actions
        ; try(<s> ("handle-default-action", args))

        // apply s to perform the check actions
        ; try(<s> ("handle-check-action", args))
      )

strategies

  /**
   * Register useage info 's' by storing 's' in the table "usage-table".
   * Use fail, such that program execution continues with the next
   * alternative Option or ArgOption. This way we collect all usage info.
   */
  register-usage(s) =
      <table-push>("usage-table", "usage", <s>())
    ; fail

  system-usage =
    override-system-usage
    <+ default-system-usage

  system-about =
    override-system-about
    <+ default-system-about

  /**
   * No default long description. Overrule to include program description in usage info.
   */
  short-description(s) =  fail

  /**
   * No default short description. Overrule to include in usage info.
   */
  long-description(s) =  fail


  /**
   * No override of the default system usage.
   */
  override-system-usage = fail

  /**
   * No override of the default system about.
   */
  override-system-about = fail

  /**
   * Default system usage that invokes the short-description and long-description hook.
   */
  default-system-usage =
    where(<get-config> "program" => p <+ option-defined(Program(?p)))
    ; default-system-usage(short-description(!p), long-description(!p))

  /**
   * Display usage info containing a short description of the program., if
   * defined, followed by the usages of all switches. Finally, the long
   * description of the program is displayed when it is defined.
   */
  default-system-usage(short, long) =
    (<get-config> "program" => p <+ option-defined(Program(?p)))
    ; try(short; echo)
    ; <echo> "\nOptions:"
    ; <table-get; reverse> ("usage-table", "usage")
    ; map(<echo> ["   ", <id>])
    ; <echo> "\nDescription:"
    ; try(long; if is-string then ![<id>] end; echo)

  /**
   * Just shows the name of the program.
   */
  default-system-about =
    <get-config; echo> "program"

rules

  Option(is-flag, label, s) :
    [flag|rest] -> [<label>()|rest]
    where
      <is-flag> flag

  Option(is-flag, label) =
    Option(is-flag, label, !"")

  /**
   * Registere usage info, when Option is applied to the term "register-usage-info"
   */
  Option(is-flag, label, s) =
     "register-usage-info"
     ; register-usage(s)

rules

  ArgOption(is-flag, label, s) :
    [flag, arg | rest] -> [<label> arg | rest]
  where <is-flag> flag

  ArgOption(is-flag, label) =
    ArgOption(is-flag, label, !"")

  ArgOption(is-flag, label, s) =
    "register-usage-info"
    ; register-usage(s)

rules

  Arg2Option(is-flag, label) =
    Arg2Option(is-flag, label, !"")

  Arg2Option(is-flag, label, s) :
    [flag, arg1, arg2 | rest] -> [<label> (arg1, arg2) | rest]
    where
      <is-flag> flag

  Arg2Option(is-flag, label, s) =
    "register-usage-info"
    ; register-usage(s)

rules

  UndefinedOption :
  [x | rest] -> [Undefined(x) | rest]

strategies

  option-defined(s) = fetch(s)

rules

  /**
   * The handlers argument of this ArgOption variant must be an OptionHandler.
   */
  Option(is-flag, handlers | msg) :
    [flag | rest] -> [<handlers> ("handle-user-action", flag) | rest]
    where
    <is-flag> flag

  /**
   * Handle a special action, which is specified by a tuple.
   */
  Option(is-flag, handlers | msg) =
    OptionHandlerHelper(is-flag, handlers)

rules

  /**
   * The handlers argument of this ArgOption variant must be an OptionHandler.
   */
  ArgOption(is-flag, handlers | msg) :
    [flag, arg | rest] -> [<handlers> ("handle-user-action", arg) | rest]
    where
    <is-flag> flag

  /**
   * Handle a special action, which is specified by a tuple.
   */
  ArgOption(is-flag, handlers | msg) =
    OptionHandlerHelper(is-flag, handlers)

/**
 * @param Initial action
 * @param Handle user-specified option
 * @param Default action (no user-specified option)
 * @param Check action (applied before all options, can be used to very invalid combinations)
 */
strategies

  OptionHandlerHelper(is-flag, handlers) =
    ?("handle-default-action", args)
    ; if not(<fetch(is-flag)> args) then
        handlers
      end
    ; fail

  OptionHandlerHelper(is-flag, handlers) =
    ?(action, _)
    ; where(not(!action => "handle-default-action"))
    ; handlers
    ; fail

  OptionHandler(user) =
    OptionHandler(id, user, id)

  OptionHandler(init, user, default) =
    ?("handle-init-action", args)
    ; <init> args

  OptionHandler(init, user, default) =
    ?("handle-user-action", arg)
    ; <user> arg

  OptionHandler(init, user, default) =
    ?("handle-default-action", args)
    ; <default> args

/**
 * Checks for command-line options.
 */
strategies

  /**
   * The exit parameter can
   * - be <exit> 1 for immediate failure
   * - be <set-config> "--help" to report the usage and exit.
   * - not fail: failure will silently be ignored
   */
  OptionCheck(exit, checks | msg) =
    ?("handle-check-action", <id>)
    ; ( checks
        <+ <fprintnl> (stderr(), [msg])
           ; exit
      )
    ; fail

  /**
   * Checks that this option is not used together with other options.
   */
  OptionNotCombinedCheck(is-flag, other-flags) =
    where(
      if fetch(is-flag) then
        if fetch(other-flags) then
          fail
        end
      end
    )

  /**
   * Checks that this option is specified just once, or not at all.
   */
  OptionZeroOrOneCheck(is-flag) =
    where(
      filter(is-flag)
      ; if ?[_, _ | _] then
          fail
        end
    )

  /**
   * Checks that this option is used exactly once.
   */
  OptionOneCheck(is-flag) =
    where(
      filter(is-flag)
      ; if ?[] + ?[_, _ | _] then
          fail
        end
    )

  /**
   * Checks that this option is used one or more times.
   */
  OptionOneOrMoreCheck(is-flag) =
    where(
      filter(is-flag)
      ; if ?[] then
          fail
        end
    )

// util/config/stats
strategies

/**
  * Sets the 'statistics' level.
  *
  * E.g. <set-statistics>4 sets the statistics level to 4.
  */
  set-statistics =
    <set-config> ("--statistics", <id>)

 /**
  * Give the current 'statistics' level. Default is 0.
  */
  get-statistics =
    <get-config> "--statistics" <+ !0

 /**
  * Builds command-line parameter for 'statistics' levels for calling XT tools.
  *
  * E.g. xtc-transform(!"abox2text", pass-statistics ) passes the 'statistics' level
  * to abox2text.
  */
  pass-statistics =
    !["--statistics", <subt; int-to-string>(<get-config <+ !1> "--statistics", 1)]

/**
 * Apply the supplied strategy if the 'statistics' level is set to a value greater
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-statistics5(debug) calls the debug strategy if 'statistics' level is > 5.
 *
 * @param strategy to be applied
 */
strategies

  if-statistics(s|t) =
    if <geq> (<get-statistics> (), t) then
      s
    end

  if-statistics1(s) = if-statistics(s|1)
  if-statistics2(s) = if-statistics(s|2)
  if-statistics3(s) = if-statistics(s|3)
  if-statistics4(s) = if-statistics(s|4)
  if-statistics5(s) = if-statistics(s|5)
  if-statistics6(s) = if-statistics(s|6)
  if-statistics7(s) = if-statistics(s|7)

/**
 * Apply the supplied strategy if the 'statistics' level is set to a value lesser
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-less-statistics3(s) calls the s strategy if 'statistics' level is < 3.
 *
 * @param strategy to be applied
 */
strategies

  if-less-statistics(s|t) =
    if <leq> (<get-statistics> (), t) then
      s
    end

  if-less-statistics1(s) = if-statistics(s|1)
  if-less-statistics2(s) = if-statistics(s|2)
  if-less-statistics3(s) = if-statistics(s|3)
  if-less-statistics4(s) = if-statistics(s|4)
  if-less-statistics5(s) = if-statistics(s|5)
  if-less-statistics6(s) = if-statistics(s|6)
  if-less-statistics7(s) = if-statistics(s|7)

// util/config/verbose
strategies

 /**
  * Sets the verbosity level.
  *
  * E.g. <set-verbosity> 4 sets the verbosity level to 4.
  *
  * @type Int -> _
  */
  set-verbosity =
    <set-config> ("--verbose", <id>)

 /**
  * Give the current verbosity level. Default is 1.
  *
  * @type _ -> Int
  */
  verbosity =
    <get-config> "--verbose" <+ !1

 /**
  * Builds command-line parameter for verbosity levels for calling XT tools.
  *
  * E.g. xtc-transform(!"abox2text", pass-verbose ) passes the verbosity level
  * to abox2text.
  *
  * @type _ -> List(String)
  */
  pass-verbose =
    !["--verbose", <verbosity; int-to-string> ()]

/**
 * Apply the supplied strategy if the verbosity level is set to a value greater
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-verbose5(debug) calls the debug strategy if verbosity level is > 5.
 *
 * @param strategy to be applied
 */
strategies

  if-verbose(s|t) =
    if <geq> (<verbosity> (), t) then
      s
    end

  if-verbose1(s) = if-verbose(s|1)
  if-verbose2(s) = if-verbose(s|2)
  if-verbose3(s) = if-verbose(s|3)
  if-verbose4(s) = if-verbose(s|4)
  if-verbose5(s) = if-verbose(s|5)
  if-verbose6(s) = if-verbose(s|6)
  if-verbose7(s) = if-verbose(s|7)

/**
 * Apply the supplied strategy if the verbosity level is set to a value lesser
 * than or equal to the number given in the strategy name.
 *
 * E.g. if-less-verbose3(debug) calls the debug strategy if verbosity level is < 3.
 *
 * @param strategy to be applied
 */
strategies

 if-less-verbose(s|t) =
    if <leq> (<verbosity> (), t) then
      s
    end

  if-less-verbose1(s) = if-less-verbose(s|1)
  if-less-verbose2(s) = if-less-verbose(s|2)
  if-less-verbose3(s) = if-less-verbose(s|3)
  if-less-verbose4(s) = if-less-verbose(s|4)
  if-less-verbose5(s) = if-less-verbose(s|5)
  if-less-verbose6(s) = if-less-verbose(s|6)
  if-less-verbose7(s) = if-less-verbose(s|7)

// util/date-format
strategies

  /**
   * @type List(String) * ComponentTime -> String
   */
  date-format:
    (ps, t) -> <map(<date-pattern-to-string <+ Fst> (<id>, t)); concat-strings> ps

strategies

  /**
   * @type String * ComponentTime -> String
   */
  date-pattern-to-string =
      ?(p, _)
    ; date-pattern-to-int
    ; <align-right> ('0', <int-to-string>, <string-length> p)

rules

  /**
   * @type String * ComponentTime -> Int
   */

  /* year */
  date-pattern-to-int : ("yyyy", ComponentTime(Date(y, _, _), _, _)) -> y
  date-pattern-to-int : ("yy",   ComponentTime(Date(y, _, _), _, _)) -> <<mod> (<id>, 100)> y

  /* month */
  date-pattern-to-int    : ("M",    ComponentTime(Date(_, m, _), _, _)) -> <month2index; inc> m
  date-pattern-to-int    : ("MM",   ComponentTime(Date(_, m, _), _, _)) -> <month2index; inc> m

  /**
   * @type String * ComponentTime -> String
   */

  /* month */
  date-pattern-to-string : ("MMM",  ComponentTime(Date(_, m, _), _, _)) -> <month2abbr> m
  date-pattern-to-string : ("MMMM", ComponentTime(Date(_, m, _), _, _)) -> <month2text> m

  /**
   * @type String * ComponentTime -> Int
   */
  /* day of */
  date-pattern-to-int    : ("d",    ComponentTime(Date(_, _, d), _, _)) -> d
  date-pattern-to-int    : ("dd",   ComponentTime(Date(_, _, d), _, _)) -> d
  date-pattern-to-int    : ("D",    ComponentTime(_, _, Dupl(_, dy)))   -> dy
  date-pattern-to-int    : ("DD",   ComponentTime(_, _, Dupl(_, dy)))   -> dy

  /**
   * @type String * ComponentTime -> String
   */
  /* day of */
  date-pattern-to-string : ("EEE",  ComponentTime(_, _, Dupl(dw, _)))   -> <day-of-week2abbr> dw
  date-pattern-to-string : ("EEEE", ComponentTime(_, _, Dupl(dw, _)))   -> <day-of-week2text> dw

  /* am/pm marker */
  date-pattern-to-string : ("a", ComponentTime(_, DayTime(h, _, _), _)) -> "a.m."
      where <leq-lt> (0, h, 12)

  date-pattern-to-string : ("a", ComponentTime(_, DayTime(h, _, _), _)) -> "p.m."
      where <leq-leq> (12, h, 23)

  /**
   * @type String * ComponentTime -> Int
   */
  /* hour */
  date-pattern-to-int : ("HH", ComponentTime(_, DayTime(h, _, _), _)) -> h
  date-pattern-to-int : ("kk", ComponentTime(_, DayTime(h, _, _), _)) -> <inc> h
  date-pattern-to-int : ("hh", ComponentTime(_, DayTime(0, _, _), _)) -> 12
  date-pattern-to-int : ("hh", ComponentTime(_, DayTime(h, _, _), _)) -> h
      where <leq-leq> (1, h, 12)

  date-pattern-to-int : ("hh", ComponentTime(_, DayTime(h, _, _), _)) -> <subt> (h, 12)
      where <leq-leq> (12, h, 23)

  date-pattern-to-int : ("KK", ComponentTime(_, DayTime(h, _, _), _)) -> h
      where <leq-lt> (0, h, 12)

  date-pattern-to-int : ("KK", ComponentTime(_, DayTime(h, _, _), _)) -> <subt> (h, 12)
      where <leq-leq> (12, h, 23)

  /* minutes */
  date-pattern-to-int : ("mm", ComponentTime(_, DayTime(_, m, _), _)) -> m

  /* seconds */
  date-pattern-to-int : ("ss", ComponentTime(_, DayTime(_, _, s), _)) -> s

/**
 * Translate a day constructor to corresponding abbreviation.
 *
 * E.g. <day-of-week2abbr>Monday() => "Mon"
 *
 * @type DayOfWeek -> String
 */
rules
  day-of-week2abbr : Sunday()    -> "Sun"
  day-of-week2abbr : Monday()    -> "Mon"
  day-of-week2abbr : Tuesday()   -> "Tue"
  day-of-week2abbr : Wednesday() -> "Wed"
  day-of-week2abbr : Thursday()  -> "Thu"
  day-of-week2abbr : Friday()    -> "Fri"
  day-of-week2abbr : Saturday()  -> "Sat"

/**
 * Translate a day constructor to a full text representation.
 *
 * E.g. <day-of-week2text>Tuesday() => "Tuesday"
 *
 * @type DayOfWeek -> String
 */
rules
  day-of-week2text : Sunday()    -> "Sunday"
  day-of-week2text : Monday()    -> "Monday"
  day-of-week2text : Tuesday()   -> "Tuesday"
  day-of-week2text : Wednesday() -> "Wednesday"
  day-of-week2text : Thursday()  -> "Thursday"
  day-of-week2text : Friday()    -> "Friday"
  day-of-week2text : Saturday()  -> "Saturday"


/**
 * Translate a month constructor to corresponding abbreviation.
 *
 * E.g. <month2abbr>September() => "Sep"
 *
 * @type Month -> String
 */
rules
  month2abbr : January()     -> "Jan"
  month2abbr : February()    -> "Feb"
  month2abbr : March()       -> "Mar"
  month2abbr : April()       -> "Apr"
  month2abbr : May()         -> "May"
  month2abbr : June()        -> "Jun"
  month2abbr : July()        -> "Jul"
  month2abbr : August()      -> "Aug"
  month2abbr : September()   -> "Sep"
  month2abbr : October()     -> "Oct"
  month2abbr : November()    -> "Nov"
  month2abbr : December()    -> "Dec"


/**
 * Translate a month constructor to a full text representation.
 *
 * E.g. <month2text>September() => "September"
 *
 * @type Month -> String
 */
rules
  month2text : January()     -> "January"
  month2text : February()    -> "February"
  month2text : March()       -> "March"
  month2text : April()       -> "April"
  month2text : May()         -> "May"
  month2text : June()        -> "June"
  month2text : July()        -> "July"
  month2text : August()      -> "August"
  month2text : September()   -> "September"
  month2text : October()     -> "October"
  month2text : November()    -> "November"
  month2text : December()    -> "December"

// util/log
signature
  constructors
    Emergency : Severity
    Alert     : Severity
    Critical  : Severity
    Error     : Severity
    Warning   : Severity
    Notice    : Severity
    Info      : Severity
    Debug     : Severity
    Vomit     : Severity

strategies

  debug-area(s|msg) =
      log(|Debug(), <conc-strings> ("entering area ", msg))
    ; s
    ; log(|Debug(), <conc-strings> ("leaving area ",  msg))

  risky(s|msg) =
    risky(s|Error(), msg)

  risky(s|severity, msg) =
    restore(s, log(|severity, msg, <id>))

strategies

  log(|severity : Severity, msg, term) =
    if-log-severity(
      log(|severity, msg)
      ; where(
          <copy-char; log-puts> (<add> (<severity-string; string-length> severity, 3), ' ')
        ; <write-in-text-to-stream> (<log-stream>, term)
        ; <log-puts> "\n"
        )
    | severity
    )

  log(|severity : Severity, msg) =
    if-log-severity(
      where(
        <try(not(is-list) ; ![<id>])>msg
      ; map(is-string <+ write-to-string)
      ; <concat-strings ; log-puts> ["[ ", <log-src>, " | ",  <severity-string> severity, " ] " | <id> ]
      ; <log-puts> "\n"
      )
    | severity
    )

  if-log-severity(s | severity) =
    if-verbose(s | <verbose-level> severity)

strategies

  log-stream =
    <get-config> "log-stream"
    <+ <getenv> "STRATEGO_LOG"
       ; <fopen> (<id>, "a")
    <+ <stderr-stream> ()

  set-log-stream =
    <set-config> ("log-stream", <id>)

  log-puts =
    <fputs> (<id>, <log-stream> ())

  log-src =
    whoami; base-filename
    <+ !"identity crisis"

rules

  verbose-level : Emergency() -> -10
  verbose-level : Alert()     -> -5
  verbose-level : Critical()  -> -2
  verbose-level : Error()     -> 0
  verbose-level : Warning()   -> 1
  verbose-level : Info()      -> 1
  verbose-level : Notice()    -> 2
  verbose-level : Debug()     -> 4
  verbose-level : Vomit()     -> 10

  severity-string : Emergency() -> "emergency"
  severity-string : Alert()     -> "alert"
  severity-string : Critical()  -> "critical"
  severity-string : Error()     -> "error"
  severity-string : Info()      -> "info"
  severity-string : Warning()   -> "warning"
  severity-string : Notice()    -> "notice"
  severity-string : Debug()     -> "debug"
  severity-string : Vomit()     -> "vomit"

  string-to-level : "emergency" -> level
    where <verbose-level> Emergency() => level

  string-to-level : "alert"     -> level
    where <verbose-level> Alert() => level

  string-to-level : "critical"  -> level
    where <verbose-level> Critical() => level

  string-to-level : "error"     -> level
    where <verbose-level> Error() => level

  string-to-level : "warning"   -> level
    where <verbose-level> Warning() => level

  string-to-level : "notice"    -> level
    where <verbose-level> Notice() => level

  string-to-level : "info"      -> level
    where <verbose-level> Info() => level

  string-to-level : "debug"     -> level
    where <verbose-level> Debug() => level

  string-to-level : "vomit"     -> level
    where <verbose-level> Vomit() => level

strategies

  /**
   * Logs the specified message as critical and terminates the program
   * with exit code 1.
   *
   * @type a -> _
   */
  fatal-err(|msg : String) =
    log(|Critical(), msg, <id>); <exit> 1

  /**
   * Logs the specified message as an error.
   *
   * @type a -> a
   */
  err(|msg : String) =
    log(|Error(), msg, <id>)

  /**
   * Logs the specified message as a warning.
   *
   * @type a -> a
   */
  warn(|msg : String) =
    log(|Warning(), msg, <id>)

  /**
   * Logs the specified message as a notice.
   *
   * @type a -> a
   */
  notice(|msg : String) =
    log(|Notice(), msg, <id>)

  /**
   * Logs the specified message as a debug.
   *
   * @type a -> a
   */
  dbg(|msg : String) =
    log(|Debug(), msg, <id>)

strategies

  /**
   * Logs the specified message as critical and terminates the program
   * with exit code 1.
   *
   * @type a -> _
   */
  fatal-err-msg(|msg : String) =
    log(|Critical(), msg); <exit> 1

  /**
   * Logs the specified message as an error.
   *
   * @type a -> a
   */
  err-msg(|msg : String) =
    log(|Error(), msg)

  /**
   * Logs the specified message as a warning.
   *
   * @type a -> a
   */
  warn-msg(|msg : String) =
    log(|Warning(), msg)

  /**
   * Logs the specified message as a notice.
   *
   * @type a -> a
   */
  notice-msg(|msg : String) =
    log(|Notice(), msg)

// util/sunit
strategies

  test-suite(name, tests) =
    name
    ; debug(!"test suite: ")
    ; init-record
    ; tests
    ; report-test
    ; check-for-failures

  apply-test(name, s, in-term, out) =
    do-test(name,
            (sunit-create-input(in-term); s <+ <print-failure> "  strategy failed"; fail) => tmp;
        sunit-create-output(out) => tmp';
      ((!tmp' => tmp)
               <+ (<print-failure(|"  result not equal : ")> tmp;
                   <print-failure(|"  expected         : ")> tmp'); fail))

  apply-test(name, s, in-term) =
    do-test(name,
      (sunit-create-input(in-term); s <+ <print-failure> "  strategy failed"; fail)
    )

  apply-and-check(name, s, in-term, check) =
    do-test(name,
      (sunit-create-input(in-term); s  <+ <print-failure> "  application failed"; fail)
      ; (check <+ (print-failure(|"  check failed: "); fail))
    )

  apply-and-fail(name, s, in-term) =
    apply-and-fail(name, s, in-term, !())

  apply-and-fail(name, s, in-term, out) =
    do-test(name,
      ((sunit-create-input(in-term); not(s))
             <+ <print-failure> "  succeeded (should fail)"; fail))

  apply-and-show(name, s, in-term) =
    do-test(name
     ,(sunit-create-input(in-term); s <+ <print-failure> "  strategy failed"; fail)
            ; <debug> ["  succeeded; result: ", <id>]
           )

/**
 * Term arguments variants of the old sunit strategies
 */
strategies

  apply-test(s | name, in-term, out) =
    apply-test(!name, s, !in-term, !out)

  apply-test(s | name, in-term) =
    apply-test(!name, s, !in-term)

  apply-and-check(s | name, in-term, check) =
    apply-and-check(!name, s, !in-term, !check)

  apply-and-fail(s | name, in-term) =
    apply-and-fail(!name, s, !in-term)

  apply-and-fail(s | name, in-term, out) =
    apply-and-fail(!name, s, !in-term, !out)

  apply-and-show(s | name, in-term) =
    apply-and-show(!name, s, !in-term)

/**
 * Internal helpers
 */
strategies

  sunit-create-input(s) =
    s <+ say(!"error: input strategy for this test failed"); fail

  sunit-create-output(s) =
    s <+ say(!"error: output strategy for this test failed"); fail

  do-test(nr, s) =
    where(nr; debug)
    ; (where(s); record-success
       <+ record-failure)

  testing(nr, s) =
    do-test(nr, s; debug(!"  succeeded: ")
      <+ debug(!"  failed: "); fail)

  do-test(s | nr) =
    where(<debug>nr )
  ; ( where(s) ; record-success <+ record-failure )

/**
 * Test results are stored in a tuple of two integers. This tuple is
 * passed from test to test. (success, failure)
 */
strategies

  init-record =
    !(0,0)

  /**
   * Internal: record a successful test
   */
  record-success =
    (inc, id)

  /**
   * Internal: record a failed test
   */
  record-failure =
    (id, inc)

  /**
   * Internal: fails if there was a failure
   */
  check-for-failures =
    (id, 0)

  /**
   * Internal: report the number of successes and failures
   */
  report-test =
    (debug(!"successes: "), debug(!"failures: "))

  print-failure =
    sunit-failure-string
    ; debug

  print-failure(|msg) =
    debug(<sunit-failure-string> msg)

strategies

  /**
   * @type String -> String
   */
  sunit-failure-string =
    if <getenv> "ENABLE_COLORS" => "true" then
      <concat-strings> [
        <sunit-color-red>
      , <id>
      , <sunit-color-plain>
      ]
    end

  sunit-color-red =
    <conc-strings> (<implode-string> [27], "[01;31m")

  sunit-color-plain =
    <conc-strings> (<implode-string> [27], "[m")

// util/time
signature
  constructors
    EpochTime     : Int -> EpochTime

    ComponentTime : Date * DayTime * ComponentTimeDupl -> ComponentTime
    DayTime       : Int * Int * Int -> DayTime // Hours, Minutes, Seconds
    Date          : Int * Month * Int -> Date    // Year, DayOfMonth
    Dupl          : Int * Int -> ComponentTimeDupl // DayOfWeek, DayOfYear

  constructors
    January   : Month
    February  : Month
    March     : Month
    April     : Month
    May       : Month
    June      : Month
    July      : Month
    August    : Month
    September : Month
    October   : Month
    November  : Month
    December  : Month

  constructors
    Sunday    : DayOfWeek
    Monday    : DayOfWeek
    Tuesday   : DayOfWeek
    Wednesday : DayOfWeek
    Thursday  : DayOfWeek
    Friday    : DayOfWeek
    Saturday  : DayOfWeek

strategies

 /**
  * Strategy time returns the time since the Epoch (00:00:00 UTC, January 1, 1970),
  * measured in seconds. It is an alias of now-epoch-time.
  */
  time =
    prim("SSL_time")

  // :: _ -> EpochTime
  now-epoch-time =
    prim("SSL_now_epoch_time"); !EpochTime(<id>)

  // :: _ -> ComponentTime
  now-local-time =
      now-epoch-time; epoch2local-time

  // :: _ -> ComponentTime
  now-UTC =
      now-epoch-time; epoch2UTC

  // :: EpochTime -> ComponentTime
  epoch2local-time =
    ?EpochTime(t); prim("SSL_epoch2localtime", t); prim-tuple-to-ComponentTime

  // :: EpochTime -> ComponentTime
  epoch2utc =
    ?EpochTime(t); prim("SSL_epoch2UTC", t); prim-tuple-to-ComponentTime

  epoch2UTC =
    ?EpochTime(t); prim("SSL_epoch2UTC", t); prim-tuple-to-ComponentTime

  // :: ComponentTime -> DayTime
  just-day-time =
    ?ComponentTime(_, <id>, _)

  // :: ComponentTime -> Date
  just-date =
    ?ComponentTime(<id>, _, _)

  prim-tuple-to-ComponentTime:
    (s, mi, h, dm, mo, y, dw, dy)
      ->
    ComponentTime(Date(y, <index2month> mo, dm), DayTime(h, mi, s) , Dupl(<index2day-of-week> dw, dy))


/**
 * Translates a day index into the corresponding day constructor. Sunday is the beginning
 * of the week, starting with day 0.
 *
 * E.g.
 * <index2day-of-week>0 => Sunday()
 * <index2day-of-week>6 => Saturday()
 */
rules
  // :: Int -> DayOfWeek
  index2day-of-week : 0 -> Sunday()
  index2day-of-week : 1 -> Monday()
  index2day-of-week : 2 -> Tuesday()
  index2day-of-week : 3 -> Wednesday()
  index2day-of-week : 4 -> Thursday()
  index2day-of-week : 5 -> Friday()
  index2day-of-week : 6 -> Saturday()

/**
 * Translates a day constructor into the corresponding day index. Sunday is the beginning
 * of the week, starting with day 0.
 *
 * E.g.
 * <day-of-week2index>Sunday()    => 0
 * <day-of-week2index>Wednesday() => 3
 */
rules
  // :: DayOfWeek -> Int
  day-of-week2index : Sunday()    -> 0
  day-of-week2index : Monday()    -> 1
  day-of-week2index : Tuesday()   -> 2
  day-of-week2index : Wednesday() -> 3
  day-of-week2index : Thursday()  -> 4
  day-of-week2index : Friday()    -> 5
  day-of-week2index : Saturday()  -> 6

/**
 * Translates a month constructor into the corresponding month index. The year
 * starts with January which has index 0.
 *
 * E.g.
 * <month2index>January()   => 0
 * <month2index>September() => 8
 */
rules
  // :: Month -> Int
  month2index : January()     ->  0
  month2index : February()    ->  1
  month2index : March()       ->  2
  month2index : April()       ->  3
  month2index : May()         ->  4
  month2index : June()        ->  5
  month2index : July()        ->  6
  month2index : August()      ->  7
  month2index : September()   ->  8
  month2index : October()     ->  9
  month2index : November()    -> 10
  month2index : December()    -> 11

/**
 * Translates a month index into the corresponding month constructor. The year
 * starts with January which has index 0.
 *
 * E.g.
 * <index2month>0  => January()
 * <index2month>10 => November()
 */
rules
  // :: Int -> Month
  index2month : 0  -> January()
  index2month : 1  -> February()
  index2month : 2  -> March()
  index2month : 3  -> April()
  index2month : 4  -> May()
  index2month : 5  -> June()
  index2month : 6  -> July()
  index2month : 7  -> August()
  index2month : 8  -> September()
  index2month : 9  -> October()
  index2month : 10 -> November()
  index2month : 11 -> December()

strategies

  // RELATIVE TIME ; TIME OF PROCESS

 clock-to-seconds =
    ?c; prim("SSL_ClockToSeconds", c)

  clock =
    prim("SSL_clock")

// system/c99/fallback-posix
strategies

  report-run-time =
    id

// system/c99/file
strategies

  /**
   * Alternative to the POSIX+XSI copy-file
   */
  copy-file =
    ?(oldname, newname)
    ; prim("SSL_copy", oldname, newname)

  /**
   * Alternative to the POSIX+XSI rename-file
   */
  rename-file =
    ?(oldname, newname)
    ; prim("SSL_rename", oldname, newname)

// system/io/char
strategies

  /**
   * Reads the contents of a textfile.
   *
   * @type String -> String
   */
  read-text-file =
    ?file
    ; <fopen> (file,"r") => stream
    ; read-text-from-stream
    ; where(<fclose> stream)

  /**
   * Reads all characters until EOF.
   * The stream is not closed.
   *
   * @type Stream -> String
   */
  read-text-from-stream =
      ?stream
    ; rec x(![<fgetc> stream | <x> ()] <+ ![])
    ; implode-string

  /**
   * Reads the next line of text in stream.
   * Line is ended by newline or EOF.
   *
   * @type Stream -> String
   */
  read-text-line =
    ?stream
    ; rec x(![<fgetc; not('\n')> stream | <x> ()] <+ ![])
    ; implode-string

strategies

  /**
   * Filters the contents of a textfile character chunk by character chunk.
   *
   * 'done' determines when a chunk is complete
   *        should fail to indicate completeness
   *
   * 'more' transforms current chunck after adding next character
   *        should always succeed
   *
   * Note that the charachters in a chunk are in reverse order.
   *
   * @type (String, String) -> String
   */
  filter-text-file(more, done) :
    (filein, fileout) -> fileout
    where <fopen>(filein, "r") => streamin
        ; <fopen>(fileout, "w") => streamout
        ; repeat(
            for(![<fgetc> streamin]; more, done, ![<fgetc> streamin | <id>]; more)
            ; reverse-map(<fputc> (<id>, streamout))
          )
        ; <fclose> streamin
        ; <fclose> streamout

// system/io/dir
strategies

  /**
   * Removes a file from a directory.
   */
  remove-file =
    ?name; prim("SSL_remove", name)

 /**
  * The  getenv() function searches the environment list for a
  * string that matches the string pointed to  by  name.   The
  * strings are of the form name = value.
  */
  getenv =
    ?name; prim("SSL_getenv", name)

strategies

  home-dir =
    <getenv> "HOME"

// system/io/file
/**
 * Stream and file representations
 */
signature
  constructors
    Stream    : ImplDep -> Stream

    Path      : String -> FileLoc

    stdin     : FileLoc
    stdout    : FileLoc
    stderr    : FileLoc

/**
 * Abstractions for streams
 */
strategies

  /**
   * Opens a Stream associated to a FileLoc
   *
   * @type (FileLoc, String) -> Stream
   */
  open-stream = ?(_, _);
    (  Fst; stdio-stream
    <+ (?Path(<id>), id); fopen
    <+ (is-string,   id); fopen
    )

  /**
   * @type FileLoc -> Stream
   */
  stdio-stream = ?stdin() ; stdin-stream
  stdio-stream = ?stdout(); stdout-stream
  stdio-stream = ?stderr(); stderr-stream

  /**
   * Returns the Stream for stdin, stdout and stderr
   *
   * @type _ -> Stream
   */
  stdin-stream  = prim("SSL_stdin_stream") ; !Stream(<id>)
  stdout-stream = prim("SSL_stdout_stream"); !Stream(<id>)
  stderr-stream = prim("SSL_stderr_stream"); !Stream(<id>)

/**
 * Stream operations
 */
strategies

  /**
   * Opens the file whose name is the string pointed to by
   * pathname and returns a Stream associated with this file.
   * For documentation on the mode string, see the man page of
   * fopen.
   *
   * fails if the file couldn't be opened.
   *
   * @type String * String -> Stream
   */
  fopen =
    ?(pathname, mode); prim("SSL_fopen", pathname, mode); !Stream(<id>)

  /**
   * Dissociates the named stream from its underlying file or set of functions.
   * If the stream was being used for output, any buffered data is written
   * first, using fflush(3).
   *
   * @type Stream -> ()
   */
  fclose =
    ?Stream(stream); prim("SSL_fclose", stream)
      <+ ?stream-old; prim("SSL_fclose", stream-old) // legacy

  /**
   * Forces a write of all user-space buffered data for the given Stream
   *
   * @type Stream -> Stream
   */
  fflush =
    ?Stream(stream); prim("SSL_fflush", stream); !Stream(<id>)
    <+ ?stream-old; prim("SSL_fflush", stream-old); !Stream(<id>) // legacy

/**
 * Character output to stream
 */
strategies

  /**
   * Writes a String to a Stream
   * @type (String, Stream) -> Stream
   */
  fputs =
    ?(s, Stream(stream)); prim("SSL_fputs", s, stream); !Stream(<id>)

  /**
   * Writes a String to stdout with a trailing newline and returns stdout.
   *
   * @type String -> Stream
   */
  puts =
    ?s; prim("SSL_puts", s); !Stream(<id>)

  /**
   * Writes a Char to a Stream
   *
   * @type (Char, Stream) -> Stream
   */
  fputc =
    ?(c, Stream(stream)); prim("SSL_fputc", c, stream); !Stream(<id>)

/**
 * Character input from stream
 */
strategies

  /**
   * fgetc() reads the next character from the stream and returns the
   * ASCII code of the character as an Int. Fails on end of file or error.
   *
   * @type Stream -> Char
   */
  fgetc =
    ?Stream(stream); prim("SSL_fgetc", stream)

/**
 * tmpnam
 */
strategies

  tmpnam =
    prim("SSL_tmpnam")

/**
 * Components of a pathname
 */
strategies

  /**
   * Returns directory portion of pathname in a POSIX compatible way,
   * after converting all backslashes to forward slashes.
   *
   * @inc   dirname
   * @type  String -> String
   */
  dirname =
    string-as-chars(
      /* (0) Convert backslashes to forward slashes */
      all(try(\'\' -> '/'\))
    ; /* (1) Strip trailing slashes */
      try(split-init-last; ?(<id>, '/'))
    ; /* (2) If string consists entirely of slash characters, string shall be
             set to a single slash character.  In this case, skip steps (3)
             through (8). */
    ( ?[]
      < !['/']
      + ( /* (3) If there are any trailing slash characters in string, they
                 shall be removed. */
          init
          /* (4) If there are no slash characters remaining in string, string
                 shall be set to a single period character.  In this case, skip
                 steps (5) through (8).

             (5) If there are any trailing nonslash characters in string,
                 they shall be removed. */

        ; repeat(split-init-last; (id, not(?'/')); Fst)
        ; (?[]
          < !['.']
          + ( /* (7) If there are any trailing slash characters in string, they
                   shall be removed. */
              repeat(split-init-last; ?(<id>, '/'))
            ; (?[] < !['/'] + id))))))

  /**
   * Succeeds if the input pathname is an absolute path.
   *
   * A pathname is considered absolute if it starts with a /, a \,
   * X:/ or X:\ for any letter X.
   *
   * @type  String -> String
   * @since 0.9.4
   * @inc   is-abs-path
   */
  is-abspath =
    where(explode-string; (?[<'/' + '\'> | _] + ?[<is-alpha>, ':', <'/' + '\'> | _]))

  /**
   * Succeeds if the input pathname is a relative path.
   *
   * A pathname is relative if is-abspath fails.
   *
   * @type  String -> String
   * @since 0.9.4
   */
  is-relpath =
    not(is-abspath)

  /**
   * Strips the directory from a pathname.
   *
   * @type  String -> String
   * @inc   base-filename-test
   */
  base-filename =
      <string-tokenize> (['/','\'], <id>)
    ; last

/**
 * Strategies for file extensions
 */
strategies

  /**
   * Drops the current extension and replaces it with the specified extension.
   *
   * @type   String -> String
   * @since  0.15
   * @inc    guarantee-extension
   */
  guarantee-extension(|ext) =
    remove-extension
    ; <add-extension> (<id>, ext)

  /**
   * Checks if the file extension is ext.
   *
   * @param  The required extension (without . )
   * @type   String -> String
   * @since  0.15
   * @inc    has-extension
   */
  has-extension(|ext) =
    test-extension(?ext)

  /**
   * Tests if the file extension (everything after the . satisfies ext.
   *
   * @param  Test for the file extension. Is applied to the plain file extension (without the .)
   * @since  0.15
   * @inc    test-extension
   */
  test-extension(ext) =
    where(
      get-extension
      ; ext
    )

  /**
   * Adds an extension (second argument) to a path (first argument).
   *
   * @type (String, String) -> String
   */
  add-extension :
    (name, ext) -> <concat-strings> [name, ".", ext]

  /**
   * Remove an extension from a file name.
   * Returns the input if the file does not have an extension.
   *
   * @inc  remove-extension
   * @type String -> String
   */
  remove-extension =
    if get-extension; explode-string; !['.' | <id>] => ext then
      explode-string
      ; at-suffix(?ext; ![])
      ; implode-string
    end

  /**
   * Get extension from filename
   *
   * @type   String -> String
   */
  get-extension =
    explode-string
    ; list-tokenize(|['.'])

    /**
     * There should be at least two elements in the result, otherwise
     * there is not extension.
     */
    ; ?[_, _ | _]

    /**
     * The match of ?[base, ext] cannot be placed in at-suffix due to
     * the lack of unbinding of variables on backtracking.
     */
    ; at-suffix(?[_, _]; ?lastwo)
    ; !lastwo => [base, ext]
    ; where(
        /**
         * The n-th . part should not contain / \ :
         * in that case it is not a real extension
         */
        <not(fetch(?'/' + ?'\'))> ext

        /**
         * The (n-1)th part should not end with a / or \
         * in that case, part n is not a real extension.
         */
      ; <last; not(?'/' + '\')> base
      )
    ; <implode-string> ext

// system/io/process
/**
 * Terminating the Current Process
 */
strategies

  /**
   * Abort execution with exit value n.
   *
   * @type Int -> _
   */
  exit =
    ?n; prim("SSL_exit", n)

// system/io/term
/**
 * Term input and output
 */
strategies

  /**
   * <ReadFromFile> file reads the term in file.
   * The file needs to be in textual or binary ATerm format.
   *
   * @type File -> a
   */
  ReadFromFile =
      ( <open-stream> (<id>, "r")
      <+ <conc-strings; perror; fail> ("SSL/ReadFromFile ", <id>))
    ; where(read-from-stream => trm)
    ; fclose
    ; !trm

  /**
   * <WriteToBinaryFile> (file, term) writes term to file in BAF format.i
   *
   * @type File * a -> a
   */
  WriteToBinaryFile =
    WriteToFile(write-in-baf-to-stream)

  /**
   * <WriteToTextFile> (file, term) writes term to file in textual ATerm format.
   *
   * @type File * a -> a
   */
  WriteToTextFile =
    WriteToFile(write-in-text-to-stream; <fputc> ('\n', <id>))

  /**
   * <WriteToFile(s)> (file, term) writes term to file with the writer s.
   *
   * @type (Stream * a -> Stream) * File * a -> a
   */
  WriteToFile(writer) =
      ?(<id>, trm)
    ; <open-stream> (<id>, "w")
    ; <writer> (<id>, trm)
    ; fclose
    ; !trm

  open(file) =
    file; ReadFromFile

  save(file) =
    <WriteToTextFile> (<file>, <id>)

/**
 * ATerm input and output with streams
 *
 * @TODO move to io module.
 */
strategies

  /**
   * Writes an ATerm to a Stream.
   *
   * @type Stream * _ -> Stream
   */
  write-to-stream =
    write-in-baf-to-stream

  write-in-baf-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_baf", stream, term); !Stream(<id>)

  write-in-taf-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_taf", stream, term); !Stream(<id>)

  write-in-text-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_text", stream, term); !Stream(<id>)

  /**
   * Reads an ATerm from a Stream
   *
   * @type Stream -> _
   */
  read-from-stream =
    ?Stream(stream); prim("SSL_read_term_from_stream", stream)

  /**
   * Reads an ATerm from a String
   *
   * @type String -> _
   */
  read-from-string =
    ?s; prim("SSL_read_term_from_string", s)

  /**
   * Writes an ATerm to a String
   *
   * @type a -> String
   */
  write-to-string =
    ?t; prim("SSL_write_term_to_string", t)

  /**
   * Writes an ATerm to a binary string represented as a list of chars.
   *
   * @type a -> List(Char)
   */
  write-to-binary-string =
    ?t; prim("SSL_write_term_to_binary_string", t)

  /**
   * Writes an ATerm to a shared string represented as a list of chars.
   *
   * @type a -> List(Char)
   */
  write-to-shared-string =
    ?t; prim("SSL_write_term_to_shared_string", t)

strategies

  /**
   * Prints the terms to a stream. If a term is a string it is printed
   * without quotes, otherwise it is printed as a term.
   *
   * @type Stream * [a] -> Stream
   */
  fprint =
    (?Stream(_) <+ stdio-stream, id)
    ; ?(stream, <id>)
    ; map(
        where(
          is-string
        < <fputs> (<id>, stream)
        + <write-in-text-to-stream> (stream, <id>)
        )
      )
    ; !stream

  /**
   * fprint, followed by a newline.
   *
   * @type Stream * [a] -> Stream
   */
  fprintnl =
    fprint; <fputc> ('\n', <?Stream(_) <+ stdio-stream>)

 /**
  * Prints terms to a file. If \verb|ti| is a string it is printed without
  * quotes, otherwise it is printed as a term. \verb|printnl| has the same
  * behaviour, but also prints a newline after \verb|tn|.
  *
  * E.g. <print> (file, [t1,...,tn]) prints terms ti to file. Terms ti
  * that are strings are printed without quotes
  *
  * @obsolete use fprint
  */
  print =
    ?(stream, strs)
    ; obsolete(!"print: use fprint")
    ; fprint

 /**
  * Same as print, but prints a newline at the end.
  *
  * @obsolete use fprintnl
  */
  printnl =
    ?(stream, strs)
    ; obsolete(!"printnl: use fprintnl")

strategies

  /**
   * Prints the current term to stderr without changing it.
   * This is a useful strategy for debugging specifications (hence its name).
   *
   * @type  a -> a
   */
  debug =
    where(<fprintnl> (stderr(), [<id>]))

  /**
   * Prints the term produced by applying msg followed by the current term to stderr.
   *
   * @type  a -> a
   */
  debug(msg) =
    where(<fprintnl> (stderr(), [<msg>,<id>]))

strategies

  debug-depth =
    debug-depth(!4, !"")

  debug-depth(depth) =
    debug-depth(depth, !"")

  debug-depth(depth, s) =
    where(
      at-depth(depth, !"...")
    ; debug(s)
    )

strategies

  /**
   * Prints the term produced by applying msg to stderr.
   *
   * @param  term to print to stderr
   * @type   a -> a
   */
  say(msg) =
    where(msg; debug)

  trace(msg,s) =
    debug(msg); (s; debug(!"succeeded: ") <+ debug(!"failed: "))

  /**
   * Prints a list of terms to stderr using fprintnl.
   *
   * @type List(a) -> List(a)
   */
  error =
    where(<fprintnl> (stderr(), <id>))

  /**
   * Prints a list of terms to stderr using fprintnl and exits with code 1.
   *
   * @type List(a) -> List(a)
   */
  fatal-error =
    where(error; <exit> 1)

  /**
   * Prints giving-up to stderr and exits with code 1.
   *
   * @type _ -> _
   */
  giving-up =
    <fatal-error>["giving-up"]

  /**
   * Logs an obsolete strategy message with the given message.
   *
   * @param Strategy that produces a string message.
   * @type  a -> a
   */
  obsolete(msg) =
    log(|Warning(), <conc-strings> ("program uses obsolete strategy ", <msg> ()))

  /**
   * Tries to apply s and prints msg to stderr if this fails.
   * Risky preserves the failure of s: if s fails, then risky will
   * fail as well.
   *
   * @param Strategy that produces a string message
   * @param Strategy to apply
   * @type  a -> a
   */
  risky(msg, s) =
    restore(s, debug(msg))

/**
 * Print to the stdout. You usually don't want this.
 */
strategies

  echo =
    where(<fprintnl> (stdout(), <is-list <+ ![<id>]>))

  echo(msg) =
    where(<fprintnl> (stdout(), [<msg>,<id>]))

  printstring =
    where(<fprint> (stdout(), [<id>]))

// system/posix/file-abstractions
strategies

  /**
   * Return the absolute path of a pathname.
   *
   * @type  String -> String
   * @since 0.9.4
   */
  abspath =
      is-abspath
    < id
    + <concat-strings> [<getcwd> (), "/", <id>]

  file-newer =
    (modification-time, modification-time); gt

overlays

  Read      = R_OK()
  Write     = W_OK()
  Execute   = X_OK()
  Existence = F_OK()

strategies

  /**
   * @type  String -> String
   */
  file-exists =
    <access> (<id>, [F_OK()])

  /**
   * @type  String -> String
   */
  can-read-file =
    <access> (<id>, [R_OK()])

  is-readable = can-read-file

  /**
   * @type  String -> String
   */
  can-write-file =
    <access> (<id>, [W_OK()])

  is-writable = can-write-file

  /**
   * @type  String -> String
   */
  can-execute-file =
    <access> (<id>, [X_OK()])

  is-executable = can-execute-file

  /**
   * @type String -> String
   * @inc  create?
   */
  can-create-file =
    where(dirname; can-write-file)

/**
 * find files in paths
 *
 * @todo Create a file-exists based on fopen to make this code portable?
 */
strategies

  /**
   * Finds a file in a list of directories (a path).
   *
   * <find-path(strict|path)> f looks for a file with name f in the list of
   * directories path. If the file is not found the behaviour depends on the
   * strategy strict, if it succeeds a fatal-error is flagged, otherwise the
   * strategy just fails.
   *
   * Example (when run in strategoxt root):
   *   <find-in-path(id|["ssl/spec","ssl/tests"])> "file.str" => "ssl/spec/file.str"
   */

  find-in-path(strict|path) =
    ?file
    ; ( file-exists
      <+ <fetch-elem(<concat-strings; file-exists> [<id>,"/",file])> path
      <+ if strict then <fatal-error> ["no such file: ", file] else fail end
      )

  /**
   * Finds a file in a list of directories (a path).
   *
   * Differs from find-in-path/(0,0) in that it exits with fatal-error if file is
   * not found.
   *
   * @param should build a list of paths in which the search is performed.
   */

  find-in-path(|path) =
    find-in-path(id|path)

  /**
   * Finds a file in a list of directories (a path)
   *
   * @obsolete.
   *
   * This strategy operates on a tuple (f, [d*]) where f is the name of the file
   * to be found, and d* are the directories to search in. The full path of the
   * first match is the output term.
   *
   * Example (when run in strategoxt root):
   *   <find-in-path> ("file.str", ["ssl/spec", "ssl/tests"]) => "ssl/spec/file.str"
   */

  find-in-path =
    ?(file, path); <find-in-path(fail|path)> file

  /**
   * @obsolete
   */

  find-in-path(mkpath) =
    find-in-path(|<mkpath>)

  /**
   * Finds one file with a specific file extension in a list of directories.
   *
   * This strategy operates on a tuple (f, [d*]). The one file that will be
   * searched for is determined by the basename of f and the requested file
   * extension.
   * Example:
   *   <find-file(!"rtree")> ("file.str", ["."])
   * searches for file.rtree in the current dir.
   *
   * @param should build the file extension as a string.
   */

  find-file(|ext, path) =
    guarantee-extension(|ext)
    ; find-in-path(fail|path)

  find-file(|ext) =
    ?(file, path)
    ; <find-file(|ext, path)> file

  /**
   * @obsolete
   */
  find-file(ext) =
    find-file(|<ext>)

  /**
   * Finds one file with a specific file extension in a list of directories.
   *
   * Differs from find-file/(1,0) in that it exits with fatal error if file is
   * not found.
   *
   * @param should build a list of paths in which the search is performed.
   * @param should build the file extension as a string.
   */
  find-file(mkpath, ext) =
    guarantee-extension(|<ext>)
    ; find-in-path(|<mkpath>)

/**
 * Obsolete strategies
 */
strategies

  /**
   * Creates a fresh file in the current directory.
   *
   * @obsolete  use new-temp-file or XTC temporary files
   */
  new-file =
    obsolete(!"new-file; use new-temp-file or XTC temporary files")
    ; rec x(<conc-strings> (<new>(), ".tmp"); try(file-exists; x))

// system/posiz/file
/**
 * Standard file descriptors
 */
strategies

  // Standard input, equal to <fileno> stdin
  STDIN_FILENO =
    prim("SSL_STDIN_FILENO")

  // Standard output, equal to <fileno> stdout
  STDOUT_FILENO =
    prim("SSL_STDOUT_FILENO")

  // Standard error output, equal to <fileno> stderr
  STDERR_FILENO =
    prim("SSL_STDERR_FILENO")

/**
 * Terminal I/O
 */
strategies

  /**
   * Succeeds if file descriptor refers to a terminal device.
   */
  isatty =
    ?filedes; prim("SSL_isatty", filedes) => 1

/**
 * These  functions  return  information  about the specified
 * file.  You do not need any access rights to  the  file  to
 * get  this  information  but  you need search rights to all
 * directories named in the path leading to the file.
 */
strategies

  /**
   * Returns the modification time of a file in sections since
   * epoch.
   *
   * @type String -> Int
   */
  modification-time =
    ?file; prim("SSL_modification_time", file)

/**
 * File operations
 */
strategies

 /**
  * link-file creats a hard link from file 'new' to file 'old'.
  */
  link-file =
    ?(old, new); prim("SSL_link", old, new)

/**
 * Directories
 */
strategies

 /**
  * Given a path to a directory, returns a list of files in that directory,
  * including the self (.) and parent pointers (..).
  *
  * @type String -> List(String)
  */
  readdir =
    ?dir; prim("SSL_readdir", dir)

  /**
   * Returns the current working directory.
   */
  getcwd =
    prim("SSL_getcwd")

  /**
   * Change current working directory.
   *
   * @type String -> String
   */
  chdir =
    ?pathname; prim("SSL_chdir", pathname) => 0

  /**
   * Create directory
   *
   * @type String -> Int
   */
  mkdir(|mode) =
    where(
      ?pathname; prim("SSL_mkdir", pathname, mode) => 0
    )

  mkdir =
    mkdir(|[Read(), Write(), Execute()])

  /**
   * Remove empty directory
   *
   * @type String -> Int
   */
  rmdir =
    ?pathname; prim("SSL_rmdir", pathname) => 0

/**
 * Primitive file operations
 */
strategies

  /**
   * Opening a file
   */

  // create a file and return a file descriptor
  creat =
    ?pathname; prim("SSL_creat", pathname)

  // open a file and return a file descriptor
  open =
    ?pathname; prim("SSL_open", pathname)

  /**
   * Closing a file
   *
   * Deallocates a file descriptor
   */
  close =
    ?fd; prim("SSL_close", fd)

  /**
   * Duplicating a file descriptor
   */
  dup =
    ?fd; prim("SSL_dup", fd)

  dup2 =
    ?(fd1, fd2); prim("SSL_dup2", fd1, fd2)

  /**
   * checks the accessibility of the specified file wrt to the
   * specified permissions. Fails if the access is not allowed,
   * returns the path otherwise.
   *
   * @type (String, List(AccessPermission)) -> String
   *
   * @inc access
   */
  access =
    ?(path, permissions); prim("SSL_access", path, permissions)

signature
  constructors
    F_OK: AccessPermission
    R_OK: AccessPermission
    W_OK: AccessPermission
    X_OK: AccessPermission

/**
 * Connecting high and low level file operations
 */
strategies

  /**
   * The fdopen function associates a stream with the existing file
   * descriptor, fd.
   *
   * The mode of the stream ("r", "r+", "w", "w+",  "a", "a+") must be
   * compatible with the mode of the file descriptor.  The file position
   *
   * @type (FileDescr, String) -> Stream
   */
  fdopen =
    ?(fd, mode); prim("SSL_fdopen", fd, mode); !Stream(<id>)

  /**
   * The function fileno examines the argument stream and returns its
   * integer descriptor
   *
   * @type Stream -> FileDescr
   * @inc fileno
   */
  fileno =
    ?Stream(stream); prim("SSL_fileno", stream)

  /**
   * Mode of a file
   * @type String -> FileMode
   */
  filemode =
    ?pathname; prim("SSL_filemode", pathname); ?(<id>, 0)

  /**
   * @type File -> FileMode
   */
  isreg =
    ?mode; prim("SSL_S_ISREG", mode)

  /**
   * Succeeds when applied to a File which is a directory.
   *
   * Idiom: <file-exists ; filemode ; isdir> "/etc"
   *
   * @type File -> FileMode
   */
  isdir =
    ?mode; prim("SSL_S_ISDIR", mode)

  /**
   * @type File -> FileMode
   */
  ischr =
    ?mode; prim("SSL_S_ISCHR", mode)

  /**
   * @type File -> FileMode
   */
  isblk =
    ?mode; prim("SSL_S_ISBLK", mode)

  /**
   * @type File -> FileMode
   */
  isfifo =
    ?mode; prim("SSL_S_ISFIFO", mode)

  /**
   * @type File -> FileMode
   */
  islnk =
    ?mode; prim("SSL_S_ISLNK", mode)

  /**
   * @type File -> FileMode
   */
  issock =
    ?mode; prim("SSL_S_ISSOCK", mode)

/**
 * Pipes (and FIFOs)
 */
strategies

  /**
   * Pipe creates a pair Pipe(fd1, fd2) of file descriptors, pointing
   * to a pipe inode, and places them in the array pointed to by filedes.
   * fd1 is for reading, fd2 is for writing.
   *
   * @type _ -> Pipe
   */
  pipe =
    prim("SSL_pipe")

signature
  constructors
    Pipe       : Int * Int -> Pipe

// system/posix/pipe-abstractions
strategies

// connecting and/or disconnecting parts of a pipe

  // close both file descriptors constituting a pipe
  close-pipe =
  where(
    ?Pipe(fd1, fd2)
    ; <close> fd1
    ; <close> fd2
  )

  // connect the input side (fd1) of the pipe to stdin
  stdin-from-pipe =
  where(
    ?Pipe(fd1, fd2)
    ; <dup2> (fd1, <STDIN_FILENO>)
    ; <close> fd2
  )

  // create a file that is connected to input side (fd1) of the pipe
  file-from-pipe :
    Pipe(fd1, fd2) -> file
    where <fdopen> (fd1, "r") => file
        ; <close> fd2

  // connect the output side (fd2) of the pipe to stdout
  stdout-to-pipe =
  where(
    ?Pipe(fd1, fd2)
    ; <dup2> (fd2, <STDOUT_FILENO>)
    ; <close> fd1
  )

  // create a file that is connected to output side (fd2) of the pipe
  file-to-pipe :
    Pipe(fd1, fd2) -> file
    where <fdopen> (fd2, "w") => file
        ; <close> fd1

  write-term-to-text-pipe =
  where(
    ?(p, t)
    ; <file-to-pipe> p => outfile
    ; <fprint> (outfile, [t])
    ; <fclose> outfile
  )

  read-term-from-pipe :
    p -> t
    where <file-from-pipe> p => file
        ; <ReadFromFile> file => t
        ; <fclose> file

strategies

// Programs that interact with pipes

  // execute prog and write the current term to its stdin
  write-to-prog(prog, args) =
  where(
    where(pipe => p)
    ; fork(<stdin-from-pipe> p
           ; <execvp> (<prog>, <args>))
    ; ?(pid, t)
    ; <write-term-to-text-pipe> (p, t)
    ; <waitpid> pid
    ; (exited + signaled + stopped)
  )

  write-to-prog'(prog, args) =
  where(
    ?t
    ; pipe => p
    ; fork
    ; (?0 // child
          ; <stdin-from-pipe> p
          ; <execvp> (<prog>, <args>)
       <+ ?pid // parent
          ; <write-term-to-text-pipe> (p, t)
          ; <waitpid> pid
          ; (exited + signaled + stopped))
     )

  // execute prog and read the term on its stdout
  read-from-prog(prog, args) =
    where(pipe => p)
    ; fork(<stdout-to-pipe> p; <execvp> (<prog>, <args>))
    ; ?(pid, _)
    ; <read-term-from-pipe> p => t
    ; where(<waitpid> pid
            ; (exited + signaled + stopped))

  read-from-prog'(prog, args) =
  where(
    pipe => p
    ; fork
    ; (?0 // child
          ; <stdout-to-pipe> p
          ; <execvp> (<prog>, <args>)
       <+ ?pid // parent
          ; <read-term-from-pipe> p
          ; where( <waitpid> pid
                ; (exited + signaled + stopped)))
   )

strategies

// managing pipelines of filter programs

  setup-filter-pipe =
    pipe => p; !(p, [], p)

  // prog produces input for the pipe p
  pipe-source(prog, args) :
    (p, pids) -> pids
    where fork
        ; (?0; <stdout-to-pipe> p; <execvp> (<prog>, <args>)
           <+ ?pid)

  // prog consumes the output from pipe p
  pipe-sink(prog, args) :
    (p0, pids, p1) -> (p0, [pid | pids])
    where fork(<stdin-from-pipe> p1; <execvp> (<prog>, <args>)) => (pid, _)

  close-filter-pipe(s) :
    (p-in, pids, p-out) -> (p-in, [pid | pids])
    where <s> p-out => pid

  exec-filter-pipe(s) :
    (p-in, pids) -> ()
    where <s> p-in => pid
        ; <map(waitpid; (exited + signaled + stopped))> [pid | pids]

  spawn-filter-with-prog(prog, args) :
    (p0, pids, p-in) -> (p0, [pid | pids], p-out)
    where debug(<concat-strings> ["spawn-filter-with ", <prog>, ": "])
        ; pipe => p-out
        ; fork(<stdin-from-pipe> p-in
               ; <stdout-to-pipe> p-out
               ; <execvp> (<prog>, <args>)) => (pid, _)
      //; <close-pipe> p-in

/*
  file-to-file-filter(!infile, !outfile) :
    (p-in, pids, p-out) ->
    where <fopen> infile

  pipe-comm(prog, args, cont) :
    ?fd;

*/

// system/posix/process-abstractions
/**
 * Fork abstractions
 */
strategies

  /**
   * Executes "child" in the child process and returns a tuple
   * of the pid of the child process and the current term in the
   * parent process.
   */
  fork(child) =
    fork(child, id)

  fork(child, parent) =
    ?t; fork; ?pid; (?0 < <child> t + <parent> (pid, t))

  fork-and-wait(child) =
    fork(child, ?(<waitpid>, t); warn-ifsignaled; ?WaitStatus(0,_,_); !t)

/**
 * Call abstractions
 */
strategies

  /**
   * Call a program with list of string arguments.
   *
   * @type (String, List(String)) -> (String, List(String))
   */
//  call =
//    call(id)

//  call(init-child) =
//    ?(prog,args)
//    ; fork-and-wait(init-child; <execvp> (prog, args); <exit> 1)

  /**
   * Call program with a list of strings arguments and print
   * information to stderr.
   *
   * @type (String, List(String)) -> (String, List(String))
   */
  call-noisy =
    ?(prog,args)
    ; fork-and-wait(<debug; execvp> (prog, args))

/**
 * Termination abstractions
 */
strategies

  /**
   * Succeeds if the process of this WaitStatus exited.
   *
   * @type WaitStatus -> WaitStatus
   */
  exited =
    ?WaitStatus(s,_,_)
    ; where(<not(eq)> (s, -1))
    ; if-verbose3(debug(!"the process exited: "))

  /**
   * Succeeds if the process of this WaitStatus was signaled.
   *
   * @type WaitStatus -> WaitStatus
   */
  signaled =
    ?WaitStatus(_,s,_)
    ; where(<not(eq)> (s, -1))
    ; if-verbose2(debug(!"the process was signaled"))

  /**
   * Succeeds if the process of this WaitStatus was stopped.
   *
   * @type WaitStatus -> WaitStatus
   */
  stopped =
    ?WaitStatus(_,_,s)
    ; where(<not(eq)> (s, -1))
    ; if-verbose3(debug(!"the process stopped"))

  /**
   * Prints a warning if the process of this WaitStatus was signaled.
   *
   * @type WaitStatus -> WaitStatus
   */
  warn-ifsignaled =
    where(try(
      ?WaitStatus(_, <id>, _)
    ; not(?-1)
    ; signal-from-number
    ; signal-to-descr
    ; log(|Warning(),<concat-strings>["process signaled: ",<id>])
    ))

  /**
   * Execute program in a new process with list of string args,
   * with the specified exec strategy.
   *
   * Optionally you can define file descriptors to use for stdin, stdout,
   * stderr.
   *
   * @param  opt-fdin   Option(FileDescr)
   * @param  opt-fdout  Option(FileDescr)
   * @param  opt-fderr  Option(FileDescr)
   *
   * @type  (String, List(String)) -> ()
   */
//  call(|opt-fdin, opt-fdout, opt-fderr) =
//      ?(prog, args)
//      ; fork-and-wait(
//          <option(<dup2> (<id>, <STDIN_FILENO> ))> opt-fdin
//          ; <option(<dup2> (<id>, <STDOUT_FILENO>))> opt-fdout
//          ; <option(<dup2> (<id>, <STDERR_FILENO>))> opt-fderr
//          ; <execvp> (prog, args)
//          ; <exit> 1
//        )
//      ; !()

// system/posix/process
strategies

 /**
  * The  setenv() function adds the variable name to the
  * environment with the value value, if  name  does  not  already
  * exist.   If  name  does exist in the environment, then its
  * value is changed to value if  overwrite  is  non-zero;  if
  * overwrite  is zero, then the value of name is not changed.
  */
  setenv =
    ?(name, value, overwrite)
    ; where(prim("SSL_setenv", name, value, overwrite))

strategies

  /**
   * Return process identifier of current process
   *
   * @type _ -> Int
   */
  get-pid =
    prim("SSL_get_pid")

/**
 * Process creation
 */
strategies

  /**
   * Creates a child process almost equivalent to the parent process.
   *
   * The new process differs from the parent process
   * only in its PID and PPID, and in the fact that resource
   * utilizations  are  set  to  0. File locks and pending signals are not
   * inherited.
   *
   * Fails if forking fails, in which case no child process is created.
   * On success, the PID of the child process is returned  in  the  parent's
   * thread  of execution, and a 0 is returned in the child's thread of exe-
   * cution.
   *
   * @type fork :: a -> Int
   */
  fork =
    prim("SSL_fork")

  /**
   * Replaces the current process image with a new  process image.
   *
   * @see      man execvp
   * @warning  The first arugment is added in the runtime.
   */
  execvp =
    ?(file, argv)
    ; prim("SSL_execvp", file, argv)
    ; where(<conc-strings; perror; fail> ("SSL/execvp: Cannot execute file ", file))

  /**
   * Replaces the current process image with a new  process image.
   *
   * @see      man execv
   * @warning  The first arugment is not added in the runtime.
   * @warning  If the
   */
  execv =
    ?(file, argv)
    ; prim("SSL_execv", file, argv)
    ; where(<conc-strings; perror; fail> ("SSL/execv: Cannot execute file ", file))

/**
 * Process termination
 */
strategies

  /**
   * @type Int -> WaitStatus
   */
  waitpid =
    ?pid; prim("SSL_waitpid", pid)

signature
  constructors
    /**
     * Collects the information returned from a wait call.
     *
     * (1) Exit status or -1 if process did not terminate properly
     * (2) Signal number or -1 if the process wasn't terminated because of a signal
     * (3) Signal number or -1 if the process wasn't stopped
     */
    WaitStatus : Int * Int * Int -> WaitStatus

/**
 * Terminating Another Process
 */
strategies

  /**
   * Sends the specified signal to the specified process.
   *
   * @fail fails on failure of the kill invocation
   * @type Int * Signal -> Int * Signal
   */
  kill =
    where(
      ?(pid, <number-from-signal; ?sig>)
    ; prim("SSL_kill", pid, sig)
    )

// system/process/signal
signature
  constructors
    Signal:        String * Int * String -> Signal
    UnknownSignal: Int -> Signal

strategies

  // :: Int -> Signal
  signal-from-number = ?i;
    ( <fetch-elem(?Signal(_, i, _))> AllSignals()
    <+ !UnknownSignal(i))

  // :: Signal -> Int
  number-from-signal :
    Signal(_, i, _) -> i

  number-from-signal :
    UnknownSignal(i) -> i

  // :: Signal -> String
  signal-to-descr :
    Signal(n, i, s) -> <concat-strings> [n, " (", <int-to-string> i, "): ", s]

  signal-to-descr :
    UnknownSignal(i) -> <concat-strings> ["Unknown signal (", <int-to-string> i, ")"]

overlays

 /**
  * Table containing all signals.
  */
  AllSignals =
    [ SIGHUP(),  SIGINT(),  SIGQUIT(), SIGABRT(), SIGKILL(),   SIGALRM(), SIGTERM()
    , SIGBUS(),  SIGCHLD(), SIGCONT(), SIGFPE(),  SIGILL(),    SIGPIPE(), SIGSEGV()
    , SIGSTOP(), SIGTSTP(), SIGTTIN(), SIGTTOU(), SIGURG(),    SIGUSR1(), SIGUSR2()
    , SIGPOLL(), SIGPROF(), SIGSYS(),  SIGTRAP(), SIGVTALRM(), SIGXCPU(), SIGXFSZ()
    ]

/**
 * POSIX
 */
overlays
  SIGHUP  = Signal("HUP",   1, "Hangup")
  SIGINT  = Signal("INT",   2, "Terminal interrupt")
  SIGQUIT = Signal("QUIT",  3, "Terminal quit")
  SIGABRT = Signal("ABRT",  6, "Process abort")
  SIGKILL = Signal("KILL",  9, "Kill")
  SIGALRM = Signal("ALRM", 14, "Alarm Clock")
  SIGTERM = Signal("TERM", 15, "Termination")

/**
 * POSIX 1003.1-2001
 */
overlays
  SIGBUS  = Signal("BUS",   7, "Access to an undefined portion of a memory object")
  SIGCHLD = Signal("CHLD", 17, "Child process terminated, stopped, or continued")
  SIGCONT = Signal("CONT", 18, "Continue executing, if stopped")
  SIGFPE  = Signal("FPE",   8, "Erroneous arithmetic operation")
  SIGILL  = Signal("ILL",   4, "Illegal Instruction")
  SIGPIPE = Signal("PIPE", 13, "Write on a pipe with no one to read it")
  SIGSEGV = Signal("SEGV", 11, "Invalid memory reference")
  SIGSTOP = Signal("STOP", 19, "Stop executing")
  SIGTSTP = Signal("TSTP", 20, "Terminal stop")
  SIGTTIN = Signal("TTIN", 21, "Background process attempting read")
  SIGTTOU = Signal("TTOU", 22, "Background process attempting write")
  SIGURG  = Signal("URG",  23, "High bandwidth data is available at a socket")
  SIGUSR1 = Signal("USR1", 10, "User-defined signal 1")
  SIGUSR2 = Signal("USR2", 12, "User-defined signal 2")

/**
 * POSIX 1003.1-2001, XSI extension
 */
overlays
  SIGPOLL   = Signal("POLL",    29, "Pollable event")
  SIGPROF   = Signal("PROF",    27, "Profiling timer expired")
  SIGSYS    = Signal("SYS",     31, "Bad system call")
  SIGTRAP   = Signal("TRAP",     5, "Trace/breakpoint trap")
  SIGVTALRM = Signal("VTALRM",  26, "Virtual timer expired")
  SIGXCPU   = Signal("XCPU",    24, "CPU time limit exceeded")
  SIGXFSZ   = Signal("XFSZ",    25, "File size limit exceeded")

// system/process/time
strategies

  /* The times() function stores the current process times in a quadruple
     (user time, system time, user time of children, system time of children)
     See man 2 times for more information */
  times =
    prim("SSL_times")

  ticks-to-seconds =
    ?t; prim("SSL_TicksToSeconds", t)

  diff-times :
    ((a1, b1, c1, d1), (a2, b2, c2, d2)) ->
    (<subt>(a1, a2), <subt>(b1, b2), <subt>(c1, c2), <subt>(d1, d2))

  add-times :
    ((a1, b1, c1, d1), (a2, b2, c2, d2)) ->
    (<add>(a1, a2), <add>(b1, b2), <add>(c1, c2), <add>(d1, d2))

  times-to-seconds :
    (a, b, c, d) ->
    (<ticks-to-seconds> a, <ticks-to-seconds> b, <ticks-to-seconds> c, <ticks-to-seconds> d)

  user-time :
    (a, b, c, d) -> a

  system-time :
    (a, b, c, d) -> b

  cuser-time :
    (a, b, c, d) -> c

  csystem-time :
    (a, b, c, d) -> d

  self-children-user-time :
    (a, b, c, d) -> <add>(a, c)

  self-children-sys-time :
    (a, b, c, d) -> <add>(b, d)

 /**
  * Total run-time so far.
  */
  run-time =
    times; crush(!0, add); ticks-to-seconds

  /**
   * Outputs the name of the program and the run time in seconds to
   * stderr.
   */
  report-run-time =
    if <geq>(<get-config> "--statistics", 1) then
      <fprintnl> (stderr(), [<whoami> (), " (", <run-time>, " secs)"])
    end

  profile(s) =
    where(times => start)
    ; s
    ; !(<id>, <<diff-times> (<times>, start); crush(!0, add)>)

  profile(msg, s) =
    where(times => start)
    ; s
    ; where(
        <diff-times
         ; <fprint> (stderr(), [<msg>
                             , " user ", <self-children-user-time; ticks-to-seconds>
                             , " system ", <self-children-sys-time; ticks-to-seconds>
           , "\n"])> (<times>, start)
      )

  profile'(msg, s) =
    where(times => start)
    ; s
    ; where(
  !(<times>, start)
        ; diff-times
        ; ![" user ",    <self-children-user-time; ticks-to-seconds>
           , " system ", <self-children-sys-time;  ticks-to-seconds>]
        ; msg
      )

// system/posix-xsi/file
strategies

  /**
   * Safe, mkstemp based, creation of temporary file
   *
   * @type _ -> (String, FileDescr)
   */
  new-temp-file =
      <conc-strings> (<temp-dir>, "/StrategoXT")
    ; mkstemp

  /**
   * Safe, mkdtemp based, creation of temporary directory
   *
   * @type  _ -> String
   */
  new-temp-dir =
      <conc-strings> (<temp-dir>, "/StrategoXT")
    ; mkdtemp

strategies

  temp-dir =
    <getenv> "TMPDIR"
    <+ P_tmpdir

  P_tmpdir =
    prim("SSL_P_tmpdir")

  /**
   * Creates a unique temporary file
   *
   * returns a fd if succesful, fails on error
   * @type String -> String * Int
   */
  mkstemp =
    <conc-strings> (<id>, "XXXXXX") => template
    ; prim("SSL_mkstemp", template)
    <+ <perror; fail> "SSL/mkstemp"

  /**
   * Creates a unique temporary directory
   *
   * returns a fd if succesful, fails on error
   * @type String -> String
   */
  mkdtemp =
    <conc-strings> (<id>, "XXXXXX") => template
    ; prim("SSL_mkdtemp", template)
    <+ <perror; fail> "SSL/mkdtemp"

strategies

 /**
  * rename renames a file, moving it between directories if required.
  * Any  other  hard links to the file (as created using link(2)) are unaffected.
  *
  * If newpath already exists it will be atomically replaced (subject to  a
  * few  conditions ~ see ERRORS below), so that there is no point at which
  * another process attempting to access newpath will find it missing.
  *
  * If newpath exists but the operation fails for some reason rename  guarantees
  * to leave an instance of newpath in place.
  *
  * From 0.9.4 this implementation copies the file if the primitive rename
  * fails because of an XDEV error.
  */
  rename-file =
      ?(oldname, newname)
    ; (  prim("SSL_rename", oldname, newname)
      <+ ( get-last-error => ErrorNumber(<EXDEV> ())
         < <copy-file> (oldname, newname)
           ; <remove-file> oldname
         + fail
         )
      )

 /**
  * Copy a file using memory mapped I/O.
  *
  * If newname is a directory the file is copied to a file in the directory
  * with the same base name as the old file.
  */
  copy-file =
    ?(oldname, newname)
    ; where(
        if <file-exists; filemode; isdir> newname then
          <concat-strings>[newname, "/", <base-filename> oldname]
        else !newname end => newname'
      )
    ; prim("SSL_copy", oldname, newname')

  fdcopy =
    ?(fdin, fdout); prim("SSL_fdcopy", fdin, fdout)

// system/posix-xsi/pipe-abstractions
strategies

  copy-pipe-to-file :
    (Pipe(fd1, fd2), name) -> name
    where <open>(name, "w") => fdout
        ; <fdcopy> (fd1, fdout)

// system/posix-xsi/time
strategies

  dtime =
    prim("SSL_dtime")

// system/error
signature
  constructors
    ErrorNumber : Int -> Error

strategies

  /**
   * @type    _ -> Error
   * @since   0.9.4
   */
  get-last-error =
    !ErrorNumber(<get-errno>)

  /**
   * @see     man errno
   * @type    _ -> Int
   * @since   0.9.4
   */
  get-errno =
    prim("SSL_get_errno")

  /**
   * Print a system error message.
   *
   * @see    man perror
   * @type   String -> String
   * @since  0.9.4
   */
  perror =
    ?s; prim("SSL_perror", s)

  /**
   * Return string describing error code
   *
   * @see    man strerror
   * @type   Int -> String
   * @since  0.9.4
   */
  strerror =
    ?s; prim("SSL_strerror", s)

strategies

  EXDEV = prim("SSL_EXDEV")
