module test

language strategoGT

fixture [[
  specification

  signature constructors
    Int : str -> Expr
    Add : Expr * Expr -> Expr

  rules
    [[...]]
]]

test Untyped Well-Formed AST [[
    untyped: e -> Add(e, e)
]] 0 errors

test Typed Well-Formed AST [[
    typed :: Expr -> Expr
    typed: e -> Add(e, e)
]] 0 errors

test Untyped Ill-Formed AST [[
    untyped: e -> Add(e, "1")
]] 0 errors

test Typed Ill-Formed AST gives error [[
    typed :: Expr -> Expr
    typed: e -> Add(e, [["1"]])
]] 1 error at #1
   0 warnings

test Typed Ill-Formed AST with indirection gives error in where clause [[
    typed :: Expr -> Expr
    typed: e1 -> Add(e1, e2)
    where e2 := [["1"]]
]] 1 error at #1
   0 warnings

test Typed Ill-Formed AST with more indirection gives error deep in where clause [[
    typed :: Expr -> Expr
    typed: e1 -> Add(e1, e2)
    where e2 := Add(Int("1"), [["1"]])
]] 1 error at #1
   0 warnings

test Typed Ill-Formed AST in annotation only gives warning [[
    typed :: Expr -> Expr
    typed: e -> Add(e, e){Add(Int("1"), [["1"]])}
]] 1 warning at #1

test Different types in different branches [[
  map :: (? -> ?|) List(?) -> List(?)
  map(s) = fail
  Snd :: ? * ? -> ?
  Snd = fail
  s = fail
  returns-a-list :: ? -> List(?)
  returns-a-list = fail
  do-something = fail
  returns-a-pair :: ? -> ? * ?
  returns-a-pair = fail
  something-else :: ? -> ?
  something-else = fail

  local-variable-type-inference: a -> b
  where if <s> a
    then c := <returns-a-list> a
       ; <map(do-something)> c // c :: List(?), no cast necessary
    else c := <returns-a-pair> a
       ; <Snd; do-something> c // c :: ? * ?, no cast necessary
    end
  ; b := <something-else> c // c :: ?, cast necessary when matching to anything
]] 0 errors
   0 warnings

test Dynamic type after different types in branches #1 [[
  map :: (? -> ?|) List(?) -> List(?)
  map(s) = fail
  Snd :: ? * ? -> ?
  Snd = fail
  s = fail
  returns-a-list :: ? -> List(?)
  returns-a-list = fail
  do-something = fail
  returns-a-pair :: ? -> ? * ?
  returns-a-pair = fail
  something-else :: List(?) -> ?
//  something-else :: ? * ? -> ?
  something-else = fail

  local-variable-type-inference: a -> b
  where if <s> a
    then c := <returns-a-list> a
       ; <map(do-something)> c // c :: List(?), no cast necessary
    else c := <returns-a-pair> a
       ; <Snd; do-something> c // c :: ? * ?, no cast necessary
    end
  ; b := <[[something-else]]> c // c :: ?, cast necessary when matching to anything
]] 0 errors
   0 warnings

test Dynamic type after different types in branches #2 [[
  map :: (? -> ?|) List(?) -> List(?)
  map(s) = fail
  Snd :: ? * ? -> ?
  Snd = fail
  s = fail
  returns-a-list :: ? -> List(?)
  returns-a-list = fail
  do-something = fail
  returns-a-pair :: ? -> ? * ?
  returns-a-pair = fail
//  something-else :: List(?) -> ?
  something-else :: ? * ? -> ?
  something-else = fail

  local-variable-type-inference: a -> b
  where if <s> a
    then c := <returns-a-list> a
       ; <map(do-something)> c // c :: List(?), no cast necessary
    else c := <returns-a-pair> a
       ; <Snd; do-something> c // c :: ? * ?, no cast necessary
    end
  ; b := <[[something-else]]> c // c :: ?, cast necessary when matching to anything
]] 0 errors
   0 warnings

test Duplicate type definitions not allowed [[
  something-else :: List(?) -> ?
  [[something-else]] :: ? * ? -> ?
  something-else = fail
]] 1 error at #1


